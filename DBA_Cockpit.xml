<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
	<name><![CDATA[DBA Cockpit]]></name>
	<tooltip><![CDATA[]]></tooltip>
	<description><![CDATA[Inspired by SAP DBA Cockpit

Author: anjul.sahu@accenture.com]]></description>
		<folder>
		<name><![CDATA[AWR]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
		</folder>
	<folder>
		<name><![CDATA[Configuration]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2c6fca29-014d-1000-8001-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_SYSAUX_AWRSize]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL CURRENT_AWR_RETENTION_DAYS, NULL TARGET_AWR_RETENTION_DAYS,
  NULL CURRENT_AWR_SPACE_GB, NULL TARGET_AWR_SPACE_GB,
  NULL DIFF_SPACE_GB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL CURRENT_AWR_RETENTION_DAYS, NULL TARGET_AWR_RETENTION_DAYS,
  NULL CURRENT_AWR_SPACE_GB, NULL TARGET_AWR_SPACE_GB,
  NULL DIFF_SPACE_GB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    TARGET_AWR_RETENTION_DAYS
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      42 TARGET_AWR_RETENTION_DAYS
    FROM
      DUAL
   ),
   ( SELECT DBID OWN_DBID FROM V$DATABASE )
)
SELECT
  TO_CHAR(CURRENT_AWR_RETENTION_DAYS, 9999999999999999999990.99) CURRENT_AWR_RETENTION_DAYS,
  TO_CHAR(TARGET_AWR_RETENTION_DAYS, 999999999999999999990.99) TARGET_AWR_RETENTION_DAYS,
  TO_CHAR(CURRENT_AWR_SPACE_GB, 9999999999999990.99) CURRENT_AWR_SPACE_GB,
  TO_CHAR(TARGET_AWR_RETENTION_DAYS / CURRENT_AWR_RETENTION_DAYS * 
    CURRENT_AWR_SPACE_GB, 999999999999990.99 ) TARGET_AWR_SPACE_GB,
  TO_CHAR(TARGET_AWR_RETENTION_DAYS / CURRENT_AWR_RETENTION_DAYS *
    CURRENT_AWR_SPACE_GB - CURRENT_AWR_SPACE_GB, 999999990.99) DIFF_SPACE_GB
FROM
( SELECT
    BI.TARGET_AWR_RETENTION_DAYS,
    TO_CHAR(ROUND(EXTRACT(DAY FROM HWC.RETENTION) +
      EXTRACT(HOUR FROM HWC.RETENTION) / 24 + 
      EXTRACT(MINUTE FROM HWC.RETENTION) / 1440, 2), 99990) CURRENT_AWR_RETENTION_DAYS,
    SO.SPACE_USAGE_KBYTES / 1024 / 1024 CURRENT_AWR_SPACE_GB
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC,
    GV$SYSAUX_OCCUPANTS SO
  WHERE
    BI.DBID = HWC.DBID AND
    BI.INSTANCE_NUMBER = SO.INST_ID AND
    SO.OCCUPANT_DESC = 
      'Server Manageability - Automatic Workload Repository'
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c711065-014d-1000-8002-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_AlertLogInfo_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL MESSAGE_TIME, NULL MESSAGE_TEXT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL MESSAGE_TIME, NULL MESSAGE_TEXT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    NUM_RECORDS,
    COMPONENT,
    LINE_PATTERN,
    ORDER_BY
  FROM
  ( SELECT
      TO_DATE('01.01.1000 10:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 15:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      100 NUM_RECORDS,
      'SERVER' COMPONENT,           /* '%' --> all logs, 'SERVER' --> traditional alert log, 'CLIENT', 'LISTENER' */
      '%ORA-%' LINE_PATTERN,
      'DESC' ORDER_BY
    FROM
      DUAL
  )
)
SELECT
  MESSAGE_TIME,
  MESSAGE_TEXT
FROM
( SELECT
    TO_CHAR(A.ORIGINATING_TIMESTAMP, 'dd.mm.yyyy hh24:mi:ss') MESSAGE_TIME,
    A.MESSAGE_TEXT,
    BI.NUM_RECORDS
  FROM
    BASIS_INFO BI,
    V$DIAG_ALERT_EXT A
  WHERE
    A.ORIGINATING_TIMESTAMP BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    ( BI.COMPONENT = '%' OR A.COMPONENT_ID = DECODE(BI.COMPONENT, 'SERVER', 
      'rdbms', 'CLIENT', 'client', 'LISTENER', 'tnslsnr') ) AND
    A.MESSAGE_TEXT LIKE BI.LINE_PATTERN
  ORDER BY
    DECODE(BI.ORDER_BY, 'ASC', RECORD_ID, 1), 
    DECODE(BI.ORDER_BY, 'DESC', RECORD_ID, 1) DESC
)
WHERE
  ROWNUM <= NUM_RECORDS
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c7234f4-014d-1000-8003-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Columns_EncryptedColumns]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL TABLE_NAME, NULL COLUMN_NAME, NULL ENCRYPTION_ALG,
  NULL SALT, NULL INTEGRITY_ALG FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TABLE_NAME, NULL COLUMN_NAME, NULL ENCRYPTION_ALG,
  NULL SALT, NULL INTEGRITY_ALG FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    :OWNER OWNER,
    :TABLE_NAME TABLE_NAME,
    :COLUMN_NAME COLUMN_NAME
  FROM
    DUAL
)
SELECT
  EC.OWNER,
  EC.TABLE_NAME,
  EC.COLUMN_NAME,
  EC.ENCRYPTION_ALG,
  EC.SALT,
  EC.INTEGRITY_ALG
FROM
  BASIS_INFO BI,
  DBA_ENCRYPTED_COLUMNS EC
WHERE
  EC.OWNER LIKE BI.OWNER AND
  EC.TABLE_NAME LIKE BI.TABLE_NAME AND
  EC.COLUMN_NAME LIKE BI.COLUMN_NAME
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[%]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[%]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="COLUMN_NAME">
						<prompt><![CDATA[COLUMN_NAME]]></prompt>
						<tooltip><![CDATA[COLUMN_NAME]]></tooltip>
						<value><![CDATA[%]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c75464b-014d-1000-8007-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Columns_VirtualColumns]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL TABLE_NAME, NULL COLUMN_NAME FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TABLE_NAME, NULL COLUMN_NAME FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    :OWNER OWNER
  FROM
    DUAL
)
SELECT
  TC.OWNER,
  TC.TABLE_NAME,
  TC.COLUMN_NAME
FROM
  BASIS_INFO BI,
  DBA_TAB_COLS TC
WHERE
  TC.OWNER LIKE BI.OWNER AND
  TC.VIRTUAL_COLUMN = 'YES'
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[%]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c77629a-014d-1000-8008-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_DDLDefinitions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL LINE FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL LINE FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */
    :OWNER OWNER,
    :OBJECT_TYPE OBJECT_TYPE,
    :OBJECT_NAME OBJECT_NAME,
    'X' COMPLEX_SQL_TEXT,      /* deactivation for large SQL statements useful */
    ' ' COMMA_AS_SPLITTER,
    'X' BLANK_AS_SPLITTER     
  FROM
    DUAL
),
SQL_TEXT_LOB AS 
( SELECT /*+ INLINE */
    SQL_TEXT,
    DBMS_LOB.GETLENGTH("SQL_TEXT") LENGTH,
    LENGTH(REGEXP_REPLACE(SQL_TEXT, '[^ ]', '')) NUM_BLANKS,
    LENGTH(REGEXP_REPLACE(SQL_TEXT, '[^,]', '')) NUM_COMMA
  FROM
  ( SELECT
      DBMS_METADATA.GET_DDL(BI.OBJECT_TYPE, BI.OBJECT_NAME, BI.OWNER) SQL_TEXT
    FROM
      BASIS_INFO BI
  )
),
START_POSITIONS AS
( SELECT 
    DECODE(ROWNUM, 
      1, 1, 
      NUM_BLANKS + 2, LENGTH + 1, 
      DBMS_LOB.INSTR(STL.SQL_TEXT, ' ', 1, ROWNUM - 1) + 1) POS
  FROM
    BASIS_INFO BI,
    SQL_TEXT_LOB STL,
    ( SELECT 1 FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 
      ( SELECT NUM_BLANKS + 2 FROM SQL_TEXT_LOB)
    )
  WHERE
    BI.COMPLEX_SQL_TEXT = 'X' AND
    BI.BLANK_AS_SPLITTER = 'X'
  UNION
  ( SELECT 
      DECODE(ROWNUM, 
        1, 1, 
        NUM_COMMA + 2, LENGTH + 1, 
        DBMS_LOB.INSTR(STL.SQL_TEXT, ',', 1, ROWNUM - 1) + 1) POS
    FROM
      BASIS_INFO BI,
      SQL_TEXT_LOB STL,
      ( SELECT 1 FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 
        ( SELECT NUM_COMMA + 2 FROM SQL_TEXT_LOB)
      )
    WHERE
      BI.COMPLEX_SQL_TEXT = 'X' AND
      BI.COMMA_AS_SPLITTER = 'X'
  )
),
START_END_POSITIONS AS
( SELECT 
    POS1,
    NVL(POS2, POS_OVERFLOW) POS2
  FROM
  ( SELECT
      SP1.POS POS1,
      MAX(SP2.POS) POS2,
      MIN(SP3.POS) POS_OVERFLOW
    FROM
      START_POSITIONS SP1,
      START_POSITIONS SP2,
      START_POSITIONS SP3
    WHERE
      SP2.POS (+) BETWEEN SP1.POS + 1 AND SP1.POS + 80 AND
      SP3.POS > SP1.POS
    GROUP BY
      SP1.POS
  )
),
START_END_LINE_POSITIONS AS
( SELECT  
    POS1,
    POS2
  FROM
    START_END_POSITIONS
  START WITH
    POS1 = 1
  CONNECT BY PRIOR 
    POS2 = POS1
  UNION ALL
  ( SELECT
      (R.ROWNUMBER - 1) * 80 + 1 POS1,
      R.ROWNUMBER * 80 + 1 POS2
    FROM
      BASIS_INFO BI,
      SQL_TEXT_LOB STL,
      ( SELECT ROWNUM ROWNUMBER FROM V$SESSTAT WHERE ROWNUM <= 1000 ) R
    WHERE
      BI.COMPLEX_SQL_TEXT = ' ' AND
      R.ROWNUMBER * 80 <= LENGTH(STL.SQL_TEXT) + 80
  )
)
SELECT
  TRANSLATE(DBMS_LOB.SUBSTR(STL.SQL_TEXT, SEP.POS2 - SEP.POS1, SEP.POS1), CHR(10) || CHR(9), ' ') LINE
FROM
  START_END_LINE_POSITIONS SEP, 
  SQL_TEXT_LOB STL
ORDER BY SEP.POS1
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="OBJECT_TYPE">
						<prompt><![CDATA[OBJECT_TYPE]]></prompt>
						<tooltip><![CDATA[OBJECT_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="OBJECT_NAME">
						<prompt><![CDATA[OBJECT_NAME]]></prompt>
						<tooltip><![CDATA[OBJECT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c795f01-014d-1000-8009-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Overview]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_OPTIMIZER_DISTINCT_AGG_TRANSFORM', 'FALSE') 
           OPT_PARAM('_PUSH_JOIN_UNION_VIEW', 'FALSE') 
           OPT_PARAM('_COMPLEX_VIEW_MERGING', 'FALSE') */ 
  NULL NAME, NULL VALUE FROM DUAL WHERE 1 = 0
UNION ALL
( SELECT NULL NAME, NULL VALUE FROM DUAL WHERE 1 = 0 )
UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INST_ID,
    OWNER
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      USER OWNER
    FROM
      DUAL
   ),
   ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SEGMENTS AS
( SELECT 
    SEGMENT_NAME,
    SEGMENT_TYPE,
    BYTES,
    EXTENTS,
    INITIAL_EXTENT,
    BUFFER_POOL
  FROM
    DBA_SEGMENTS
  WHERE
    DECODE(SUBSTR(UPPER('<Y for excluding segment information>'), 
      1, 1),'Y','Y','N') = 'N'
),
FIX_CONTROL_PARAMETERS AS
( SELECT /*+ MATERIALIZE */
    BUGNO PBUGNO,
    DECODE(UPPER(VALUE), 'ON', 1, 'OFF', 0, VALUE) PVALUE
  FROM
  ( SELECT
      SUBSTR(VALUE, 1, INSTR(VALUE, ':') - 1) BUGNO,
      SUBSTR(VALUE, INSTR(VALUE, ':') + 1) VALUE
    FROM
    ( SELECT
        REPLACE(VALUE, CHR(10), NULL) VALUE
      FROM
        BASIS_INFO BI,
        GV$PARAMETER2 P
      WHERE
        BI.INSTANCE_NUMBER = P.INST_ID AND
        UPPER(NAME) = '_FIX_CONTROL'
    )
  )
)
SELECT NULL NAME, NULL VALUE FROM BASIS_INFO WHERE 1 = 0
UNION ALL
( SELECT NULL, NULL FROM SEGMENTS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL FROM FIX_CONTROL_PARAMETERS WHERE 1 = 0 )
UNION ALL
( SELECT
    'GENERAL INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Evaluation time' NAME,
    TO_CHAR(SYSDATE, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Evaluation user' NAME,
    OWNER VALUE
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT
    DECODE(LINE, 1, 'Last startup times', ' ') NAME,
    VALUE
  FROM
  ( SELECT
      ROW_NUMBER () OVER (ORDER BY STARTUP_TIME DESC) LINE,
      TO_CHAR(STARTUP_TIME, 'dd.mm.yyyy hh24:mi:ss') VALUE
    FROM
      BASIS_INFO BI,
      DBA_HIST_DATABASE_INSTANCE HDI
    WHERE
      BI.DBID = HDI.DBID
    ORDER BY
      STARTUP_TIME DESC
  )
  WHERE
    ROWNUM <= 5
)
UNION ALL
( SELECT
    'Database creation time' NAME,
    TO_CHAR(CREATED, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Database ID' NAME,
    TO_CHAR(DBID) VALUE
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'Database name' NAME,
    NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Instance name' NAME,
    INSTANCE_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Instance number' NAME,
    TO_CHAR(INSTANCE_NUMBER) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Version' NAME,
    VERSION VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Host name' NAME,
    HOST_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Characterset' NAME,
    VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$NLS_PARAMETERS
  WHERE
    PARAMETER = 'NLS_CHARACTERSET'
)
UNION ALL
( SELECT
    'National characterset' NAME,
    VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$NLS_PARAMETERS
  WHERE
    PARAMETER = 'NLS_NCHAR_CHARACTERSET'
)
UNION ALL
( SELECT
    'Platform' NAME,
    PLATFORM_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'CPUs' NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'NUM_CPUS'
)
UNION ALL
( SELECT
    'CPU cores' NAME,
     TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'NUM_CPU_CORES'
)
UNION ALL
( SELECT
    'Physical memory (GB)' NAME,
    TO_CHAR(ROUND(VALUE / 1024 / 1024 / 1024, 2)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'PHYSICAL_MEMORY_BYTES'
)
UNION ALL
( SELECT
    'Real application clusters' NAME,
    DECODE(COUNT(*), 1, 'No', 'Yes (' || COUNT(*) || ' instances)') VALUE
  FROM
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Database vault' NAME,
    DECODE(VALUE, 'FALSE', 'No', 'Yes') VALUE
  FROM
    V$OPTION
  WHERE
    PARAMETER = 'Oracle Database Vault'
)
UNION ALL
( SELECT
    'Archiver state' NAME,
    ARCHIVER VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Archive log mode' NAME,
    LOG_MODE VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Force logging mode' NAME,
    DECODE(FORCE_LOGGING, 'YES', 'Yes', 'No') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Protection mode' NAME,
    PROTECTION_MODE VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'PSAPTEMP type' NAME,
    DECODE(EXTENT_MANAGEMENT, 'LOCAL', 'LMTS', 'DMTS') || '/' ||
      DECODE(CONTENTS, 'TEMPORARY', 'T', 'P') VALUE
  FROM
    DBA_TABLESPACES
  WHERE
    TABLESPACE_NAME = 'PSAPTEMP'
)
UNION ALL
( SELECT
    DECODE( NAME, 'log_archive_max_processes', 'ARCH processes', 
      'db_writer_processes', 'DBWR processes' ) NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$PARAMETER
  WHERE
    NAME IN ( 'log_archive_max_processes', 'db_writer_processes' )
)
UNION ALL
( SELECT
    'Resource manager active' NAME,
    DECODE(VALUE, NULL, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$PARAMETER2
  WHERE
    NAME = 'resource_manager_plan'
)
UNION ALL
( SELECT
    'Maintenance windows using resource manager' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SCHEDULER_WINDOWS
  WHERE
    RESOURCE_PLAN IS NOT NULL
)
UNION ALL
( SELECT
    'Profile limitations' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_USERS U,
    DBA_PROFILES P,
    DBA_PROFILES DP
  WHERE
    ( U.USERNAME LIKE BI.OWNER OR U.USERNAME LIKE 'SAP%' ) AND
    U.PROFILE = P.PROFILE AND
    DECODE(P.LIMIT, 'DEFAULT', DP.LIMIT, P.LIMIT) NOT IN ( 'NULL', 'UNLIMITED' ) AND
    DP.PROFILE = 'DEFAULT' AND
    DP.RESOURCE_NAME = P.RESOURCE_NAME AND
    P.RESOURCE_NAME NOT IN ( 'PASSWORD_LOCK_TIME', 'PASSWORD_GRACE_TIME' )
)
UNION ALL
( SELECT
    'Reported block corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$DATABASE_BLOCK_CORRUPTION
)
UNION ALL
( SELECT
    'Reported backup corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$BACKUP_CORRUPTION
)
UNION ALL
( SELECT
    'Reported copy corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$COPY_CORRUPTION
)
UNION ALL
( SELECT
    'Tables with activated corruption skipping' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    DBA_TABLES
  WHERE
    SKIP_CORRUPT = 'ENABLED'
)
UNION ALL
( SELECT
    'OFFLINE datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATAFILE
  WHERE
    STATUS = 'OFFLINE'
)
UNION ALL
( SELECT
    'RECOVER datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATAFILE
  WHERE
    STATUS = 'RECOVER'
)
UNION ALL
( SELECT
    'Backup mode datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$BACKUP
  WHERE
    STATUS = 'ACTIVE'
)
UNION ALL
( SELECT
    'Files with AUTOEXTEND increment > 100 M' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TABLESPACES TS,
    DBA_DATA_FILES DF
  WHERE
    DF.TABLESPACE_NAME = TS.TABLESPACE_NAME AND
    DF.INCREMENT_BY * TS.BLOCK_SIZE > 100 * 1024 * 1024
)
UNION ALL
( SELECT
    'Indexes with owner different from table' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_INDEXES
  WHERE
    OWNER != TABLE_OWNER 
)
UNION ALL
( SELECT
    'Indexes with name not starting with table name' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_INDEXES I
  WHERE
    I.OWNER LIKE BI.OWNER AND
    INDEX_TYPE NOT IN ( 'LOB', 'IOT - TOP' ) AND
    INDEX_NAME NOT LIKE TABLE_NAME || '%'
)
UNION ALL
( SELECT
    'Tables with preferred caching' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.CACHE = 'Y'
)
UNION ALL
( SELECT
    'Tables with disabled table lock' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.TABLE_LOCK = 'DISABLED'
)
UNION ALL
( SELECT
    'Tables with diff. indexes in different tablespaces' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      COUNT(DISTINCT(I.TABLESPACE_NAME)) NUM
    FROM
      BASIS_INFO BI,
      DBA_INDEXES I
    WHERE
      I.OWNER LIKE BI.OWNER AND
      I.INDEX_TYPE NOT IN ('IOT - TOP', 'LOB')
    GROUP BY
      I.TABLE_NAME
  )
  WHERE 
    NUM > 1
)
UNION ALL
( SELECT
    'Temporary tablespace smaller than largest index' NAME,
    DECODE(SIGN(GREATEST(TEMP_DMTS_BYTES, TEMP_LMTS_BYTES) - 
      INDEX_BYTES), -1, 'Yes', 'No') VALUE
  FROM
    ( SELECT 
        MAX(BYTES) INDEX_BYTES 
      FROM 
        SEGMENTS 
      WHERE 
        SEGMENT_TYPE LIKE 'INDEX%' ),
    ( SELECT 
        NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_DMTS_BYTES
      FROM
        BASIS_INFO BI,
        DBA_USERS U,
        DBA_DATA_FILES DF
      WHERE
        BI.OWNER = U.USERNAME AND
        U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
    ),
    ( SELECT 
        NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_LMTS_BYTES
      FROM
        BASIS_INFO BI,
        DBA_USERS U,
        DBA_TEMP_FILES DF
      WHERE
        BI.OWNER = U.USERNAME AND
        U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
    )
)
UNION ALL
( SELECT
    'UNUSABLE indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_INDEXES
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'UNUSABLE index partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_IND_PARTITIONS
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'UNUSABLE tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TABLES
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'Encrypted columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_ENCRYPTED_COLUMNS EC
  WHERE
    EC.OWNER LIKE BI.OWNER
)
UNION ALL
( SELECT
    'Hidden columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.HIDDEN_COLUMN = 'YES'
)
UNION ALL
( SELECT
    'Virtual columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.VIRTUAL_COLUMN = 'YES'
)
UNION ALL
( SELECT
    DECODE(EN.NAME, 'free buffer waits', 'Free buffer waits',
      'log file switch (checkpoint incomplete)', 'Checkpoint not complete',
      'log file switch (archiving needed)', 'Archiver stuck') NAME,
    DECODE(SE.TOTAL_WAITS, NULL, 'No', 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    GV$EVENT_NAME EN, 
    GV$SYSTEM_EVENT SE
  WHERE
    BI.INSTANCE_NUMBER = EN.INST_ID AND
    EN.INST_ID = SE.INST_ID (+) AND
    EN.NAME IN ('free buffer waits', 
                'log file switch (checkpoint incomplete)',
                'log file switch (archiving needed)') AND
    EN.NAME = SE.EVENT (+)
)
UNION ALL
( SELECT
    'PGA multipass executions' NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSSTAT
  WHERE
    NAME = 'workarea executions - multipass'
)
UNION ALL
( SELECT
    'Parallel operations downgraded' NAME,
    TO_CHAR(SUM(VALUE)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSSTAT
  WHERE
    NAME LIKE 'Parallel operations downgraded%'
)
UNION ALL
( SELECT
    'Tables with parallel degree > 1' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    (DEGREE != '         1' OR 
     INSTANCES NOT IN ( '         0', '         1'))
)
UNION ALL
( SELECT
    'Indexes with parallel degree > 1' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE != 'LOB' AND
    (DEGREE != '1' OR INSTANCES NOT IN ('0', '1'))
)
UNION ALL
( SELECT
    'Tables with > 100 partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_PART_TABLES PT
  WHERE
    PT.OWNER LIKE BI.OWNER AND
    PT.PARTITION_COUNT > 100
)
UNION ALL
( SELECT
    'Indexes with > 100 partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_PART_INDEXES PI
  WHERE
    PI.OWNER LIKE BI.OWNER AND
    PI.PARTITION_COUNT > 100
)
UNION ALL
( SELECT
    'Function based indexes' NAME,
    TO_CHAR(COUNT(DISTINCT(INDEX_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_IND_EXPRESSIONS IE
  WHERE
    IE.INDEX_OWNER LIKE BI.OWNER 
)
UNION ALL
( SELECT
    'Domain indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE = 'DOMAIN'
)
UNION ALL
( SELECT
    'Reverse key indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE = 'NORMAL/REV'
)
UNION ALL
( SELECT
    'Compressed indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'Compressed index partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_IND_PARTITIONS DI
  WHERE
    DI.INDEX_OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'Compressed tables' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), TO_CHAR(COUNT(*)) || ' (' || 
      NVL(TO_CHAR(SUM(DECODE(SUBSTR(TABLE_NAME, 1, 4), 
      'GVD_', 1, 'ORA_', 1, 0))), 0) || ' SAP default)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'Compressed table partitions' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), TO_CHAR(COUNT(*)) || ' (' || 
      NVL(TO_CHAR(SUM(DECODE(SUBSTR(TABLE_NAME, 1, 4), 
      'GVD_', 1, 'ORA_', 1, 0))), 0) || ' SAP default)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TAB_PARTITIONS DT
  WHERE
    DT.TABLE_OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'NOLOGGING indexes' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), 
      TO_CHAR(COUNT(*)) || ' (' || TO_CHAR(SUM(DECODE(SUBSTR(INDEX_NAME, 1, 3), 
      '/BI', 1, 0))) || ' BW indexes)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    LOGGING = 'NO'
)
UNION ALL
( SELECT
    'NOLOGGING tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    LOGGING = 'NO' AND
    TEMPORARY = 'N'
)
UNION ALL
( SELECT
    'Temporary tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT                                                  
  WHERE                  
    DT.OWNER LIKE BI.OWNER AND
    TEMPORARY = 'Y'
)
UNION ALL
( SELECT
    'Supplemental logging tables' NAME,
    TO_CHAR(COUNT(DISTINCT(DLG.OWNER || TABLE_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_LOG_GROUPS DLG
  WHERE
    DLG.OWNER LIKE BI.OWNER
)
UNION ALL
( SELECT
    'Tables with primary key constraint' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_CONSTRAINTS C
  WHERE
    C.OWNER LIKE BI.OWNER AND
    C.CONSTRAINT_TYPE = 'P'
)
UNION ALL
( SELECT
    'Index organized tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    IOT_TYPE = 'IOT'
)  
UNION ALL
( SELECT
    'SYS_JOURNAL tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.TABLE_NAME LIKE 'SYS_JOURNAL%'
)  
UNION ALL
( SELECT
    'SYS_IOT_TOP indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    DI.INDEX_NAME LIKE 'SYS_IOT_TOP%'
)  
UNION ALL
( SELECT
    'QCM tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'QCM%'
)  
UNION ALL
( SELECT
    'MLOG$ tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'MLOG$%'
)  
UNION ALL
( SELECT
    'RUPD$ tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'RUPD$%'
)  
UNION ALL
( SELECT
    'RECYCLEBIN segments' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_RECYCLEBIN
)
UNION ALL
( SELECT
    'Segments with INITIAL > 100 M' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    SEGMENTS
  WHERE
    INITIAL_EXTENT > 100 * 1024 * 1024
)
UNION ALL
( SELECT
    'Segments with PCTFREE > 10' NAME,
    TO_CHAR(SUM(NUM)) VALUE
  FROM
  ( SELECT
      COUNT(*) NUM
    FROM
      BASIS_INFO BI,
      DBA_TABLES DT
    WHERE
      DT.OWNER LIKE BI.OWNER AND
      DT.PCT_FREE > 10
    UNION ALL
    ( SELECT
        COUNT(*) NUM
      FROM
        BASIS_INFO BI,
        DBA_INDEXES DI
      WHERE
        DI.OWNER LIKE BI.OWNER AND
        DI.PCT_FREE > 10
    )
  )
)
UNION ALL
( SELECT
    'Tables with PCTFREE < 10' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.PCT_FREE < 10 AND 
    DT.COMPRESSION != 'ENABLED'
)
UNION ALL
( SELECT
    'Tables with PCTUSED < 40' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.PCT_USED < 40
)
UNION ALL
( SELECT
    'Segments with INITRANS > 2' NAME,
    TO_CHAR(SUM(NUM)) VALUE
  FROM
  ( SELECT
      COUNT(*) NUM
    FROM
      BASIS_INFO BI,
      DBA_TABLES DT
    WHERE
      DT.OWNER LIKE BI.OWNER AND
      DT.INI_TRANS > 2
    UNION ALL
    ( SELECT
        COUNT(*) NUM
      FROM
        BASIS_INFO BI,
        DBA_INDEXES DI
      WHERE
        DI.OWNER LIKE BI.OWNER AND
        DI.INI_TRANS > 2
    )
  )
)
UNION ALL
( SELECT
    'Materialized views' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_MVIEWS DM
  WHERE
    DM.OWNER LIKE BI.OWNER
)  
UNION ALL
( SELECT
    'Materialized view logs' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_MVIEW_LOGS DM
  WHERE
    DM.LOG_OWNER LIKE BI.OWNER
)  
UNION ALL
( SELECT
    'Segments not in DEFAULT buffer pool' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    SEGMENTS
  WHERE
    BUFFER_POOL != 'DEFAULT'
)
UNION ALL
( SELECT
    'Segments not pre-calculated for DBA_SEGMENTS' NAME,
    TO_CHAR(COUNT(*)) || ' (SYSTEM: ' || TO_CHAR(NVL(SUM(DECODE(
      TABLESPACE_NAME, 'SYSTEM', 1, 0)), 0)) || ')' VALUE
  FROM
    SYS.SYS_DBA_SEGS
  WHERE
    BITAND(SEGMENT_FLAGS, 131073) = 1 AND
    SEGMENT_TYPE NOT IN ('ROLLBACK', 'TYPE2 UNDO') 
)
UNION ALL
( SELECT
    'Outdated DBA_SEGMENTS definition used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_COL_COMMENTS
  WHERE
    OWNER = 'SYS' AND                                    
    TABLE_NAME = 'DBA_SEGMENTS' AND                      
    COLUMN_NAME = 'SEGMENT_TYPE' AND                     
    COMMENTS NOT LIKE '%TYPE2 UNDO%' 
)                    
UNION ALL
( SELECT
    'Outdated SYS_DBA_SEGS helper view used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_VIEWS                         
  WHERE 
    VIEW_NAME = 'SYS_DBA_SEGS_2' 
)
UNION ALL
( SELECT
    'Outdated DBA_EXTENTS helper view used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_VIEWS                         
  WHERE 
    VIEW_NAME = 'SAP_DBA_EXTENTS' AND 
    OWNER = 'SYS' 
)
UNION ALL
( SELECT
    'Outdated PLAN_TABLE used' NAME,
    DECODE(COUNT(DISTINCT(TC.OWNER)), NVL(SUM(DECODE(TC.COLUMN_NAME, 
      'FILTER_PREDICATES', 1, 0)), 0), 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLUMNS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.TABLE_NAME = 'PLAN_TABLE'
)
UNION ALL
( SELECT
    'Non-default triggers' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TRIGGERS
  WHERE
    TRIGGER_NAME NOT IN 
    ( 'DEF$_PROPAGATOR_TRIG', 
      'REPCATLOGTRIG', 
      'AW_DROP_TRG',
      'AW_TRUNC_TRG', 
      'AW_REN_TRG',
      'LOGMNRGGC_TRIGGER' )
)
UNION ALL
( SELECT
    'Non-default sequences' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_SEQUENCES S
  WHERE
    S.SEQUENCE_OWNER LIKE BI.OWNER AND
    SEQUENCE_NAME != 'DDLOG_SEQ'
)
UNION ALL
( SELECT
    'INVALID objects in DDIC' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_OBJECTS
  WHERE
    OWNER IN ('SYS', 'SYSTEM') AND
    STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID constraints' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_CONSTRAINTS DC
  WHERE
    DC.OWNER LIKE BI.OWNER AND
    DC.INVALID = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID views' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O
  WHERE
    O.OWNER LIKE BI.OWNER AND
    O.OBJECT_TYPE = 'VIEW' AND
    O.STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID procedures' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O
  WHERE
    O.OWNER LIKE BI.OWNER AND
    O.OBJECT_TYPE = 'PROCEDURE' AND
    O.STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'Non-default database users' NAME,
    COUNT(*) || DECODE(COUNT(*), 0, ' ', DECODE(COUNT(*), 1, 
      ' (', ' (e.g. ') || MIN(USERNAME) || ')') VALUE
  FROM
    DBA_USERS
  WHERE
    USERNAME NOT IN ('SYS', 'SYSTEM', 'DBSNMP', 'SYSMAN', 'TSMSYS', 
      'OUTLN', 'DIP', 'ORACLE_OCM', 'MGMT_VIEW', 'PERFSTAT',
      'APPQOSSYS') AND
    USERNAME NOT LIKE 'OPS$%' AND
    USERNAME NOT LIKE 'SAP%'
)
UNION ALL
( SELECT
    'EXECUTE on DBMS_LOB revoked' NAME,
    DECODE(COUNT(*), 0, 'Yes', 'No') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_PRIVS P
  WHERE
    P.GRANTEE IN (BI.OWNER, 'PUBLIC') AND
    P.TABLE_NAME = 'DBMS_LOB' AND
    P.PRIVILEGE = 'EXECUTE'
)
UNION ALL
( SELECT
    'Outlines' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_OUTLINES
)
UNION ALL
( SELECT
    'SQL profiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SQL_PROFILES
)
UNION ALL
( SELECT
    'LOBs with PCTVERSION > 10' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_LOBS DL
  WHERE
    DL.OWNER LIKE BI.OWNER AND
    PCTVERSION > 10    
)
UNION ALL
( SELECT
    'Database links' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_DB_LINKS
)
UNION ALL
( SELECT
    'Missing ST04 initialization' NAME,
    DECODE(COUNT(*), 0, 'Yes', 'No') VALUE
  FROM
    DBA_VIEWS
  WHERE
    VIEW_NAME = 'SAP_AUXSTATS'
)
UNION ALL
( SELECT
    'Inconsistency system fix control / parameters' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    FIX_CONTROL_PARAMETERS P,
    V$SYSTEM_FIX_CONTROL F   
  WHERE
    F.BUGNO = P.PBUGNO AND
    F.VALUE != P.PVALUE
)
UNION ALL
( SELECT
    'ORA-01555 errors' NAME,
    TO_CHAR(SUM(SSOLDERRCNT)) VALUE
  FROM
    DBA_HIST_UNDOSTAT
)
UNION ALL
( SELECT
    'Undo space errors' NAME,
    TO_CHAR(SUM(NOSPACEERRCNT)) VALUE
  FROM
    DBA_HIST_UNDOSTAT
)
UNION ALL
( SELECT
    'Multiple redo log sizes' NAME,
    DECODE(SIGN(MAX(BYTES) - MIN(BYTES)), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    GV$LOG L
  WHERE
    BI.INSTANCE_NUMBER = L.INST_ID
)
UNION ALL
( SELECT
    'Log switches within less than 1 minute (last 7 days)' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      ( LH2.FIRST_TIME - LH1.FIRST_TIME ) * 86400 SECONDS
    FROM
      BASIS_INFO BI,
      GV$LOGHIST LH1,
      GV$LOGHIST LH2
    WHERE
      BI.INSTANCE_NUMBER = LH1.INST_ID AND
      LH2.INST_ID = LH1.INST_ID AND
      LH1.FIRST_TIME > SYSDATE - 7 AND
      LH1.THREAD# = LH2.THREAD# AND
      LH1.SEQUENCE# = LH2.SEQUENCE# - 1
  )
  WHERE
    SECONDS BETWEEN 0 AND 60 
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'ORACLE DDIC COMPONENTS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    COMP_ID NAME,
    VERSION || ' (' || STATUS || ')' VALUE            
  FROM 
    DBA_REGISTRY     
) 
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'ORACLE JOBS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    JOB_NAME NAME,
    RPAD(STATE, 12) || DECODE(LAST_START_DATE, NULL, NULL,
      '(last run: ' || TO_CHAR(LAST_START_DATE, 'dd.mm.yyyy') || ')') VALUE
  FROM 
    DBA_SCHEDULER_JOBS
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'CHANGE HISTORY:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( SELECT
      TO_CHAR(ACTION_TIME, 'dd.mm.yyyy hh24:mi:ss') NAME,
      ACTION || DECODE(VERSION, NULL, '', ' ' || VERSION ) || 
        DECODE(COMMENTS, NULL, '', ' (' || COMMENTS || ')') VALUE
    FROM
      DBA_REGISTRY_HISTORY
    ORDER BY
      ACTION_TIME
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'USED FEATURES:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( SELECT 
      NAME,
      'used since ' || TO_CHAR(FIRST_USAGE_DATE, 
        'dd.mm.yyyy hh24:mi:ss') VALUE
    FROM                                                    
      DBA_FEATURE_USAGE_STATISTICS                          
    WHERE                                                   
      VERSION = 
      ( SELECT 
          VERSION 
        FROM 
          BASIS_INFO NATURAL JOIN
          GV$INSTANCE ) AND        
      (DETECTED_USAGES > 0 OR CURRENTLY_USED != 'FALSE')  
    ORDER BY
      NAME
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'RESOURCE INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    DECODE(RESOURCE_NAME, 'processes', 'Processes', 'sessions', 'Sessions',
      'parallel_max_servers', 'PX slaves') NAME,
    'current: ' || TO_CHAR(CURRENT_UTILIZATION, 9990) || ', max.: ' || 
      TO_CHAR(MAX_UTILIZATION, 9990) || ', limit: ' || TO_CHAR(INITIAL_ALLOCATION, 99990) VALUE
  FROM 
    BASIS_INFO NATURAL JOIN
    GV$RESOURCE_LIMIT
  WHERE
    RESOURCE_NAME IN ( 'processes',
                       'sessions',
                       'parallel_max_servers')
)  
UNION ALL
( SELECT
    'Datafiles' NAME,
    'current: ' || TO_CHAR(DF_CURRENT.NUM_DATAFILES, 9990) || 
      ',              ' ||
      'limit: ' || TO_CHAR(DF_LIMIT.MAX_DATAFILES, 99990) VALUE
  FROM
  ( SELECT COUNT(*) NUM_DATAFILES FROM DBA_DATA_FILES ) DF_CURRENT,
  ( SELECT VALUE MAX_DATAFILES FROM V$PARAMETER WHERE NAME = 'db_files') DF_LIMIT
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'SPACE INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Tablespaces' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) VALUE
  FROM
    DBA_TABLESPACES
)
UNION ALL
( SELECT
    'Datafiles' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(SUM(BYTES) / 
      1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_DATA_FILES
)
UNION ALL
( SELECT
    'Tempfiles' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(NVL(SUM(BYTES), 0) / 
      1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_TEMP_FILES
)
UNION ALL
( SELECT 
    NAME, 
    VALUE
  FROM
  ( 
    SELECT
      'Segments' NAME,
      TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
        TO_CHAR(ROUND(SUM(BYTES) / 
        1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
    FROM
      SEGMENTS
    UNION ALL
    ( SELECT
        'Extents' NAME,
        TO_CHAR(SUM(EXTENTS), 99999999999999999999999999990) VALUE
      FROM
        SEGMENTS
    )
    UNION ALL
    ( SELECT
        *
      FROM
      ( SELECT
          SUBSTR(SEGMENT_TYPE, 1, 1) || LOWER(SUBSTR(SEGMENT_TYPE, 2)) || 
            DECODE(SEGMENT_TYPE, 'INDEX', 'es', 'LOBINDEX', 'es', 's') NAME,
          TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
            TO_CHAR(ROUND(SUM(BYTES) / 
            1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
        FROM
          SEGMENTS
        WHERE 
          SEGMENT_TYPE IN ( 'TABLE',
                            'TABLE PARTITION',
                            'TABLE SUBPARTITION',
                            'INDEX',
                            'INDEX PARTITION',
                            'INDEX SUBPARTITION',
                            'LOBSEGMENT',
                            'LOBINDEX' )
        GROUP BY
          SUBSTR(SEGMENT_TYPE, 1, 1) || LOWER(SUBSTR(SEGMENT_TYPE, 2)) || 
            DECODE(SEGMENT_TYPE, 'INDEX', 'es', 'LOBINDEX', 'es', 's')
        ORDER BY
          1
      )
    )
  )
)
UNION ALL
( SELECT
    'Freespace fragments' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(SUM(BYTES) / 1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_FREE_SPACE
)
UNION ALL
( SELECT
    'Redo log groups' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
)
UNION ALL
( SELECT
    'Redo log members' NAME,
    TO_CHAR(MEMBERS, 99999999999999999999999999990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
  WHERE
    ROWNUM = 1
)
UNION ALL
( SELECT
    'Redo log size (min.)' NAME,
    TO_CHAR(MIN(BYTES) / 1024 / 1024, 99999999999999999999999999990.99) || ' MB' VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'CBO STATISTICS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)   
UNION ALL
( SELECT
    'Last CBO statistics creation' NAME,
    TO_CHAR(MAX(LAST_ANALYZED), 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_STATISTICS TS
  WHERE
    TS.OWNER LIKE BI.OWNER 
)
UNION ALL
( SELECT
    'DDIC statistics creation' NAME,
    DECODE(LAST_ANALYZED, NULL, 'No', TO_CHAR(LAST_ANALYZED, 
      'dd.mm.yyyy hh24:mi:ss')) VALUE
  FROM
    DBA_TAB_STATISTICS
  WHERE
    OWNER = 'SYS' AND
    TABLE_NAME = 'TAB$'   
)
UNION ALL
( SELECT
    'Fixed objects statistics creation' NAME,
    DECODE(LAST_ANALYZED, NULL, 'No', TO_CHAR(LAST_ANALYZED, 
      'dd.mm.yyyy hh24:mi:ss')) VALUE
  FROM
    DBA_TAB_STATISTICS
  WHERE
    OWNER = 'SYS' AND
    TABLE_NAME = 'X$BH'   
)
UNION ALL
( SELECT
    'Tables with small statistics sample size' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    USER_STATS = 'NO' AND                                           
    NUM_ROWS > 50000 AND                                            
    SAMPLE_SIZE > 100 AND                                           
    SAMPLE_SIZE < 0.2 * NUM_ROWS *                                  
      DECODE(NUM_ROWS, 0, 0, DECODE(TRUNC(LOG(10, GREATEST(NUM_ROWS, BLOCKS))),       
      0, 1, 1, 1, 2, 1, 3, 1, 4, 0.3, 5, 0.1, 6, 0.03, 7, 0.01,     
      8, 0.003, 9, 0.001, 10, 0.0003, 11, 0.0001, 12, 0.00003,      
      0.00001))    
)
UNION ALL
( SELECT
    'Tables without statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    LAST_ANALYZED IS NULL AND
    TEMPORARY = 'N'
)
UNION ALL
( SELECT
    'Tables with locked statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_STATISTICS T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    T.STATTYPE_LOCKED IS NOT NULL
)
UNION ALL
( SELECT
    'Tables with statistics older than segment' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    ( SELECT
        OWNER,
        TABLE_NAME,
        MIN(LAST_ANALYZED) LAST_ANALYZED
      FROM
        DBA_TAB_STATISTICS
      GROUP BY
        OWNER,
        TABLE_NAME
    ) T,
    DBA_OBJECTS O
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.OWNER = O.OWNER AND
    T.TABLE_NAME = O.OBJECT_NAME AND
    O.OBJECT_TYPE = 'TABLE' AND
    O.SUBOBJECT_NAME IS NULL AND
    T.LAST_ANALYZED < O.CREATED
)
UNION ALL
( SELECT
    'Tables with ANALYZE statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.LAST_ANALYZED IS NOT NULL AND
    T.GLOBAL_STATS = 'NO'
)
UNION ALL
( SELECT
    'Indexes without statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_INDEXES I
  WHERE
    I.OWNER LIKE BI.OWNER AND
    I.LAST_ANALYZED IS NULL AND 
    I.INDEX_TYPE != 'LOB'
)
UNION ALL
( SELECT 
    'Columns without statistics' NAME,
    TO_CHAR(COUNT(*)) || ' (' ||
      'LONG: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'LONG', 1, 0)), 0) || ', ' ||
      'LONG RAW: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'LONG RAW', 1, 0)), 0) || ', ' ||
      'LOB: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'BLOB', 1, 'CLOB', 1, 
        'BFILE', 1, 'NCLOB', 1, 0)), 0) || ')' VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES T,
    DBA_TAB_COLUMNS TCS
  WHERE
    TCS.OWNER LIKE BI.OWNER AND
    TCS.OWNER = T.OWNER AND
    TCS.TABLE_NAME = T.TABLE_NAME AND
    TCS.LAST_ANALYZED IS NULL AND
    T.TEMPORARY = 'N'
)
UNION ALL
( SELECT
    'Tables with non-default histograms' NAME,
    TO_CHAR(COUNT(DISTINCT(TABLE_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TAB_COL_STATISTICS TCS
  WHERE
    TCS.OWNER LIKE BI.OWNER AND
    HISTOGRAM != 'NONE' AND
    TABLE_NAME NOT LIKE '/BI%' AND 
    TABLE_NAME NOT LIKE '/B20%' AND
    TABLE_NAME NOT IN ('MSEG', 'MKPF', 'RSDD_TMPNM_ADM',
      'LTAP', 'LTBP', 'MKPF', 'BDCP', 'BDCPS', 'PPC_HEAD',
      'RSREQDONE', 'RSSELDONE', 'RSSTATMANREQMAP',
      'RSSTATMANSTATUS', 'RSTSODSREQUEST' )
)
UNION ALL
( SELECT
    'Indexed columns of infocubes without histograms' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_IND_COLUMNS IC,
    DBA_TAB_COL_STATISTICS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    IC.TABLE_OWNER = TC.OWNER AND
    IC.TABLE_NAME = TC.TABLE_NAME AND
    IC.COLUMN_NAME = TC.COLUMN_NAME AND
    ( TC.TABLE_NAME LIKE '/BIC/F%' OR
      TC.TABLE_NAME LIKE '/BIC/9AF%' OR
      TC.TABLE_NAME LIKE '/BI0/F%' OR
      TC.TABLE_NAME LIKE '/BI0/9AF%' OR
      TC.TABLE_NAME LIKE '/BIC/E%' OR
      TC.TABLE_NAME LIKE '/BIC/9AE%' OR
      TC.TABLE_NAME LIKE '/BI0/E%' OR
      TC.TABLE_NAME LIKE '/BI0/9AE%' OR
      TC.TABLE_NAME LIKE '/BIC/D%' OR
      TC.TABLE_NAME LIKE '/BIC/9AD%' OR
      TC.TABLE_NAME LIKE '/BI0/D%' OR
      TC.TABLE_NAME LIKE '/BI0/9AD%' OR
      TC.TABLE_NAME LIKE '/BIC/S%' OR
      TC.TABLE_NAME LIKE '/BIC/9AS%' OR
      TC.TABLE_NAME LIKE '/BI0/S%' OR
      TC.TABLE_NAME LIKE '/BI0/9AS%' OR
      TC.TABLE_NAME LIKE '/BIC/X%' OR
      TC.TABLE_NAME LIKE '/BIC/9AX%' OR
      TC.TABLE_NAME LIKE '/BI0/X%' OR
      TC.TABLE_NAME LIKE '/BI0/9AX%' OR
      TC.TABLE_NAME LIKE '/BIC/Y%' OR
      TC.TABLE_NAME LIKE '/BIC/9AY%' OR
      TC.TABLE_NAME LIKE '/BI0/Y%' OR
      TC.TABLE_NAME LIKE '/BI0/9AY%' OR
      TC.TABLE_NAME LIKE '/BIC/I%' OR
      TC.TABLE_NAME LIKE '/BIC/9AI%' OR
      TC.TABLE_NAME LIKE '/BI0/I%' OR
      TC.TABLE_NAME LIKE '/BI0/9AI%' OR
      TC.TABLE_NAME LIKE '/BIC/P%' OR
      TC.TABLE_NAME LIKE '/BIC/9AP%' OR
      TC.TABLE_NAME LIKE '/BI0/P%' OR 
      TC.TABLE_NAME LIKE '/BI0/9AP%' OR
      TC.TABLE_NAME LIKE '/BIC/Q%' OR
      TC.TABLE_NAME LIKE '/BIC/9AQ%' OR
      TC.TABLE_NAME LIKE '/BI0/Q%' OR
      TC.TABLE_NAME LIKE '/BI0/9AQ%' OR
      TC.TABLE_NAME LIKE '/BI0/02%' OR
      TC.TABLE_NAME LIKE '/BI0/06%'
    ) AND
    TC.NUM_DISTINCT > 0 AND
    TC.HISTOGRAM = 'NONE'
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)   
UNION ALL
( SELECT
    'KEY FIGURES (SINCE DATABASE START):' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    'Buffer quality' NAME, 
    TO_CHAR(ROUND((1 - S2.VALUE / S1.VALUE) * 100, 2), 99999999999999999999999999990.99) || ' %' VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'session logical reads' AND
    S2.NAME = 'physical reads cache'
)
UNION ALL
( SELECT
    'Reads / user call' NAME, 
    TO_CHAR(DECODE(S2.VALUE, 0, 0, ROUND(S1.VALUE / S2.VALUE, 2)), 
      99999999999999999999999999990.99) VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'session logical reads' AND  
    S2.NAME = 'user calls'
)
UNION ALL
( SELECT
    'User / recursive calls' NAME, 
    TO_CHAR(DECODE(S2.VALUE, 0, 0, ROUND(S1.VALUE / S2.VALUE, 2)), 
      99999999999999999999999999990.99) VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'user calls' AND  
    S2.NAME = 'recursive calls'
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( WITH SECONDS AS
    ( SELECT 
        TO_CHAR(SYSDATE, 'SSSSS') - TO_CHAR(STARTUP_TIME, 'SSSSS') +
          86400 * (TO_CHAR(SYSDATE, 'J') - TO_CHAR(STARTUP_TIME, 'J')) 
          SECONDS
       FROM
         V$INSTANCE
    ), 
    TIMED_EVENTS AS
    ( SELECT 
        'CPU' NAME,
        VALUE / 10000 TIME_WAITED
      FROM
        BASIS_INFO BI NATURAL JOIN
        GV$SYS_TIME_MODEL
      WHERE
        STAT_NAME = 'DB CPU' 
      UNION ALL
      ( SELECT 
          WAIT_CLASS NAME,
          TIME_WAITED
        FROM
          BASIS_INFO BI NATURAL JOIN
          GV$SYSTEM_WAIT_CLASS
      )
    ) 
    ( SELECT
        'Time / user call' NAME,
        TO_CHAR(STM.VALUE / 1000 / SS.VALUE, 
          99999999999999999999999999990.99) || ' ms' VALUE
      FROM
        BASIS_INFO BI,
        GV$SYS_TIME_MODEL STM, 
        GV$SYSSTAT SS
      WHERE
        BI.INSTANCE_NUMBER = STM.INST_ID AND
        BI.INSTANCE_NUMBER = SS.INST_ID AND
        STM.STAT_NAME = 'DB time' AND
        SS.NAME = 'user calls'
    )
    UNION ALL
    ( SELECT
        SS.NAME || ' / s' NAME,
        TO_CHAR(ROUND(VALUE / S.SECONDS, 2), 99999999999999999999999999990.99) VALUE
      FROM
        BASIS_INFO BI,
        GV$SYSSTAT SS, 
        SECONDS S
      WHERE
        BI.INSTANCE_NUMBER = SS.INST_ID AND
        SS.NAME IN ('user calls', 
                    'user commits', 
                    'recursive calls',
                    'session logical reads',
                    'consistent changes',
                    'physical reads',
                    'physical reads cache prefetch',
                    'db block changes',
                    'physical writes',
                    'redo blocks written',
                    'bytes sent via SQL*Net to client',
                    'bytes received via SQL*Net from client',
                    'SQL*Net roundtrips to/from client',
                    'parse count (total)',
                    'parse count (hard)',
                    'table fetch by rowid',
                    'table fetch continued row')
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        'TIMED EVENTS (SINCE DATABASE START):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          TE.NAME || ' sessions active' NAME,
          TO_CHAR(ROUND(TE.TIME_WAITED / 100 / S.SECONDS, 2), 
            99999999999999999999999999990.99) || ' (' || TO_CHAR(ROUND(RATIO_TO_REPORT 
            (TE.TIME_WAITED) OVER () * 100, 2), 90.99) || ' %)' VALUE,
          RATIO_TO_REPORT (TE.TIME_WAITED) OVER () * 100 PCT
        FROM
          TIMED_EVENTS TE, SECONDS S
        WHERE
          TE.NAME != 'Idle'
        ORDER BY
          TE.TIME_WAITED DESC
      )
      WHERE 
        PCT >= 1
    )
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'TOP I/O READ TABLESPACES (SINCE DATABASE START):' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    TABLESPACE_NAME NAME,
    TO_CHAR(PERCENT, 
        99999999999999999999999999990.99) || ' %' VALUE
  FROM
  ( SELECT
      TABLESPACE_NAME,
      TO_CHAR(SUM(IO_READ_TIME_S), 9999999999990) IO_READ_TIME_S,
      TO_CHAR(RATIO_TO_REPORT(SUM(IO_READ_TIME_S)) OVER () * 100, 990.99) PERCENT
    FROM
    ( SELECT
        TS.NAME TABLESPACE_NAME,
        FS.READTIM / 100 IO_READ_TIME_S
      FROM
        BASIS_INFO BI,
        GV$FILESTAT FS,
        GV$DATAFILE DF,
        GV$TABLESPACE TS
      WHERE
        BI.INSTANCE_NUMBER = FS.INST_ID AND
        FS.INST_ID = DF.INST_ID AND
        FS.INST_ID = TS.INST_ID AND
        FS.FILE# = DF.FILE# AND
        DF.TS# = TS.TS# 
      UNION ALL
      ( SELECT
          TS.NAME TABLESPACE_NAME,
          FS.READTIM / 100 IO_READ_TIME_S
        FROM
          BASIS_INFO BI,
          GV$TEMPSTAT FS,
          GV$TEMPFILE DF,
          GV$TABLESPACE TS
        WHERE
          BI.INSTANCE_NUMBER = FS.INST_ID AND
          FS.INST_ID = DF.INST_ID AND
          FS.INST_ID = TS.INST_ID AND
          FS.FILE# = DF.FILE# AND
          DF.TS# = TS.TS#
      )  
    )
    GROUP BY
      TABLESPACE_NAME
    ORDER BY
      IO_READ_TIME_S DESC
  )
  WHERE
    ROWNUM <= 10
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    *
  FROM
  ( WITH ASH AS
    ( SELECT
        A.NAME SQL_TYPE,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.MODULE,
        U.USERNAME USER_NAME,
        ASH.SESSION_TYPE,
        COUNT(*) OCCURRENCES
      FROM
        BASIS_INFO BI,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        AUDIT_ACTIONS A,
        DBA_USERS U
      WHERE
        BI.DBID = ASH.DBID AND
        ASH.SQL_OPCODE = A.ACTION (+) AND
        DECODE(SUBSTR(UPPER('<Y for excluding ASH information>'), 
          1, 1),'Y','Y','N') = 'N' AND
        ASH.USER_ID = U.USER_ID (+)
      GROUP BY
        A.NAME,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.MODULE,
        U.USERNAME,
        ASH.SESSION_TYPE
    )
    ( SELECT
        'TOP ACTIONS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          SQL_TYPE || DECODE(SQL_TYPE, 'UNKNOWN', ' (' || PROGRAM || ')', '') NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          SQL_TYPE || DECODE(SQL_TYPE, 'UNKNOWN', ' (' || PROGRAM || ')', '')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  UNION ALL
    ( SELECT
        'TOP MODULES (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          NVL(MODULE, 'UNKNOWN (' || PROGRAM || ')')  NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          NVL(MODULE, 'UNKNOWN (' || PROGRAM || ')')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  UNION ALL
    ( SELECT
        'TOP PROGRAMS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          PROGRAM NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          PROGRAM
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  
    UNION ALL
    ( SELECT
        'TOP USERS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          NVL(USER_NAME, 'UNKNOWN') || DECODE(SESSION_TYPE, 'BACKGROUND', ' (BACKGROUND)') NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          NVL(USER_NAME, 'UNKNOWN') || DECODE(SESSION_TYPE, 'BACKGROUND', ' (BACKGROUND)')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  
    UNION ALL
    ( SELECT
        'TOP CLIENT IDS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          CLIENT_ID NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          CLIENT_ID
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    'AWR / ASH INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Multiple database IDs' NAME,
    DECODE(COUNT(DISTINCT(HSS.DBID)), 0, 'No', 1, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER
)
UNION ALL
( SELECT
    'Captured SQL statements' NAME,
    TOPNSQL VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'Snapshot interval (minutes)' NAME,
    TO_CHAR(EXTRACT(DAY FROM SNAP_INTERVAL) * 1440 +
      EXTRACT(HOUR FROM SNAP_INTERVAL) * 60 + 
      EXTRACT(MINUTE FROM SNAP_INTERVAL), 99990) VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'Snapshot retention (days)' NAME,
    TO_CHAR(ROUND(EXTRACT(DAY FROM RETENTION) +
      EXTRACT(HOUR FROM RETENTION) / 24 + 
      EXTRACT(MINUTE FROM RETENTION) / 1440, 2), 99990) VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'V$ACTIVE_SESSION_HISTORY time (hours)' NAME,
    TO_CHAR(ROUND((TO_CHAR(MAX(SAMPLE_TIME), 'SSSSS') - 
      TO_CHAR(MIN(SAMPLE_TIME), 'SSSSS') +
      86400 * (TO_CHAR(MAX(SAMPLE_TIME), 'J') - 
      TO_CHAR(MIN(SAMPLE_TIME), 'J'))) / 3600, 2), 99990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$ACTIVE_SESSION_HISTORY
)
UNION ALL
( SELECT
    'AWR size in SYSAUX (MB)' NAME,
    TO_CHAR(SPACE_USAGE_KBYTES / 1024, 99990.99) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSAUX_OCCUPANTS
  WHERE
    OCCUPANT_DESC = 
      'Server Manageability - Automatic Workload Repository'
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c7e86c7-014d-1000-800a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Overview_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  /* 11g: - Auto Tasks, GV$SESSION_CONNECT_INFO, COMPRESS_FOR, Resource Manager, GV$ASH_INFO, SecureFiles,
            Diagnostic and Tuning Pack license */
  /*+ OPT_PARAM('_OPTIMIZER_DISTINCT_AGG_TRANSFORM', 'FALSE') */ 
  NULL NAME, NULL VALUE FROM DUAL WHERE 1 = 0
UNION ALL
( SELECT NULL NAME, NULL VALUE FROM DUAL WHERE 1 = 0 )
UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INST_ID,
    OWNER
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      USER OWNER
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SEGMENTS AS
( SELECT 
    SEGMENT_NAME,
    SEGMENT_TYPE,
    BYTES,
    EXTENTS,
    INITIAL_EXTENT,
    BUFFER_POOL
  FROM
    DBA_SEGMENTS
  WHERE
    DECODE(SUBSTR(UPPER('<Y for excluding segment information>'), 
      1, 1),'Y','Y','N') = 'N'
),
FIX_CONTROL_PARAMETERS AS
( SELECT /*+ MATERIALIZE */
    BUGNO PBUGNO,
    DECODE(UPPER(VALUE), 'ON', 1, 'OFF', 0, VALUE) PVALUE
  FROM
  ( SELECT
      SUBSTR(VALUE, 1, INSTR(VALUE, ':') - 1) BUGNO,
      SUBSTR(VALUE, INSTR(VALUE, ':') + 1) VALUE
    FROM
    ( SELECT
        REPLACE(VALUE, CHR(10), NULL) VALUE
      FROM
        BASIS_INFO BI,
        GV$PARAMETER2 P
      WHERE
        BI.INSTANCE_NUMBER = P.INST_ID AND
        UPPER(NAME) = '_FIX_CONTROL'
    )
  )
)
SELECT NULL NAME, NULL VALUE FROM BASIS_INFO WHERE 1 = 0
UNION ALL
( SELECT NULL, NULL FROM SEGMENTS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL FROM FIX_CONTROL_PARAMETERS WHERE 1 = 0 )
UNION ALL
( SELECT
    'GENERAL INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Evaluation time' NAME,
    TO_CHAR(SYSDATE, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM DUAL
)
UNION ALL
( SELECT
    'Evaluation user' NAME,
    OWNER VALUE
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT
    DECODE(LINE, 1, 'Last startup times', ' ') NAME,
    VALUE
  FROM
  ( SELECT
      ROW_NUMBER () OVER (ORDER BY STARTUP_TIME DESC) LINE,
      TO_CHAR(STARTUP_TIME, 'dd.mm.yyyy hh24:mi:ss') VALUE
    FROM
      BASIS_INFO BI,
      DBA_HIST_DATABASE_INSTANCE HDI
    WHERE
      BI.DBID = HDI.DBID
    ORDER BY
      STARTUP_TIME DESC
  )
  WHERE
    ROWNUM <= 5
)
UNION ALL
( SELECT
    'Database creation time' NAME,
    TO_CHAR(CREATED, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Database RESETLOGS time' NAME,
    TO_CHAR(RESETLOGS_TIME, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Prior database RESETLOGS time' NAME,
    TO_CHAR(PRIOR_RESETLOGS_TIME, 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Database ID' NAME,
    TO_CHAR(DBID) VALUE
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'Database name' NAME,
    NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Instance name' NAME,
    INSTANCE_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Instance number' NAME,
    TO_CHAR(INSTANCE_NUMBER) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Version' NAME,
    VERSION VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Host name' NAME,
    HOST_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Characterset' NAME,
    VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$NLS_PARAMETERS
  WHERE
    PARAMETER = 'NLS_CHARACTERSET'
)
UNION ALL
( SELECT
    'National characterset' NAME,
    VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$NLS_PARAMETERS
  WHERE
    PARAMETER = 'NLS_NCHAR_CHARACTERSET'
)
UNION ALL
( SELECT
    'Platform' NAME,
    PLATFORM_NAME VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'CPUs' NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'NUM_CPUS'
)
UNION ALL
( SELECT
    'CPU cores' NAME,
     TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'NUM_CPU_CORES'
)
UNION ALL
( SELECT
    'Physical memory (GB)' NAME,
    TO_CHAR(ROUND(VALUE / 1024 / 1024 / 1024, 2)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$OSSTAT
  WHERE
    STAT_NAME = 'PHYSICAL_MEMORY_BYTES'
)
UNION ALL
( SELECT
    'Real application clusters' NAME,
    DECODE(COUNT(*), 1, 'No', 'Yes (' || COUNT(*) || ' instances)') VALUE
  FROM
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Database vault' NAME,
    DECODE(VALUE, 'FALSE', 'No', 'Yes') VALUE
  FROM
    V$OPTION
  WHERE
    PARAMETER = 'Oracle Database Vault'
)
UNION ALL
( SELECT
    'Archiver state' NAME,
    ARCHIVER VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$INSTANCE
)
UNION ALL
( SELECT
    'Archive log mode' NAME,
    LOG_MODE VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Archive log compression' NAME,
    DECODE(ARCHIVELOG_COMPRESSION, 'ENABLED', 'Yes', 'No') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Force logging mode' NAME,
    DECODE(FORCE_LOGGING, 'YES', 'Yes', 'No') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Supplemental logging mode' NAME,
    DECODE(DECODE(SUPPLEMENTAL_LOG_DATA_MIN, 'NO', 0, 1) +
      DECODE(SUPPLEMENTAL_LOG_DATA_PK, 'NO', 0, 1) +
      DECODE(SUPPLEMENTAL_LOG_DATA_UI, 'NO', 0, 1) +
      DECODE(SUPPLEMENTAL_LOG_DATA_FK, 'NO', 0, 1) +
      DECODE(SUPPLEMENTAL_LOG_DATA_ALL, 'NO', 0, 1) +
      DECODE(SUPPLEMENTAL_LOG_DATA_PL, 'NO', 0, 1), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Protection mode' NAME,
    PROTECTION_MODE VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATABASE
)
UNION ALL
( SELECT
    'Diagnostic / tuning pack license' NAME,
    P.VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$PARAMETER2 P
  WHERE 
    P.NAME = 'control_management_pack_access'
)
UNION ALL
( SELECT
    'PSAPTEMP type' NAME,
    DECODE(EXTENT_MANAGEMENT, 'LOCAL', 'LMTS', 'DMTS') || '/' ||
      DECODE(CONTENTS, 'TEMPORARY', 'T', 'P') VALUE
  FROM
    DBA_TABLESPACES
  WHERE
    TABLESPACE_NAME = 'PSAPTEMP'
)
UNION ALL
( SELECT
    DECODE( NAME, 'log_archive_max_processes', 'ARCH processes', 
      'db_writer_processes', 'DBWR processes' ) NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$PARAMETER
  WHERE
    NAME IN ( 'log_archive_max_processes', 'db_writer_processes' )
)
UNION ALL
( SELECT
    'Resource manager active' NAME,
    DECODE(VALUE, NULL, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$PARAMETER2
  WHERE
    NAME = 'resource_manager_plan'
)
UNION ALL
( SELECT
    'Maintenance windows using resource manager' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SCHEDULER_WINDOWS
  WHERE
    RESOURCE_PLAN IS NOT NULL
)
UNION ALL
( SELECT
    'Profile limitations' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_USERS U,
    DBA_PROFILES P,
    DBA_PROFILES DP
  WHERE
    ( U.USERNAME LIKE BI.OWNER OR U.USERNAME LIKE 'SAP%' ) AND
    U.PROFILE = P.PROFILE AND
    DECODE(P.LIMIT, 'DEFAULT', DP.LIMIT, P.LIMIT) NOT IN ( 'NULL', 'UNLIMITED' ) AND
    DP.PROFILE = 'DEFAULT' AND
    DP.RESOURCE_NAME = P.RESOURCE_NAME AND
    P.RESOURCE_NAME NOT IN ( 'PASSWORD_LOCK_TIME', 'PASSWORD_GRACE_TIME' )
)
UNION ALL
( SELECT
    'Reported block corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$DATABASE_BLOCK_CORRUPTION
)
UNION ALL
( SELECT
    'Reported backup corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$BACKUP_CORRUPTION
)
UNION ALL
( SELECT
    'Reported copy corruptions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    GV$COPY_CORRUPTION
)
UNION ALL
( SELECT
    'Tables with activated corruption skipping' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI NATURAL JOIN
    DBA_TABLES
  WHERE
    SKIP_CORRUPT = 'ENABLED'
)
UNION ALL
( SELECT
    'OFFLINE datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATAFILE
  WHERE
    STATUS = 'OFFLINE'
)
UNION ALL
( SELECT
    'RECOVER datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$DATAFILE
  WHERE
    STATUS = 'RECOVER'
)
UNION ALL
( SELECT
    'Backup mode datafiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$BACKUP
  WHERE
    STATUS = 'ACTIVE'
)
UNION ALL
( SELECT
    'Files with AUTOEXTEND increment > 100 M' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TABLESPACES TS,
    DBA_DATA_FILES DF
  WHERE
    DF.TABLESPACE_NAME = TS.TABLESPACE_NAME AND
    DF.INCREMENT_BY * TS.BLOCK_SIZE > 100 * 1024 * 1024
)
UNION ALL
( SELECT
    'Indexes with owner different from table' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_INDEXES
  WHERE
    OWNER != TABLE_OWNER 
)
UNION ALL
( SELECT
    'Indexes with name not starting with table name' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_INDEXES I
  WHERE
    I.OWNER LIKE BI.OWNER AND
    INDEX_TYPE NOT IN ( 'LOB', 'IOT - TOP' ) AND
    INDEX_NAME NOT LIKE TABLE_NAME || '%'
)
UNION ALL
( SELECT
    'Tables with preferred caching' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.CACHE = 'Y'
)
UNION ALL
( SELECT
    'Tables with disabled table lock' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.TABLE_LOCK = 'DISABLED'
)
UNION ALL
( SELECT
    'Tables with diff. indexes in different tablespaces' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      COUNT(DISTINCT(I.TABLESPACE_NAME)) NUM
    FROM
      BASIS_INFO BI,
      DBA_INDEXES I
    WHERE
      I.OWNER LIKE BI.OWNER AND
      I.INDEX_TYPE NOT IN ('IOT - TOP', 'LOB')
    GROUP BY
      I.TABLE_NAME
  )
  WHERE 
    NUM > 1
)
UNION ALL
( SELECT
    'Tables with diff. partitions in different tablespaces' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      COUNT(DISTINCT(TP.TABLESPACE_NAME)) NUM
    FROM
      BASIS_INFO BI,
      DBA_TAB_PARTITIONS TP
    WHERE
      TP.TABLE_OWNER LIKE BI.OWNER
    GROUP BY
      TP.TABLE_NAME  
  )
  WHERE 
    NUM > 1
)
UNION ALL
( SELECT
    'Indexes with diff. partitions in different tablespaces' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      COUNT(DISTINCT(IP.TABLESPACE_NAME)) NUM
    FROM
      BASIS_INFO BI,
      DBA_IND_PARTITIONS IP
    WHERE
      IP.INDEX_OWNER LIKE BI.OWNER
    GROUP BY
      IP.INDEX_NAME  
  )
  WHERE 
    NUM > 1
)
UNION ALL
( SELECT
    'Temporary tablespace smaller than largest index' NAME,
    DECODE(SIGN(GREATEST(TEMP_DMTS_BYTES, TEMP_LMTS_BYTES) - 
      INDEX_BYTES), -1, 'Yes', 'No') VALUE
  FROM
    ( SELECT 
        MAX(BYTES) INDEX_BYTES 
      FROM 
        SEGMENTS 
      WHERE 
        SEGMENT_TYPE LIKE 'INDEX%' ),
    ( SELECT 
        NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_DMTS_BYTES
      FROM
        BASIS_INFO BI,
        DBA_USERS U,
        DBA_DATA_FILES DF
      WHERE
        BI.OWNER = U.USERNAME AND
        U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
    ),
    ( SELECT 
        NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_LMTS_BYTES
      FROM
        BASIS_INFO BI,
        DBA_USERS U,
        DBA_TEMP_FILES DF
      WHERE
        BI.OWNER = U.USERNAME AND
        U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
    )
)
UNION ALL
( SELECT
    'UNUSABLE indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_INDEXES
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'UNUSABLE index partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_IND_PARTITIONS
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'UNUSABLE tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TABLES
  WHERE
    STATUS = 'UNUSABLE'
)
UNION ALL
( SELECT
    'Encrypted columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_ENCRYPTED_COLUMNS EC
  WHERE
    EC.OWNER LIKE BI.OWNER
)
UNION ALL
( SELECT
    'Hidden columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.HIDDEN_COLUMN = 'YES'
)
UNION ALL
( SELECT
    'Virtual columns' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.VIRTUAL_COLUMN = 'YES'
)
UNION ALL
( SELECT
    DECODE(EN.NAME, 'free buffer waits', 'Free buffer waits',
      'log file switch (checkpoint incomplete)', 'Checkpoint not complete',
      'log file switch (archiving needed)', 'Archiver stuck') NAME,
    DECODE(SE.TOTAL_WAITS, NULL, 'No', 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    GV$EVENT_NAME EN, 
    GV$SYSTEM_EVENT SE
  WHERE
    BI.INSTANCE_NUMBER = EN.INST_ID AND
    EN.INST_ID = SE.INST_ID (+) AND
    EN.NAME IN ('free buffer waits', 
                'log file switch (checkpoint incomplete)',
                'log file switch (archiving needed)') AND
    EN.NAME = SE.EVENT (+)
)
UNION ALL
( SELECT
    'PGA multipass executions' NAME,
    TO_CHAR(VALUE) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSSTAT
  WHERE
    NAME = 'workarea executions - multipass'
)
UNION ALL
( SELECT
    'Parallel operations downgraded' NAME,
    TO_CHAR(SUM(VALUE)) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSSTAT
  WHERE
    NAME LIKE 'Parallel operations downgraded%'
)
UNION ALL
( SELECT
    'Tables with parallel degree > 1' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    (DEGREE != '         1' OR 
     INSTANCES NOT IN ( '         0', '         1'))
)
UNION ALL
( SELECT
    'Indexes with parallel degree > 1' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE != 'LOB' AND
    (DEGREE != '1' OR INSTANCES NOT IN ('0', '1'))
)
UNION ALL
( SELECT
    'Tables with > 100 partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_PART_TABLES PT
  WHERE
    PT.OWNER LIKE BI.OWNER AND
    PT.PARTITION_COUNT > 100
)
UNION ALL
( SELECT
    'Indexes with > 100 partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_PART_INDEXES PI
  WHERE
    PI.OWNER LIKE BI.OWNER AND
    PI.PARTITION_COUNT > 100
)
UNION ALL
( SELECT
    'Function based indexes' NAME,
    TO_CHAR(COUNT(DISTINCT(INDEX_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_IND_EXPRESSIONS IE
  WHERE
    IE.INDEX_OWNER LIKE BI.OWNER 
)
UNION ALL
( SELECT
    'Domain indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE = 'DOMAIN'
)
UNION ALL
( SELECT
    'Reverse key indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    INDEX_TYPE = 'NORMAL/REV'
)
UNION ALL
( SELECT
    'Compressed indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'Compressed index partitions' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_IND_PARTITIONS DI
  WHERE
    DI.INDEX_OWNER LIKE BI.OWNER AND
    COMPRESSION = 'ENABLED'
)
UNION ALL
( SELECT
    'Compressed tables (BASIC)' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), TO_CHAR(COUNT(*)) || ' (' || 
      NVL(TO_CHAR(SUM(DECODE(SUBSTR(TABLE_NAME, 1, 4), 
      'GVD_', 1, 'ORA_', 1, 0))), 0) || ' SAP default)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.COMPRESSION = 'ENABLED' AND
    DT.COMPRESS_FOR = 'BASIC'
)
UNION ALL
( SELECT
    'Compressed tables (OLTP)' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.COMPRESSION = 'ENABLED' AND
    DT.COMPRESS_FOR = 'OLTP'
)
UNION ALL
( SELECT
    'Compressed table partitions (BASIC)' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), TO_CHAR(COUNT(*)) || ' (' || 
      NVL(TO_CHAR(SUM(DECODE(SUBSTR(TABLE_NAME, 1, 4), 
      'GVD_', 1, 'ORA_', 1, 0))), 0) || ' SAP default)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TAB_PARTITIONS DT
  WHERE
    DT.TABLE_OWNER LIKE BI.OWNER AND
    DT.COMPRESSION = 'ENABLED' AND
    DT.COMPRESS_FOR = 'BASIC'
)
UNION ALL
( SELECT
    'Compressed table partitions (OLTP)' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TAB_PARTITIONS DT
  WHERE
    DT.TABLE_OWNER LIKE BI.OWNER AND
    DT.COMPRESSION = 'ENABLED' AND
    DT.COMPRESS_FOR = 'OLTP'
)
UNION ALL
( SELECT
    'Compressed SecureFiles' NAME,
    TO_CHAR(NUM_TOTAL) || DECODE(NUM_TOTAL, 0, NULL, ' (' ||
      DECODE(NUM_LOW, 0, NULL, 'LOW: ' || NUM_LOW || DECODE(NUM_MEDIUM + NUM_HIGH, 0, NULL, ', ')) ||
      DECODE(NUM_MEDIUM, 0, NULL, 'MEDIUM: ' || NUM_MEDIUM || DECODE(NUM_HIGH, 0, NULL, ', ')) ||
      DECODE(NUM_HIGH, 0, NULL, 'HIGH: ' || NUM_HIGH) || ')') VALUE      
  FROM 
  ( SELECT
      COUNT(*) NUM_TOTAL,
      SUM(DECODE(DL.COMPRESSION, 'LOW', 1, 0)) NUM_LOW,
      SUM(DECODE(DL.COMPRESSION, 'MEDIUM', 1, 0)) NUM_MEDIUM,
      SUM(DECODE(DL.COMPRESSION, 'HIGH', 1, 0)) NUM_HIGH
    FROM
      BASIS_INFO BI,
      DBA_LOBS DL
    WHERE
      DL.OWNER LIKE BI.OWNER AND
      DL.COMPRESSION IN ('LOW', 'MEDIUM', 'HIGH') 
  )
)
UNION ALL
( SELECT
    'SecureFiles with deduplication' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_LOBS DL
  WHERE
    DL.OWNER LIKE BI.OWNER AND
    DL.DEDUPLICATION = 'YES'
)
UNION ALL
( SELECT
    'NOLOGGING indexes' NAME,
    DECODE(COUNT(*), 0, TO_CHAR(COUNT(*)), 
      TO_CHAR(COUNT(*)) || ' (' || TO_CHAR(SUM(DECODE(SUBSTR(INDEX_NAME, 1, 3), 
      '/BI', 1, 0))) || ' BW indexes)') VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    LOGGING = 'NO'
)
UNION ALL
( SELECT
    'NOLOGGING tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    LOGGING = 'NO' AND
    TEMPORARY = 'N'
)
UNION ALL
( SELECT
    'Temporary tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT                                                  
  WHERE                  
    DT.OWNER LIKE BI.OWNER AND
    TEMPORARY = 'Y'
)
UNION ALL
( SELECT
    'Supplemental logging tables' NAME,
    TO_CHAR(COUNT(DISTINCT(DLG.OWNER || TABLE_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_LOG_GROUPS DLG
  WHERE
    DLG.OWNER LIKE BI.OWNER
)
UNION ALL
( SELECT
    'Tables with primary key constraint' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_CONSTRAINTS C
  WHERE
    C.OWNER LIKE BI.OWNER AND
    C.CONSTRAINT_TYPE = 'P'
)
UNION ALL
( SELECT
    'Index organized tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    IOT_TYPE = 'IOT'
)  
UNION ALL
( SELECT
    'SYS_JOURNAL tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.TABLE_NAME LIKE 'SYS_JOURNAL%'
)  
UNION ALL
( SELECT
    'SYS_IOT_TOP indexes' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_INDEXES DI
  WHERE
    DI.OWNER LIKE BI.OWNER AND
    DI.INDEX_NAME LIKE 'SYS_IOT_TOP%'
)  
UNION ALL
( SELECT
    'QCM tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'QCM%'
)  
UNION ALL
( SELECT
    'MLOG$ tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'MLOG$%'
)  
UNION ALL
( SELECT
    'RUPD$ tables' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    TABLE_NAME LIKE 'RUPD$%'
)  
UNION ALL
( SELECT
    'RECYCLEBIN segments' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_RECYCLEBIN
)
UNION ALL
( SELECT
    'Segments with INITIAL > 100 M' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    SEGMENTS
  WHERE
    INITIAL_EXTENT > 100 * 1024 * 1024
)
UNION ALL
( SELECT
    'Segments with PCTFREE > 10' NAME,
    TO_CHAR(SUM(NUM)) VALUE
  FROM
  ( SELECT
      COUNT(*) NUM
    FROM
      BASIS_INFO BI,
      DBA_TABLES DT
    WHERE
      DT.OWNER LIKE BI.OWNER AND
      DT.PCT_FREE > 10
    UNION ALL
    ( SELECT
        COUNT(*) NUM
      FROM
        BASIS_INFO BI,
        DBA_INDEXES DI
      WHERE
        DI.OWNER LIKE BI.OWNER AND
        DI.PCT_FREE > 10
    )
  )
)
UNION ALL
( SELECT
    'Tables with PCTFREE < 10' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.PCT_FREE < 10 AND 
    DT.COMPRESSION != 'ENABLED'
)
UNION ALL
( SELECT
    'Tables with PCTUSED < 40' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.PCT_USED < 40
)
UNION ALL
( SELECT
    'Segments with INITRANS > 2' NAME,
    TO_CHAR(SUM(NUM)) VALUE
  FROM
  ( SELECT
      COUNT(*) NUM
    FROM
      BASIS_INFO BI,
      DBA_TABLES DT
    WHERE
      DT.OWNER LIKE BI.OWNER AND
      DT.INI_TRANS > 2
    UNION ALL
    ( SELECT
        COUNT(*) NUM
      FROM
        BASIS_INFO BI,
        DBA_INDEXES DI
      WHERE
        DI.OWNER LIKE BI.OWNER AND
        DI.INI_TRANS > 2
    )
  )
)
UNION ALL
( SELECT
    'Materialized views' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_MVIEWS DM
  WHERE
    DM.OWNER LIKE BI.OWNER
)  
UNION ALL
( SELECT
    'Materialized view logs' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_MVIEW_LOGS DM
  WHERE
    DM.LOG_OWNER LIKE BI.OWNER
)  
UNION ALL
( SELECT
    'Segments not in DEFAULT buffer pool' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    SEGMENTS
  WHERE
    BUFFER_POOL != 'DEFAULT'
)
UNION ALL
( SELECT
    'Segments not pre-calculated for DBA_SEGMENTS' NAME,
    TO_CHAR(COUNT(*)) || ' (SYSTEM: ' || TO_CHAR(NVL(SUM(DECODE(
      TABLESPACE_NAME, 'SYSTEM', 1, 0)), 0)) || ')' VALUE
  FROM
    SYS.SYS_DBA_SEGS
  WHERE
    BITAND(SEGMENT_FLAGS, 131073) = 1 AND
    SEGMENT_TYPE NOT IN ('ROLLBACK', 'TYPE2 UNDO') 
)
UNION ALL
( SELECT
    'Outdated DBA_SEGMENTS definition used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_COL_COMMENTS
  WHERE
    OWNER = 'SYS' AND                                    
    TABLE_NAME = 'DBA_SEGMENTS' AND                      
    COLUMN_NAME = 'SEGMENT_TYPE' AND                     
    COMMENTS NOT LIKE '%TYPE2 UNDO%' 
)                    
UNION ALL
( SELECT
    'Outdated SYS_DBA_SEGS helper view used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_VIEWS                         
  WHERE 
    VIEW_NAME = 'SYS_DBA_SEGS_2' 
)
UNION ALL
( SELECT
    'Outdated DBA_EXTENTS helper view used' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    DBA_VIEWS                         
  WHERE 
    VIEW_NAME = 'SAP_DBA_EXTENTS' AND 
    OWNER = 'SYS' 
)
UNION ALL
( SELECT
    'Outdated PLAN_TABLE used' NAME,
    DECODE(COUNT(DISTINCT(TC.OWNER)), NVL(SUM(DECODE(TC.COLUMN_NAME, 
      'FILTER_PREDICATES', 1, 0)), 0), 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLUMNS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    TC.TABLE_NAME = 'PLAN_TABLE'
)
UNION ALL
( SELECT
    'Non-default triggers' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_TRIGGERS
  WHERE
    TRIGGER_NAME NOT IN 
    ( 'DEF$_PROPAGATOR_TRIG', 
      'REPCATLOGTRIG', 
      'AW_DROP_TRG',
      'AW_TRUNC_TRG', 
      'AW_REN_TRG',
      'LOGMNRGGC_TRIGGER' )
)
UNION ALL
( SELECT
    'Non-default sequences' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_SEQUENCES S
  WHERE
    S.SEQUENCE_OWNER LIKE BI.OWNER AND
    SEQUENCE_NAME != 'DDLOG_SEQ'
)
UNION ALL
( SELECT
    'INVALID objects in DDIC' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_OBJECTS
  WHERE
    OWNER IN ('SYS', 'SYSTEM') AND
    STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID constraints' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_CONSTRAINTS DC
  WHERE
    DC.OWNER LIKE BI.OWNER AND
    DC.INVALID = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID views' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O
  WHERE
    O.OWNER LIKE BI.OWNER AND
    O.OBJECT_TYPE = 'VIEW' AND
    O.STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID procedures' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O
  WHERE
    O.OWNER LIKE BI.OWNER AND
    O.OBJECT_TYPE = 'PROCEDURE' AND
    O.STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'INVALID triggers' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O
  WHERE
    O.OWNER LIKE BI.OWNER AND
    O.OBJECT_TYPE = 'TRIGGER' AND
    O.STATUS = 'INVALID'
)
UNION ALL
( SELECT
    'Mismatch client / server characterset' NAME,
    DECODE(SUM(DECODE(SCI.CLIENT_CHARSET || NP.VALUE, 'UTF16UTF8', 0, 
      DECODE(SCI.CLIENT_CHARSET, 'Unknown', 0, 
      NP.VALUE, 0, 1))), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    GV$SESSION_CONNECT_INFO SCI,
    GV$NLS_PARAMETERS NP
  WHERE
    BI.INSTANCE_NUMBER = SCI.INST_ID AND
    BI.INSTANCE_NUMBER = NP.INST_ID AND
    NP.PARAMETER = 'NLS_CHARACTERSET' 
)
UNION ALL
( SELECT
    'Non-default database users' NAME,
    COUNT(*) || DECODE(COUNT(*), 0, ' ', DECODE(COUNT(*), 1, 
      ' (', ' (e.g. ') || MIN(USERNAME) || ')') VALUE
  FROM
    DBA_USERS
  WHERE
    USERNAME NOT IN ('SYS', 'SYSTEM', 'DBSNMP', 'SYSMAN', 'TSMSYS', 
      'OUTLN', 'DIP', 'ORACLE_OCM', 'MGMT_VIEW', 'PERFSTAT',
      'APPQOSSYS') AND
    USERNAME NOT LIKE 'OPS$%' AND
    USERNAME NOT LIKE 'SAP%'
)
UNION ALL
( SELECT
    'EXECUTE on DBMS_LOB revoked' NAME,
    DECODE(COUNT(*), 0, 'Yes', 'No') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_PRIVS P
  WHERE
    P.GRANTEE IN (BI.OWNER, 'PUBLIC') AND
    P.TABLE_NAME = 'DBMS_LOB' AND
    P.PRIVILEGE = 'EXECUTE'
)
UNION ALL
( SELECT
    'Outlines' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_OUTLINES
)
UNION ALL
( SELECT
    'SQL plan baselines' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SQL_PLAN_BASELINES
)
UNION ALL
( SELECT
    'SQL profiles' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SQL_PROFILES
)
UNION ALL
( SELECT
    'SQL patches' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_SQL_PATCHES
)
UNION ALL
( SELECT
    'LOBs with PCTVERSION > 10' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_LOBS DL
  WHERE
    DL.OWNER LIKE BI.OWNER AND
    PCTVERSION > 10    
)
UNION ALL
( SELECT
    'Database links' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    DBA_DB_LINKS
)
UNION ALL
( SELECT
    'Missing ST04 initialization' NAME,
    DECODE(COUNT(*), 0, 'Yes', 'No') VALUE
  FROM
    DBA_VIEWS
  WHERE
    VIEW_NAME = 'SAP_AUXSTATS'
)
UNION ALL
( SELECT
    'Inconsistency system fix control / parameters' NAME,
    DECODE(COUNT(*), 0, 'No', 'Yes') VALUE
  FROM
    FIX_CONTROL_PARAMETERS P,
    V$SYSTEM_FIX_CONTROL F   
  WHERE
    F.BUGNO = P.PBUGNO AND
    F.VALUE != P.PVALUE
)
UNION ALL
( SELECT
    'ORA-01555 errors' NAME,
    TO_CHAR(SUM(SSOLDERRCNT)) VALUE
  FROM
    DBA_HIST_UNDOSTAT
)
UNION ALL
( SELECT
    'Undo space errors' NAME,
    TO_CHAR(SUM(NOSPACEERRCNT)) VALUE
  FROM
    DBA_HIST_UNDOSTAT
)
UNION ALL
( SELECT
    'Multiple redo log sizes' NAME,
    DECODE(SIGN(MAX(BYTES) - MIN(BYTES)), 0, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    GV$LOG L
  WHERE
    BI.INSTANCE_NUMBER = L.INST_ID
)
UNION ALL
( SELECT
    'Log switches within less than 1 minute (last 7 days)' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
  ( SELECT
      ( LH2.FIRST_TIME - LH1.FIRST_TIME ) * 86400 SECONDS
    FROM
      BASIS_INFO BI,
      GV$LOGHIST LH1,
      GV$LOGHIST LH2
    WHERE
      BI.INSTANCE_NUMBER = LH1.INST_ID AND
      LH2.INST_ID = LH1.INST_ID AND
      LH1.FIRST_TIME > SYSDATE - 7 AND
      LH1.THREAD# = LH2.THREAD# AND
      LH1.SEQUENCE# = LH2.SEQUENCE# - 1
  )
  WHERE
    SECONDS BETWEEN 0 AND 60 
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'ORACLE DDIC COMPONENTS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    COMP_ID NAME,
    VERSION || ' (' || STATUS || ')' VALUE            
  FROM 
    DBA_REGISTRY
) 
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'ORACLE JOBS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    JOB_NAME NAME,
    STATE VALUE
  FROM 
    DBA_SCHEDULER_JOBS
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'ORACLE AUTO TASKS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    OPERATION_NAME NAME,
    DECODE(AT.ENABLED, ' ', 'DISABLED', STATUS) VALUE
  FROM
    DBA_AUTOTASK_OPERATION AO,
    ( SELECT 
        DECODE(COUNT(*), 0, ' ', 'X') ENABLED  
      FROM 
        DBA_AUTOTASK_WINDOW_CLIENTS 
      WHERE 
        AUTOTASK_STATUS = 'ENABLED'
    ) AT
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'CHANGE HISTORY:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( SELECT
      TO_CHAR(ACTION_TIME, 'dd.mm.yyyy hh24:mi:ss') NAME,
      ACTION || DECODE(VERSION, NULL, '', ' ' || VERSION ) || 
        DECODE(COMMENTS, NULL, '', ' (' || COMMENTS || ')') VALUE
    FROM
      DBA_REGISTRY_HISTORY
    ORDER BY
      ACTION_TIME
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'USED FEATURES:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( SELECT 
      NAME,
      'used since ' || TO_CHAR(FIRST_USAGE_DATE, 
        'dd.mm.yyyy hh24:mi:ss') VALUE
    FROM                                                    
      DBA_FEATURE_USAGE_STATISTICS                          
    WHERE                                                   
      VERSION = 
      ( SELECT 
          VERSION 
        FROM 
          BASIS_INFO NATURAL JOIN
          GV$INSTANCE ) AND        
      (DETECTED_USAGES > 0 OR CURRENTLY_USED != 'FALSE')  
    ORDER BY
      NAME
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'RESOURCE INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    DECODE(RESOURCE_NAME, 'processes', 'Processes', 'sessions', 'Sessions',
      'parallel_max_servers', 'PX slaves') NAME,
    'current: ' || TO_CHAR(CURRENT_UTILIZATION, 9990) || ', max.: ' || 
      TO_CHAR(MAX_UTILIZATION, 9990) || ', limit: ' || TO_CHAR(INITIAL_ALLOCATION, 99990) VALUE
  FROM 
    BASIS_INFO NATURAL JOIN
    GV$RESOURCE_LIMIT
  WHERE
    RESOURCE_NAME IN ( 'processes',
                       'sessions',
                       'parallel_max_servers')
)  
UNION ALL
( SELECT
    'Datafiles' NAME,
    'current: ' || TO_CHAR(DF_CURRENT.NUM_DATAFILES, 9990) || 
      ',              ' ||
      'limit: ' || TO_CHAR(DF_LIMIT.MAX_DATAFILES, 99990) VALUE
  FROM
  ( SELECT COUNT(*) NUM_DATAFILES FROM DBA_DATA_FILES ) DF_CURRENT,
  ( SELECT VALUE MAX_DATAFILES FROM V$PARAMETER WHERE NAME = 'db_files') DF_LIMIT
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'SPACE INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Tablespaces' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) VALUE
  FROM
    DBA_TABLESPACES
)
UNION ALL
( SELECT
    'Datafiles' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(SUM(BYTES) / 
      1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_DATA_FILES
)
UNION ALL
( SELECT
    'Tempfiles' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(NVL(SUM(BYTES), 0) / 
      1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_TEMP_FILES
)
UNION ALL
( SELECT 
    NAME, 
    VALUE
  FROM
  ( 
    SELECT
      'Segments' NAME,
      TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
        TO_CHAR(ROUND(SUM(BYTES) / 
        1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
    FROM
      SEGMENTS
    UNION ALL
    ( SELECT
        'Extents' NAME,
        TO_CHAR(SUM(EXTENTS), 99999999999999999999999999990) VALUE
      FROM
        SEGMENTS
    )
    UNION ALL
    ( SELECT
        *
      FROM
      ( SELECT
          SUBSTR(SEGMENT_TYPE, 1, 1) || LOWER(SUBSTR(SEGMENT_TYPE, 2)) || 
            DECODE(SEGMENT_TYPE, 'INDEX', 'es', 'LOBINDEX', 'es', 's') NAME,
          TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
            TO_CHAR(ROUND(SUM(BYTES) / 
            1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
        FROM
          SEGMENTS
        WHERE 
          SEGMENT_TYPE IN ( 'TABLE',
                            'TABLE PARTITION',
                            'TABLE SUBPARTITION',
                            'INDEX',
                            'INDEX PARTITION',
                            'INDEX SUBPARTITION',
                            'LOBSEGMENT',
                            'LOBINDEX' )
        GROUP BY
          SUBSTR(SEGMENT_TYPE, 1, 1) || LOWER(SUBSTR(SEGMENT_TYPE, 2)) || 
            DECODE(SEGMENT_TYPE, 'INDEX', 'es', 'LOBINDEX', 'es', 's')
        ORDER BY
          1
      )
    )
  )
)
UNION ALL
( SELECT
    'Freespace fragments' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) || ' (' || 
      TO_CHAR(ROUND(SUM(BYTES) / 1024 / 1024 / 1024, 2), 99990.99) || ' GB)' VALUE
  FROM
    DBA_FREE_SPACE
)
UNION ALL
( SELECT
    'Redo log groups' NAME,
    TO_CHAR(COUNT(*), 99999999999999999999999999990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
)
UNION ALL
( SELECT
    'Redo log members' NAME,
    TO_CHAR(MEMBERS, 99999999999999999999999999990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
  WHERE
    ROWNUM = 1
)
UNION ALL
( SELECT
    'Redo log size (min.)' NAME,
    TO_CHAR(MIN(BYTES) / 1024 / 1024, 99999999999999999999999999990.99) || ' MB' VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$LOG
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'CBO STATISTICS:' NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)   
UNION ALL
( SELECT
    'Last CBO statistics creation' NAME,
    TO_CHAR(MAX(LAST_ANALYZED), 'dd.mm.yyyy hh24:mi:ss') VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_STATISTICS TS
  WHERE
    TS.OWNER LIKE BI.OWNER 
)
UNION ALL
( SELECT
    'DDIC statistics creation' NAME,
    DECODE(LAST_ANALYZED, NULL, 'No', TO_CHAR(LAST_ANALYZED, 
      'dd.mm.yyyy hh24:mi:ss')) VALUE
  FROM
    DBA_TAB_STATISTICS
  WHERE
    OWNER = 'SYS' AND
    TABLE_NAME = 'TAB$'   
)
UNION ALL
( SELECT
    'Fixed objects statistics creation' NAME,
    DECODE(LAST_ANALYZED, NULL, 'No', TO_CHAR(LAST_ANALYZED, 
      'dd.mm.yyyy hh24:mi:ss')) VALUE
  FROM
    DBA_TAB_STATISTICS
  WHERE
    OWNER = 'SYS' AND
    TABLE_NAME = 'X$BH'   
)
UNION ALL
( SELECT
    'Tables with small statistics sample size' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    USER_STATS = 'NO' AND                                           
    NUM_ROWS > 50000 AND                                            
    SAMPLE_SIZE > 100 AND                                           
    SAMPLE_SIZE < 0.2 * NUM_ROWS *                                  
      DECODE(NUM_ROWS, 0, 0, DECODE(TRUNC(LOG(10, GREATEST(NUM_ROWS, BLOCKS))),       
      0, 1, 1, 1, 2, 1, 3, 1, 4, 0.3, 5, 0.1, 6, 0.03, 7, 0.01,     
      8, 0.003, 9, 0.001, 10, 0.0003, 11, 0.0001, 12, 0.00003,      
      0.00001))    
)
UNION ALL
( SELECT
    'Tables without statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    LAST_ANALYZED IS NULL AND
    TEMPORARY = 'N'
)
UNION ALL
( SELECT
    'Tables with locked statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TAB_STATISTICS T                                                  
  WHERE                  
    T.OWNER LIKE BI.OWNER AND
    T.STATTYPE_LOCKED IS NOT NULL
)
UNION ALL
( SELECT
    'Tables with statistics older than segment' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    ( SELECT
        OWNER,
        TABLE_NAME,
        MIN(LAST_ANALYZED) LAST_ANALYZED
      FROM
        DBA_TAB_STATISTICS
      GROUP BY
        OWNER,
        TABLE_NAME
    ) T,
    DBA_OBJECTS O
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.OWNER = O.OWNER AND
    T.TABLE_NAME = O.OBJECT_NAME AND
    O.OBJECT_TYPE = 'TABLE' AND
    O.SUBOBJECT_NAME IS NULL AND
    T.LAST_ANALYZED < O.CREATED
)
UNION ALL
( SELECT
    'Tables with ANALYZE statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.LAST_ANALYZED IS NOT NULL AND
    T.GLOBAL_STATS = 'NO'
)
UNION ALL
( SELECT
    'Indexes without statistics' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_INDEXES I
  WHERE
    I.OWNER LIKE BI.OWNER AND
    I.LAST_ANALYZED IS NULL AND 
    I.INDEX_TYPE != 'LOB'
)
UNION ALL
( SELECT 
    'Columns without statistics' NAME,
    TO_CHAR(COUNT(*)) || ' (' ||
      'LONG: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'LONG', 1, 0)), 0) || ', ' ||
      'LONG RAW: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'LONG RAW', 1, 0)), 0) || ', ' ||
      'LOB: ' || NVL(SUM(DECODE(TCS.DATA_TYPE, 'BLOB', 1, 'CLOB', 1, 
        'BFILE', 1, 'NCLOB', 1, 0)), 0) || ')' VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TABLES T,
    DBA_TAB_COLUMNS TCS
  WHERE
    TCS.OWNER LIKE BI.OWNER AND
    TCS.OWNER = T.OWNER AND
    TCS.TABLE_NAME = T.TABLE_NAME AND
    TCS.LAST_ANALYZED IS NULL
)
UNION ALL
( SELECT
    'Tables with non-default histograms' NAME,
    TO_CHAR(COUNT(DISTINCT(TABLE_NAME))) VALUE
  FROM 
    BASIS_INFO BI,
    DBA_TAB_COL_STATISTICS TCS
  WHERE
    TCS.OWNER LIKE BI.OWNER AND
    HISTOGRAM != 'NONE' AND
    TABLE_NAME NOT LIKE '/BI%' AND 
    TABLE_NAME NOT LIKE '/B20%' AND
    TABLE_NAME NOT IN ('MSEG', 'MKPF', 'RSDD_TMPNM_ADM',
      'LTAP', 'LTBP', 'MKPF', 'BDCP', 'BDCPS', 'PPC_HEAD',
      'RSREQDONE', 'RSSELDONE', 'RSSTATMANREQMAP',
      'RSSTATMANSTATUS', 'RSTSODSREQUEST' )
)
UNION ALL
( SELECT
    'Indexed columns of infocubes without histograms' NAME,
    TO_CHAR(COUNT(*)) VALUE
  FROM
    BASIS_INFO BI,
    DBA_IND_COLUMNS IC,
    DBA_TAB_COL_STATISTICS TC
  WHERE
    TC.OWNER LIKE BI.OWNER AND
    IC.TABLE_OWNER = TC.OWNER AND
    IC.TABLE_NAME = TC.TABLE_NAME AND
    IC.COLUMN_NAME = TC.COLUMN_NAME AND
    ( TC.TABLE_NAME LIKE '/BIC/F%' OR
      TC.TABLE_NAME LIKE '/BIC/9AF%' OR
      TC.TABLE_NAME LIKE '/BI0/F%' OR
      TC.TABLE_NAME LIKE '/BI0/9AF%' OR
      TC.TABLE_NAME LIKE '/BIC/E%' OR
      TC.TABLE_NAME LIKE '/BIC/9AE%' OR
      TC.TABLE_NAME LIKE '/BI0/E%' OR
      TC.TABLE_NAME LIKE '/BI0/9AE%' OR
      TC.TABLE_NAME LIKE '/BIC/D%' OR
      TC.TABLE_NAME LIKE '/BIC/9AD%' OR
      TC.TABLE_NAME LIKE '/BI0/D%' OR
      TC.TABLE_NAME LIKE '/BI0/9AD%' OR
      TC.TABLE_NAME LIKE '/BIC/S%' OR
      TC.TABLE_NAME LIKE '/BIC/9AS%' OR
      TC.TABLE_NAME LIKE '/BI0/S%' OR
      TC.TABLE_NAME LIKE '/BI0/9AS%' OR
      TC.TABLE_NAME LIKE '/BIC/X%' OR
      TC.TABLE_NAME LIKE '/BIC/9AX%' OR
      TC.TABLE_NAME LIKE '/BI0/X%' OR
      TC.TABLE_NAME LIKE '/BI0/9AX%' OR
      TC.TABLE_NAME LIKE '/BIC/Y%' OR
      TC.TABLE_NAME LIKE '/BIC/9AY%' OR
      TC.TABLE_NAME LIKE '/BI0/Y%' OR
      TC.TABLE_NAME LIKE '/BI0/9AY%' OR
      TC.TABLE_NAME LIKE '/BIC/I%' OR
      TC.TABLE_NAME LIKE '/BIC/9AI%' OR
      TC.TABLE_NAME LIKE '/BI0/I%' OR
      TC.TABLE_NAME LIKE '/BI0/9AI%' OR
      TC.TABLE_NAME LIKE '/BIC/P%' OR
      TC.TABLE_NAME LIKE '/BIC/9AP%' OR
      TC.TABLE_NAME LIKE '/BI0/P%' OR 
      TC.TABLE_NAME LIKE '/BI0/9AP%' OR
      TC.TABLE_NAME LIKE '/BIC/Q%' OR
      TC.TABLE_NAME LIKE '/BIC/9AQ%' OR
      TC.TABLE_NAME LIKE '/BI0/Q%' OR
      TC.TABLE_NAME LIKE '/BI0/9AQ%' OR
      TC.TABLE_NAME LIKE '/BI0/02%' OR
      TC.TABLE_NAME LIKE '/BI0/06%'
    ) AND
    TC.NUM_DISTINCT > 0 AND
    TC.HISTOGRAM = 'NONE'
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)   
UNION ALL
( SELECT
    'KEY FIGURES (SINCE DATABASE START):' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    'Buffer quality' NAME, 
    TO_CHAR(ROUND((1 - S2.VALUE / S1.VALUE) * 100, 2), 99999999999999999999999999990.99) || ' %' VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'session logical reads' AND
    S2.NAME = 'physical reads cache'
)
UNION ALL
( SELECT
    'Reads / user call' NAME, 
    TO_CHAR(DECODE(S2.VALUE, 0, 0, ROUND(S1.VALUE / S2.VALUE, 2)), 
      99999999999999999999999999990.99) VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'session logical reads' AND  
    S2.NAME = 'user calls'
)
UNION ALL
( SELECT
    'User / recursive calls' NAME, 
    TO_CHAR(DECODE(S2.VALUE, 0, 0, ROUND(S1.VALUE / S2.VALUE, 2)), 
      99999999999999999999999999990.99) VALUE
  FROM
    BASIS_INFO BI,
    GV$SYSSTAT S1,
    GV$SYSSTAT S2
  WHERE
    BI.INSTANCE_NUMBER = S1.INST_ID AND
    S1.INST_ID = S2.INST_ID AND
    S1.NAME = 'user calls' AND  
    S2.NAME = 'recursive calls'
)
UNION ALL
( SELECT
    NAME,
    VALUE
  FROM
  ( WITH SECONDS AS
    ( SELECT 
        TO_CHAR(SYSDATE, 'SSSSS') - TO_CHAR(STARTUP_TIME, 'SSSSS') +
          86400 * (TO_CHAR(SYSDATE, 'J') - TO_CHAR(STARTUP_TIME, 'J')) 
          SECONDS
       FROM
         V$INSTANCE
    ), 
    TIMED_EVENTS AS
    ( SELECT 
        'CPU' NAME,
        VALUE / 10000 TIME_WAITED
      FROM
        BASIS_INFO BI NATURAL JOIN
        GV$SYS_TIME_MODEL
      WHERE
        STAT_NAME = 'DB CPU' 
      UNION ALL
      ( SELECT 
          WAIT_CLASS NAME,
          TIME_WAITED
        FROM
          BASIS_INFO BI NATURAL JOIN
          GV$SYSTEM_WAIT_CLASS
      )
    ) 
    ( SELECT
        'Time / user call' NAME,
        TO_CHAR(STM.VALUE / 1000 / SS.VALUE, 
          99999999999999999999999999990.99) || ' ms' VALUE
      FROM
        BASIS_INFO BI,
        GV$SYS_TIME_MODEL STM, 
        GV$SYSSTAT SS
      WHERE
        BI.INSTANCE_NUMBER = STM.INST_ID AND
        BI.INSTANCE_NUMBER = SS.INST_ID AND
        STM.STAT_NAME = 'DB time' AND
        SS.NAME = 'user calls'
    )
    UNION ALL
    ( SELECT
        SS.NAME || ' / s' NAME,
        TO_CHAR(ROUND(VALUE / S.SECONDS, 2), 99999999999999999999999999990.99) VALUE
      FROM
        BASIS_INFO BI,
        GV$SYSSTAT SS, 
        SECONDS S
      WHERE
        BI.INSTANCE_NUMBER = SS.INST_ID AND
        SS.NAME IN ('user calls', 
                    'user commits', 
                    'recursive calls',
                    'session logical reads',
                    'consistent changes',
                    'physical reads',
                    'physical reads cache prefetch',
                    'db block changes',
                    'physical writes',
                    'redo blocks written',
                    'bytes sent via SQL*Net to client',
                    'bytes received via SQL*Net from client',
                    'SQL*Net roundtrips to/from client',
                    'parse count (total)',
                    'parse count (hard)',
                    'table fetch by rowid',
                    'table fetch continued row')
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        'TIMED EVENTS (SINCE DATABASE START):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          TE.NAME || ' sessions active' NAME,
          TO_CHAR(ROUND(TE.TIME_WAITED / 100 / S.SECONDS, 2), 
            99999999999999999999999999990.99) || ' (' || TO_CHAR(ROUND(RATIO_TO_REPORT 
            (TE.TIME_WAITED) OVER () * 100, 2), 90.99) || ' %)' VALUE,
          RATIO_TO_REPORT (TE.TIME_WAITED) OVER () * 100 PCT
        FROM
          TIMED_EVENTS TE, SECONDS S
        WHERE
          TE.NAME != 'Idle'
        ORDER BY
          TE.TIME_WAITED DESC
      )
      WHERE 
        PCT >= 1
    )
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'TOP I/O READ TABLESPACES (SINCE DATABASE START):' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    TABLESPACE_NAME NAME,
    TO_CHAR(PERCENT, 
        99999999999999999999999999990.99) || ' %' VALUE
  FROM
  ( SELECT
      TABLESPACE_NAME,
      TO_CHAR(SUM(IO_READ_TIME_S), 9999999999990) IO_READ_TIME_S,
      TO_CHAR(RATIO_TO_REPORT(SUM(IO_READ_TIME_S)) OVER () * 100, 990.99) PERCENT
    FROM
    ( SELECT
        TS.NAME TABLESPACE_NAME,
        FS.READTIM / 100 IO_READ_TIME_S
      FROM
        BASIS_INFO BI,
        GV$FILESTAT FS,
        GV$DATAFILE DF,
        GV$TABLESPACE TS
      WHERE
        BI.INSTANCE_NUMBER = FS.INST_ID AND
        FS.INST_ID = DF.INST_ID AND
        FS.INST_ID = TS.INST_ID AND
        FS.FILE# = DF.FILE# AND
        DF.TS# = TS.TS# 
      UNION ALL
      ( SELECT
          TS.NAME TABLESPACE_NAME,
          FS.READTIM / 100 IO_READ_TIME_S
        FROM
          BASIS_INFO BI,
          GV$TEMPSTAT FS,
          GV$TEMPFILE DF,
          GV$TABLESPACE TS
        WHERE
          BI.INSTANCE_NUMBER = FS.INST_ID AND
          FS.INST_ID = DF.INST_ID AND
          FS.INST_ID = TS.INST_ID AND
          FS.FILE# = DF.FILE# AND
          DF.TS# = TS.TS#
      )  
    )
    GROUP BY
      TABLESPACE_NAME
    ORDER BY
      IO_READ_TIME_S DESC
  )
  WHERE
    ROWNUM <= 10
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    *
  FROM
  ( WITH ASH AS
    ( SELECT
        ASH.INSTANCE_NUMBER,
        ASH.SQL_OPNAME SQL_TYPE,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.MODULE,
        U.USERNAME USER_NAME,
        ASH.SESSION_TYPE,
        COUNT(*) OCCURRENCES
      FROM
        BASIS_INFO BI,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        DBA_USERS U
      WHERE
        BI.DBID = ASH.DBID AND
        DECODE(SUBSTR(UPPER('<Y for excluding ASH information>'), 
          1, 1),'Y','Y','N') = 'N' AND
        ASH.USER_ID = U.USER_ID (+)
      GROUP BY
        ASH.INSTANCE_NUMBER,
        ASH.SQL_OPNAME,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.MODULE,
        U.USERNAME,
        ASH.SESSION_TYPE
    )
    ( SELECT
        'TOP ACTIONS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          SQL_TYPE || DECODE(SQL_TYPE, 'UNKNOWN', ' (' || PROGRAM || ')', '') NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          SQL_TYPE || DECODE(SQL_TYPE, 'UNKNOWN', ' (' || PROGRAM || ')', '')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  UNION ALL
    ( SELECT
        'TOP MODULES (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          NVL(MODULE, 'UNKNOWN (' || PROGRAM || ')')  NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          NVL(MODULE, 'UNKNOWN (' || PROGRAM || ')')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  UNION ALL
    ( SELECT
        'TOP PROGRAMS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          PROGRAM NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          PROGRAM
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  
    UNION ALL
    ( SELECT
        'TOP USERS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          NVL(USER_NAME, 'UNKNOWN') || DECODE(SESSION_TYPE, 'BACKGROUND', ' (BACKGROUND)') NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          NVL(USER_NAME, 'UNKNOWN') || DECODE(SESSION_TYPE, 'BACKGROUND', ' (BACKGROUND)')
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  
    UNION ALL
    ( SELECT
        'TOP CLIENT IDS (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          CLIENT_ID NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          CLIENT_ID
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )  
    UNION ALL
    ( SELECT
        'TOP INSTANCES (FROM ASH):' NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NULL NAME,
        NULL VALUE
      FROM 
        DUAL
    )
    UNION ALL
    ( SELECT
        NAME,
        VALUE
      FROM
      ( SELECT
          TO_CHAR(INSTANCE_NUMBER) NAME,
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 
            99999999999999999999999999990.99) || ' %' VALUE
        FROM
          ASH
        GROUP BY
          INSTANCE_NUMBER
        ORDER BY
          SUM(OCCURRENCES) DESC
      )
      WHERE
        ROWNUM <= 5
    )
  )
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)  
UNION ALL
( SELECT
    'AWR / ASH INFORMATION:' NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    NULL NAME,
    NULL VALUE
  FROM 
    DUAL
)
UNION ALL
( SELECT
    'Multiple database IDs' NAME,
    DECODE(COUNT(DISTINCT(HSS.DBID)), 0, 'No', 1, 'No', 'Yes') VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER
)
UNION ALL
( SELECT
    'Captured SQL statements' NAME,
    TOPNSQL VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'Snapshot interval (minutes)' NAME,
    TO_CHAR(EXTRACT(DAY FROM SNAP_INTERVAL) * 1440 +
      EXTRACT(HOUR FROM SNAP_INTERVAL) * 60 + 
      EXTRACT(MINUTE FROM SNAP_INTERVAL), 99990) VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'Snapshot retention (days)' NAME,
    TO_CHAR(ROUND(EXTRACT(DAY FROM RETENTION) +
      EXTRACT(HOUR FROM RETENTION) / 24 + 
      EXTRACT(MINUTE FROM RETENTION) / 1440, 2), 99990) VALUE
  FROM
    BASIS_INFO BI,
    DBA_HIST_WR_CONTROL HWC
  WHERE
    BI.DBID = HWC.DBID
)      
UNION ALL
( SELECT
    'V$ACTIVE_SESSION_HISTORY time (hours)' NAME,
    TO_CHAR(ROUND((TO_CHAR(LATEST_SAMPLE_TIME, 'SSSSS') - 
      TO_CHAR(OLDEST_SAMPLE_TIME, 'SSSSS') +
      86400 * (TO_CHAR(LATEST_SAMPLE_TIME, 'J') - 
      TO_CHAR(OLDEST_SAMPLE_TIME, 'J'))) / 3600, 2), 99990) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$ASH_INFO
)
UNION ALL
( SELECT
    'AWR size in SYSAUX (MB)' NAME,
    TO_CHAR(SPACE_USAGE_KBYTES / 1024, 99990.99) VALUE
  FROM
    BASIS_INFO NATURAL JOIN
    GV$SYSAUX_OCCUPANTS
  WHERE
    OCCUPANT_DESC = 
      'Server Manageability - Automatic Workload Repository'
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c7eed9e-014d-1000-800b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Parameters]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL PARAMETER_NAME, NULL VALUE, NULL IS_DEFAULT, NULL IS_MODIFIED, NULL DESCRIPTION FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL PARAMETER_NAME, NULL VALUE, NULL IS_DEFAULT, NULL IS_MODIFIED, NULL DESCRIPTION FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    '%' PARAMETER_NAME,
    'SET' PARAMETER_STATUS     /* DEFAULT, SET, ALL */
  FROM
    DUAL
)
SELECT
  P.NAME PARAMETER_NAME,
  P.VALUE,
  P.ISDEFAULT IS_DEFAULT,
  P.ISMODIFIED IS_MODIFIED,
  P.DESCRIPTION
FROM
  BASIS_INFO BI,
  V$PARAMETER2 P
WHERE
  P.NAME LIKE BI.PARAMETER_NAME AND
  ( BI.PARAMETER_STATUS = 'ALL' OR
    BI.PARAMETER_STATUS = 'DEFAULT' AND P.ISDEFAULT = 'TRUE' AND P.ISMODIFIED = 'FALSE' OR
    BI.PARAMETER_STATUS = 'SET' AND ( P.ISDEFAULT = 'FALSE' OR P.ISMODIFIED != 'FALSE' ) )
ORDER BY
  P.NAME
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c7fafee-014d-1000-800c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Parameters_Changes]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL PARAMETER_NAME, NULL VALUE, NULL IS_DEFAULT,
  NULL VALUE_BEFORE, NULL WAS_DEFAULT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL PARAMETER_NAME, NULL VALUE, NULL IS_DEFAULT,
  NULL VALUE_BEFORE, NULL WAS_DEFAULT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    PARAMETER_NAME
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      '%' PARAMETER_NAME
    FROM 
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
)
SELECT
  DECODE(R.ID, 1, TO_CHAR(BEGIN_TIME, 'YYYY-MM-DD HH24:MI:SS'), ' ') BEGIN_TIME,
  DECODE(R.ID, 1, PARAMETER_NAME, ' ') PARAMETER_NAME,
  SUBSTR(VALUE, 1 + 59 * (R.ID - 1), 59) VALUE,
  DECODE(R.ID, 1, IS_DEFAULT, ' ') IS_DEFAULT,
  SUBSTR(VALUE_BEFORE, 1 + 59 * (R.ID - 1), 59) VALUE_BEFORE,
  DECODE(R.ID, 1, WAS_DEFAULT, ' ') WAS_DEFAULT
FROM
( SELECT ROWNUM ID FROM V$SESSTAT WHERE ROWNUM <= 20 ) R,
( SELECT
    HSS.BEGIN_INTERVAL_TIME BEGIN_TIME,
    HP2.PARAMETER_NAME PARAMETER_NAME,
    HP2.VALUE VALUE,
    NVL(HP2.ISDEFAULT, 'UNKNOWN') IS_DEFAULT,
    HP1.VALUE VALUE_BEFORE,
    NVL(HP1.ISDEFAULT, 'UNKNOWN') WAS_DEFAULT
  FROM
    BASIS_INFO BI,
    DBA_HIST_PARAMETER HP1, 
    DBA_HIST_PARAMETER HP2, 
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HP1.DBID AND
    BI.DBID = HP2.DBID AND
    BI.DBID = HSS.DBID AND
    BI.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
    BI.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
    BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
    HP1.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
    HP2.PARAMETER_NAME = HP1.PARAMETER_NAME AND
    HP2.SNAP_ID = HSS.SNAP_ID AND
    HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
    HP1.PARAMETER_NAME = HP2.PARAMETER_NAME AND 
    HP2.VALUE != HP1.VALUE
  UNION 
  ( SELECT
      HSS.BEGIN_INTERVAL_TIME BEGIN_TIME,
      HP2.PARAMETER_NAME,
      HP2.VALUE,
      NVL(HP2.ISDEFAULT, 'UNKNOWN') IS_DEFAULT,
      NULL VALUE_BEFORE,
      'TRUE' WAS_DEFAULT
    FROM
      BASIS_INFO BI,
      DBA_HIST_PARAMETER HP2,
      DBA_HIST_SNAPSHOT HSS
    WHERE
      BI.DBID = HP2.DBID AND
      BI.DBID = HSS.DBID AND
      BI.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HP2.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
      HP2.SNAP_ID = HSS.SNAP_ID AND
      EXISTS
      ( SELECT
          * 
        FROM 
          BASIS_INFO BI,
          DBA_HIST_PARAMETER HP1 
        WHERE
          BI.DBID = HP1.DBID AND
          BI.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
          HP1.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
          HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
          HP1.PARAMETER_NAME = 'sessions'
      ) AND
      NOT EXISTS
      ( SELECT 
          * 
        FROM 
          BASIS_INFO BI,
          DBA_HIST_PARAMETER HP1 
        WHERE
          BI.DBID = HP1.DBID AND
          BI.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
          HP1.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
          HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
          HP1.PARAMETER_NAME = HP2.PARAMETER_NAME
      )
  )
  UNION 
  ( SELECT
      HSS.BEGIN_INTERVAL_TIME BEGIN_TIME,
      HP1.PARAMETER_NAME,
      NULL VALUE,
      'TRUE' IS_DEFAULT,
      HP1.VALUE VALUE_BEFORE,
      NVL(HP1.ISDEFAULT, 'UNKNOWN') WAS_DEFAULT
    FROM
      BASIS_INFO BI,
      DBA_HIST_PARAMETER HP1,
      DBA_HIST_SNAPSHOT HSS
    WHERE
      BI.DBID = HP1.DBID AND
      BI.DBID = HSS.DBID AND
      BI.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HP1.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
      HP1.SNAP_ID = HSS.SNAP_ID AND
      EXISTS
      ( SELECT
          * 
        FROM 
          BASIS_INFO BI,
          DBA_HIST_PARAMETER HP2 
        WHERE
          BI.DBID = HP2.DBID AND
          BI.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
          HP2.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
          HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
          HP2.PARAMETER_NAME = 'sessions'
      ) AND
      NOT EXISTS
      ( SELECT 
          * 
        FROM 
          BASIS_INFO BI,
          DBA_HIST_PARAMETER HP2
        WHERE
          BI.DBID = HP2.DBID AND
          BI.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
          HP2.PARAMETER_NAME LIKE BI.PARAMETER_NAME AND
          HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
          HP1.PARAMETER_NAME = HP2.PARAMETER_NAME
      )
  )  
) P
WHERE
  R.ID <= TRUNC(LENGTH(P.VALUE) - 1) / 59 + 1 OR
  R.ID <= TRUNC(LENGTH(P.VALUE_BEFORE) - 1) / 59 + 1 OR
  R.ID <= 1
ORDER BY
  P.BEGIN_TIME DESC,
  P.PARAMETER_NAME,
  R.ID
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c800c26-014d-1000-800d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Parameters_FIX_CONTROL_Inconsistency]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BUGNO, NULL PARAMETER_VALUE, NULL EFFECTIVE_VALUE
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BUGNO, NULL PARAMETER_VALUE, NULL EFFECTIVE_VALUE
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER
  FROM
  ( SELECT
      -1 INSTANCE_NUMBER
    FROM
      DUAL
   )
),
FIX_CONTROL_PARAMETERS AS
( SELECT /*+ MATERIALIZE */
    BUGNO PBUGNO,
    DECODE(UPPER(VALUE), 'ON', 1, 'OFF', 0, VALUE) PVALUE
  FROM
  ( SELECT
      SUBSTR(VALUE, 1, INSTR(VALUE, ':') - 1) BUGNO,
      SUBSTR(VALUE, INSTR(VALUE, ':') + 1) VALUE
    FROM
    ( SELECT
        REPLACE(VALUE, CHR(10), NULL) VALUE
      FROM
        BASIS_INFO BI,
        GV$PARAMETER2 P
      WHERE
        BI.INSTANCE_NUMBER = P.INST_ID AND
        UPPER(NAME) = '_FIX_CONTROL'
    )
  )
)
SELECT
  F.BUGNO,
  P.PVALUE PARAMETER_VALUE,
  F.VALUE EFFECTIVE_VALUE
FROM
  FIX_CONTROL_PARAMETERS P,
  V$SYSTEM_FIX_CONTROL F   
WHERE
  F.BUGNO = P.PBUGNO AND
  F.VALUE != P.PVALUE
ORDER BY
  F.BUGNO
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c80ece6-014d-1000-800e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Patches]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL ACTION_TIME, NULL ACTION, NULL NAMESPACE, NULL VERSION,
  NULL BUNDLE_SERIES, NULL COMMENTS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL ACTION_TIME, NULL ACTION, NULL NAMESPACE, NULL VERSION,
  NULL BUNDLE_SERIES, NULL COMMENTS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    '%' BUNDLE_SERIES           /* e.g. SBP */
  FROM
    DUAL
)
SELECT
  TO_CHAR(RH.ACTION_TIME, 'dd.mm.yyyy hh24:mi:ss') ACTION_TIME,
  RH.ACTION,
  RH.NAMESPACE,
  RH.VERSION,
  RH.BUNDLE_SERIES,
  RH.COMMENTS
FROM
  BASIS_INFO BI,
  DBA_REGISTRY_HISTORY RH
WHERE
  NVL(RH.BUNDLE_SERIES, ' ') LIKE BI.BUNDLE_SERIES 
ORDER BY
  RH.ACTION_TIME DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c81e90d-014d-1000-800f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_SYSAUX_Content]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SCHEMA, NULL AREA, NULL SIZE_MB, NULL "SIZE_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SCHEMA, NULL AREA, NULL SIZE_MB, NULL "SIZE_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    10 NUM_RECORDS
  FROM
    DUAL
)
SELECT
  SCHEMA_NAME SCHEMA,
  OCCUPANT_DESC AREA,
  TO_CHAR(SPACE_USAGE_KBYTES / 1024, 99990.99) SIZE_MB,
  TO_CHAR(RATIO_TO_REPORT(SPACE_USAGE_KBYTES) OVER () * 100, 990.99) "SIZE_%"
FROM
( SELECT
    SO.SCHEMA_NAME,
    SO.OCCUPANT_DESC,
    SO.SPACE_USAGE_KBYTES,
    BI.NUM_RECORDS
  FROM
    BASIS_INFO BI,
    V$SYSAUX_OCCUPANTS SO
  ORDER BY
    SPACE_USAGE_KBYTES DESC
)
WHERE 
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c837e5c-014d-1000-8010-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Configuration_Triggers]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL TRIGGER_NAME, NULL TRIGGER_TYPE, NULL TRIGGERING_EVENT,
  NULL TABLE_OWNER, NULL TABLE_NAME FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TRIGGER_NAME, NULL TRIGGER_TYPE, NULL TRIGGERING_EVENT,
  NULL TABLE_OWNER, NULL TABLE_NAME FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    :OWNER OWNER,
    :TABLE_OWNER TABLE_OWNER
  FROM
    DUAL
)
SELECT
  DT.OWNER,
  DT.TRIGGER_NAME,
  DT.TRIGGER_TYPE,
  DT.TRIGGERING_EVENT,
  DT.TABLE_OWNER,
  DT.TABLE_NAME
FROM
  BASIS_INFO BI,
  DBA_TRIGGERS DT
WHERE
  DT.OWNER LIKE BI.OWNER AND
  ( DT.TABLE_OWNER IS NULL AND BI.TABLE_OWNER = '%' OR
    DT.TABLE_OWNER LIKE BI.TABLE_OWNER )
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_OWNER">
						<prompt><![CDATA[TABLE_OWNER]]></prompt>
						<tooltip><![CDATA[TABLE_OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Transactions]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2c84d3cc-014d-1000-8011-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Transactions_CurrentUndoUtilization]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TRANSACTION_ID, NULL START_DATE, NULL SID, NULL INST, 
  NULL INTERVAL_S, NULL UBLKS_USED, NULL UBLKS_DIFF_PER_S, 
  NULL ACTIVITY, NULL ROLLBACK_END_TIME FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TRANSACTION_ID, NULL START_DATE, NULL SID, NULL INST, 
  NULL INTERVAL_S, NULL UBLKS_USED, NULL UBLKS_DIFF_PER_S, 
  NULL ACTIVITY, NULL ROLLBACK_END_TIME FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SESSION_ID,
    TRANSACTION_ID,
    UNDO_BLOCKS_THRESHOLD,
    ONLY_ROLLBACK,
    SLEEP_CYCLES
  FROM
  ( SELECT
      -1 INSTANCE_NUMBER,             /* -1 for current instance, -2 for all instances */
      -1 SESSION_ID,
      '%' TRANSACTION_ID,
      -1 UNDO_BLOCKS_THRESHOLD,
      ' ' ONLY_ROLLBACK,
      10 SLEEP_CYCLES
    FROM
      DUAL
  )
),
CYCLES AS
( SELECT
    ROWNUM CNT
  FROM
    BASIS_INFO BI,
    V$SESSTAT SS
  WHERE
    ROWNUM <= BI.SLEEP_CYCLES
),
TIME_1 AS
( SELECT /*+ MATERIALIZE */
    CTIME SECONDS
  FROM
    V$LOCK
  WHERE
    TYPE = 'MR' AND
    ROWNUM = 1
),
SAMPLE_1 AS
( SELECT /*+ MATERIALIZE */
    START_DATE,
    SID,
    INST_ID,
    TRANSACTION_ID,
    UNDO_BLOCKS_USED,
    FAST_START
  FROM
  ( SELECT
      S.SID SID,
      S.INST_ID INST_ID,
      T.XID TRANSACTION_ID,
      T.START_DATE,
      T.USED_UBLK UNDO_BLOCKS_USED,
      ' ' FAST_START
    FROM
      BASIS_INFO BI,
      GV$TRANSACTION T, 
      GV$SESSION S 
    WHERE
      ( BI.INSTANCE_NUMBER = -2 OR T.INST_ID = BI.INSTANCE_NUMBER ) AND
      (BI.SESSION_ID = -1 OR S.SID = BI.SESSION_ID ) AND
      T.XID LIKE BI.TRANSACTION_ID AND
      S.SADDR = T.SES_ADDR AND
      S.INST_ID = T.INST_ID AND
      ( BI.UNDO_BLOCKS_THRESHOLD = -1 OR 
        T.USED_UBLK >= BI.UNDO_BLOCKS_THRESHOLD ) 
    UNION ALL
    ( SELECT
        NULL SID,
        NULL INST_ID,
        T.XID TRANSACTION_ID,
        NULL START_DATE,
        T.UNDOBLOCKSTOTAL - T.UNDOBLOCKSDONE UNDO_BLOCKS_USED,
        'X' FAST_START
      FROM
        BASIS_INFO BI,
        GV$FAST_START_TRANSACTIONS T
      WHERE
        ( BI.INSTANCE_NUMBER = -2 OR T.INST_ID = BI.INSTANCE_NUMBER ) AND
        T.XID (+) LIKE BI.TRANSACTION_ID AND
        ( BI.UNDO_BLOCKS_THRESHOLD = -1 OR 
          T.UNDOBLOCKSTOTAL - T.UNDOBLOCKSDONE >= BI.UNDO_BLOCKS_THRESHOLD ) 
    )
    ORDER BY
      UNDO_BLOCKS_USED DESC 
  )
),
SLEEPING AS
( SELECT /*+ MATERIALIZE */
    1
  FROM
    V$SESSTAT SS,
    CYCLES C
),
TIME_2 AS
( SELECT /*+ MATERIALIZE */
    CTIME SECONDS
  FROM
    V$LOCK
  WHERE
    TYPE = 'MR' AND
    ROWNUM = 1
),
SAMPLE_2 AS
( SELECT /*+ MATERIALIZE */
    START_DATE,
    SID,
    INST_ID,
    TRANSACTION_ID,
    UNDO_BLOCKS_USED,
    FAST_START
  FROM
  ( SELECT
      S.SID SID,
      S.INST_ID INST_ID,
      T.XID TRANSACTION_ID,
      T.START_DATE,
      T.USED_UBLK UNDO_BLOCKS_USED,
      ' ' FAST_START
    FROM
      BASIS_INFO BI,
      GV$TRANSACTION T, 
      GV$SESSION S
    WHERE
      ( BI.INSTANCE_NUMBER = -2 OR T.INST_ID = BI.INSTANCE_NUMBER ) AND
      ( BI.SESSION_ID = -1 OR S.SID = BI.SESSION_ID ) AND
      T.XID LIKE BI.TRANSACTION_ID AND
      S.SADDR = T.SES_ADDR AND
      S.INST_ID = T.INST_ID AND
      ( BI.UNDO_BLOCKS_THRESHOLD = -1 OR 
        T.USED_UBLK >= BI.UNDO_BLOCKS_THRESHOLD ) 
    UNION ALL
    ( SELECT
        NULL SID,
        NULL INST_ID,
        T.XID TRANSACTION_ID,
        NULL START_DATE,
        T.UNDOBLOCKSTOTAL - T.UNDOBLOCKSDONE UNDO_BLOCKS_USED,
        'X' FAST_START
      FROM
        BASIS_INFO BI,
        GV$FAST_START_TRANSACTIONS T
      WHERE
        ( BI.INSTANCE_NUMBER = -2 OR T.INST_ID = BI.INSTANCE_NUMBER ) AND
        T.XID (+) LIKE BI.TRANSACTION_ID AND
        ( BI.UNDO_BLOCKS_THRESHOLD = -1 OR 
          T.UNDOBLOCKSTOTAL - T.UNDOBLOCKSDONE >= BI.UNDO_BLOCKS_THRESHOLD ) 
    )
    ORDER BY
      UNDO_BLOCKS_USED DESC 
  )
)
SELECT
  'Evaluation date:' TRANSACTION_ID,
  TO_CHAR(SYSDATE, 'dd.mm.yyyy hh24:mi:ss') START_DATE, 
  NULL SID, NULL INST, 
  NULL INTERVAL_S, NULL UBLKS_USED, NULL UBLKS_DIFF_PER_S, 
  NULL ACTIVITY, NULL ROLLBACK_END_TIME 
FROM
  DUAL
UNION ALL
( SELECT
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
  FROM
    DUAL
)
UNION ALL
( SELECT
  *
  FROM
  ( SELECT
      TO_CHAR(RAWTOHEX(S1.TRANSACTION_ID)) TRANSACTION_ID,
      NVL(TO_CHAR(S1.START_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'n/a') START_DATE,
      TO_CHAR(S1.SID, 9990) SID,
      TO_CHAR(S1.INST_ID, 9990) INST,
      TO_CHAR(ROUND(T2.SECONDS - T1.SECONDS), 999999990) INTERVAL_S,
      TO_CHAR(S1.UNDO_BLOCKS_USED, 999999990) UBLKS_USED,
      TO_CHAR(DECODE(T2.SECONDS - T1.SECONDS, 0, 0, 
        (S2.UNDO_BLOCKS_USED - S1.UNDO_BLOCKS_USED) / 
        (T2.SECONDS - T1.SECONDS)), 
        999999999990.99) UBLKS_DIFF_PER_S,
      DECODE(S2.FAST_START, 'X', 'FAST START ROLLBACK',
        DECODE(SIGN(S2.UNDO_BLOCKS_USED - S1.UNDO_BLOCKS_USED), -1, 
        'ROLLBACK', 'TRANSACTION')) ACTIVITY,
      DECODE(SIGN(S2.UNDO_BLOCKS_USED - S1.UNDO_BLOCKS_USED), -1,
        TO_CHAR(SYSDATE + (T2.SECONDS - T1.SECONDS) * 
        S1.UNDO_BLOCKS_USED / ( S1.UNDO_BLOCKS_USED - 
        S2.UNDO_BLOCKS_USED ) / 86400, 
        'dd.mm.yyyy hh24:mi:ss')) ROLLBACK_END_TIME
    FROM
      BASIS_INFO BI,
      TIME_1 T1,
      TIME_2 T2,
      SAMPLE_1 S1,
      SAMPLE_2 S2
    WHERE
      NVL(S1.SID, 0) = NVL(S2.SID, 0) AND
      NVL(S1.INST_ID, 0) = NVL(S2.INST_ID, 0) AND
      S1.TRANSACTION_ID = S2.TRANSACTION_ID AND
      ( BI.ONLY_ROLLBACK != 'X' OR 
        S2.UNDO_BLOCKS_USED < S1.UNDO_BLOCKS_USED )
    ORDER BY
      S1.UNDO_BLOCKS_USED DESC
  )
  UNION ALL
  ( SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL 
    FROM SLEEPING WHERE 1 = 0 )
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c852963-014d-1000-8012-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Transactions_ORA1555]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT
  TO_CHAR(BEGIN_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
  TO_CHAR(END_TIME, 'dd.mm.yyyy hh24:mi:ss') END_TIME,
  TO_CHAR(SSOLDERRCNT, 9999999990) NUM_ORA1555,
  TO_CHAR(MAXQUERYLEN, 9999990) MAXLEN_S,
  MAXQUERYSQLID MAX_SQL_ID,
  TO_CHAR(ACTIVEBLKS * 8192 / 1024 / 1024 / 1024, 99990.99) ACTIVE_GB,
  TO_CHAR(UNEXPIREDBLKS * 8192 / 1024 / 1024 / 1024, 99999990.99) UNEXPIRED_GB,
  TO_CHAR(TUNED_UNDORETENTION, 999999999999999990) TUNED_UNDORETENTION
FROM
  DBA_HIST_UNDOSTAT U
WHERE
  SSOLDERRCNT > 0
ORDER BY
  U.BEGIN_TIME DESC]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c87bfda-014d-1000-8013-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Transactions_UndoStatistics]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_DATE, NULL MAXQUERY_S, NULL SQL_ID, NULL MAX_CONCURRENT, NULL UNCOMMITTED_MB,
  NULL UNEXPIRED_MB, NULL EXPIRED_MB, NULL EXP_RELOC_MB, NULL TUNED_RETENTION FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_DATE, NULL MAXQUERY_S, NULL SQL_ID, NULL MAX_CONCURRENT, NULL UNCOMMITTED_MB,
  NULL UNEXPIRED_MB, NULL EXPIRED_MB, NULL EXP_RELOC_MB, NULL TUNED_RETENTION FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    UNDO_BLOCK_SIZE_BYTE,
    DATA_SOURCE
  FROM
  ( SELECT
      :INSTANCE_NUMBER INSTANCE_NUMBER,        
      TO_DATE('01.01.1000 01:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 22:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      (select block_size from dba_tablespaces where contents ='UNDO' and rownum<2) UNDO_BLOCK_SIZE_BYTE,
      'CURRENT' DATA_SOURCE       /* AWR, CURRENT */
    FROM
      DUAL
  )
),
UNDO_STATISTICS AS
( SELECT
    U.BEGIN_TIME,
    U.MAXQUERYLEN,
    U.MAXQUERYID,
    U.MAXCONCURRENCY,
    U.ACTIVEBLKS,
    U.UNEXPIREDBLKS,
    U.EXPIREDBLKS,
    U.EXPBLKRELCNT,
    U.TUNED_UNDORETENTION
  FROM
    BASIS_INFO BI,
    GV$UNDOSTAT U
  WHERE
    BI.INSTANCE_NUMBER = U.INST_ID AND
    U.BEGIN_TIME >= BI.BEGIN_DATE AND
    U.END_TIME <= BI.END_DATE AND
    BI.DATA_SOURCE = 'CURRENT'
  UNION ALL
  ( SELECT
      U.BEGIN_TIME,
      U.MAXQUERYLEN,
      U.MAXQUERYSQLID MAXQUERYID,
      U.MAXCONCURRENCY,
      U.ACTIVEBLKS,
      U.UNEXPIREDBLKS,
      U.EXPIREDBLKS,
      U.EXPBLKRELCNT,
      U.TUNED_UNDORETENTION
    FROM
      BASIS_INFO BI,
      DBA_HIST_UNDOSTAT U
    WHERE
      BI.INSTANCE_NUMBER = U.INSTANCE_NUMBER AND
      U.BEGIN_TIME >= BI.BEGIN_DATE AND
      U.END_TIME <= BI.END_DATE AND
      BI.DATA_SOURCE = 'AWR'
  )
)
SELECT
  TO_CHAR(U.BEGIN_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
  TO_CHAR(U.MAXQUERYLEN, 999999990) MAXQUERY_S,
  U.MAXQUERYID SQL_ID,
  TO_CHAR(U.MAXCONCURRENCY, 9999999999990) MAX_CONCURRENT,
  TO_CHAR(U.ACTIVEBLKS * BI.UNDO_BLOCK_SIZE_BYTE / 1024 / 1024, 9999999990.99) UNCOMMITTED_MB,
  TO_CHAR(U.UNEXPIREDBLKS * BI.UNDO_BLOCK_SIZE_BYTE / 1024 / 1024, 99999990.99) UNEXPIRED_MB,
  TO_CHAR(U.EXPIREDBLKS * BI.UNDO_BLOCK_SIZE_BYTE / 1024 / 1024, 999990.99) EXPIRED_MB,
  TO_CHAR(U.EXPBLKRELCNT * BI.UNDO_BLOCK_SIZE_BYTE / 1024 / 1024, 99999990.99) EXP_RELOC_MB,
  TO_CHAR(U.TUNED_UNDORETENTION, 99999999999990) TUNED_RETENTION
FROM
  BASIS_INFO BI,
  UNDO_STATISTICS U
ORDER BY
  TO_CHAR(U.BEGIN_TIME, 'yyyy.mm.dd hh24:mi:ss') DESC
))]]></sql>
				<binds>
					<bind id="INSTANCE_NUMBER">
						<prompt><![CDATA[INSTANCE_NUMBER]]></prompt>
						<tooltip><![CDATA[INSTANCE_NUMBER]]></tooltip>
						<value><![CDATA[1]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[TimedEvents]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2c8ad939-014d-1000-8014-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_EventHistogram]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL EVENT, NULL UPPER_WAIT_TIME_MS, NULL WAIT_COUNT, NULL TIME_WAITED_MS,
  NULL PERCENT, NULL CUM_PERCENT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL EVENT, NULL UPPER_WAIT_TIME_MS, NULL WAIT_COUNT, NULL TIME_WAITED_MS,
  NULL PERCENT, NULL CUM_PERCENT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    EVENT_NAME
  FROM
  ( SELECT
      -1 INSTANCE_NUMBER,
      :EVENT_NAME EVENT_NAME
    FROM
      DUAL
  )
)
SELECT
  EVENT,
  LPAD(UPPER_WAIT_TIME_MS, 18) UPPER_WAIT_TIME_MS,
  LPAD(WAIT_COUNT, 10) WAIT_COUNT,
  TO_CHAR(TIME_WAITED_MS, 9999999999990) TIME_WAITED_MS,
  TO_CHAR(PERCENT, 990.99) PERCENT,
  TO_CHAR(SUM(PERCENT) OVER (ORDER BY UPPER_WAIT_TIME_MS 
    RANGE UNBOUNDED PRECEDING), 9999990.99) CUM_PERCENT
FROM
( SELECT 
    EH.EVENT,
    EH.WAIT_TIME_MILLI UPPER_WAIT_TIME_MS,
    EH.WAIT_COUNT,
    EH.WAIT_TIME_MILLI * DECODE(EH.WAIT_TIME_MILLI, 1, 0.5, 0.75) * 
      EH.WAIT_COUNT TIME_WAITED_MS,
    RATIO_TO_REPORT(EH.WAIT_TIME_MILLI * 
      DECODE(EH.WAIT_TIME_MILLI, 1, 0.5, 0.75) * EH.WAIT_COUNT) 
      OVER () * 100 PERCENT
  FROM 
    BASIS_INFO BI,
    GV$EVENT_HISTOGRAM EH
  WHERE
    BI.INSTANCE_NUMBER = EH.INST_ID AND
    EH.EVENT LIKE BI.EVENT_NAME
)
ORDER BY
  EVENT,
  UPPER_WAIT_TIME_MS
))]]></sql>
				<binds>
					<bind id="EVENT_NAME">
						<prompt><![CDATA[EVENT_NAME]]></prompt>
						<tooltip><![CDATA[EVENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c8c6469-014d-1000-8015-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_EventHistogram_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL UPPER_WAIT_TIME_MS, NULL WAIT_COUNT, NULL TIME_WAITED_S,
  NULL PERCENT, NULL CUM_PERCENT, NULL ACTIVE_SESSIONS FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL UPPER_WAIT_TIME_MS, NULL WAIT_COUNT, NULL TIME_WAITED_S,
  NULL PERCENT, NULL CUM_PERCENT, NULL ACTIVE_SESSIONS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM ( 
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    EVENT_NAME
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 11:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      :EVENT_NAME EVENT_NAME
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    MIN_SNAP_ID,
    PREV_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (PARTITION BY HSS2.INSTANCE_NUMBER ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER 
      ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
TOTAL_SECONDS AS
( SELECT
    MAX(SUM(INTERVAL_SECONDS)) TOTAL_SECONDS
  FROM
    SNAPSHOTS
  GROUP BY
    DBID,
    INSTANCE_NUMBER
),
EVENT_HISTOGRAM_PER_SNAPSHOT AS
( SELECT /*+ MATERIALIZE */
    SS.DBID,
    SS.INSTANCE_NUMBER,
    SS.SNAP_ID,
    BI.EVENT_NAME,
    EH2.WAIT_TIME_MILLI,
    DECODE(SS.RESTART, 
      'YES', EH2.WAIT_COUNT,
      'NO',  EH2.WAIT_COUNT - EH1.WAIT_COUNT) WAIT_COUNT
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS,
    DBA_HIST_EVENT_HISTOGRAM EH1,
    DBA_HIST_EVENT_HISTOGRAM EH2
  WHERE
    EH2.DBID = SS.DBID AND
    EH1.DBID (+) = EH2.DBID AND
    EH2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
    EH1.INSTANCE_NUMBER (+) = EH2.INSTANCE_NUMBER AND
    SS.SNAP_ID != SS.MIN_SNAP_ID AND
    SS.PREV_SNAP_ID IS NOT NULL AND
    EH2.SNAP_ID = SS.SNAP_ID AND
    EH1.SNAP_ID = SS.PREV_SNAP_ID AND
    EH2.EVENT_NAME = BI.EVENT_NAME AND
    EH1.EVENT_NAME (+) = EH2.EVENT_NAME AND
    EH1.WAIT_TIME_MILLI (+) = EH2.WAIT_TIME_MILLI
) 
SELECT
  'BEGIN:    ' || TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss')  UPPER_WAIT_TIME_MS,
  NULL TOTAL_WAITS,
  NULL TIME_WAITED_S,
  NULL PERCENT,
  NULL CUM_PERCENT,
  NULL ACTIVE_SESSIONS
FROM 
  SNAPSHOTS
WHERE
  SNAP_ID != MIN_SNAP_ID
UNION ALL
( SELECT 
    'END:      ' || TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') UPPER_WAIT_TIME_MS,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED_S,
    NULL PERCENT,
    NULL CUM_PERCENT,
  NULL ACTIVE_SESSIONS
  FROM 
    SNAPSHOTS
)
UNION ALL
( SELECT 
    'INSTANCE: ' || DECODE(INSTANCE_NUMBER, -2, 'ALL', TO_CHAR(INSTANCE_NUMBER)) UPPER_WAIT_TIME_MS,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED_S,
    NULL PERCENT,
    NULL CUM_PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    'EVENT:    ' || EVENT_NAME UPPER_WAIT_TIME_MS,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED_S,
    NULL PERCENT,
    NULL CUM_PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    NULL UPPER_WAIT_TIME_MS,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED_S,
    NULL PERCENT,
    NULL CUM_PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    TO_CHAR(UPPER_WAIT_TIME_MS, 99999999999999999999999999999990) UPPER_WAIT_TIME_MS,
    TO_CHAR(TOTAL_WAITS, 99999999990) TOTAL_WAITS,
    TO_CHAR(TIME_WAITED_S, 999999990.99) TIME_WAITED_S,
    TO_CHAR(PERCENT, 990.99) PERCENT,
    TO_CHAR(CUM_PERCENT, 9999990.99) CUM_PERCENT,
    TO_CHAR(ACTIVE_SESSIONS, 99999999990.99) ACTIVE_SESSIONS
  FROM
  ( SELECT
      UPPER_WAIT_TIME_MS,
      TOTAL_WAITS,
      TIME_WAITED_S,
      PERCENT,
      SUM(PERCENT) OVER (ORDER BY UPPER_WAIT_TIME_MS RANGE UNBOUNDED PRECEDING) CUM_PERCENT,
      TIME_WAITED_S / TOTAL_SECONDS ACTIVE_SESSIONS
    FROM
    ( SELECT
        EH.WAIT_TIME_MILLI UPPER_WAIT_TIME_MS,
        EH.WAIT_TIME_MILLI * DECODE(EH.WAIT_TIME_MILLI, 1, 0.5, 0.75) * 
          SUM(EH.WAIT_COUNT) / 1000 TIME_WAITED_S,
        SUM(EH.WAIT_COUNT) TOTAL_WAITS,
        RATIO_TO_REPORT(EH.WAIT_TIME_MILLI * 
          DECODE(EH.WAIT_TIME_MILLI, 1, 0.5, 0.75) * SUM(EH.WAIT_COUNT)) OVER () * 100 PERCENT,
        TS.TOTAL_SECONDS
      FROM
        TOTAL_SECONDS TS,
        EVENT_HISTOGRAM_PER_SNAPSHOT EH
      GROUP BY
        EH.WAIT_TIME_MILLI,
        TS.TOTAL_SECONDS
    )
    ORDER BY 
      UPPER_WAIT_TIME_MS
  )
)
))]]></sql>
				<binds>
					<bind id="EVENT_NAME">
						<prompt><![CDATA[EVENT_NAME]]></prompt>
						<tooltip><![CDATA[EVENT_NAME]]></tooltip>
						<value><![CDATA[latch free]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c8e8e78-014d-1000-8017-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_EventHistogramPerAWRInterval_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  NULL BEGIN_TIME, NULL TOTAL_S, NULL "   1", NULL "   2", NULL "   4", NULL "   8",
  NULL "  16", NULL "  32", NULL "  64", NULL " 128", NULL " 256", NULL " 512",
  NULL "1024", NULL "2048", NULL "MORE" FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL BEGIN_TIME, NULL TOTAL_S, NULL "   1", NULL "   2", NULL "   4", NULL "   8",
  NULL "  16", NULL "  32", NULL "  64", NULL " 128", NULL " 256", NULL " 512",
  NULL "1024", NULL "2048", NULL "MORE" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM ( 
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    EVENT_NAME,
    AGGREGATE_BY,
    SORT_ORDER
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 11:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      :EVENT_NAME EVENT_NAME,
      'SNAPSHOT' AGGREGATE_BY,  /* SNAPSHOT, DAY, HOUR_OF_DAY, INSTANCE, SS_INST, DAY_INST, HOD_INST */
      'DESC' SORT_ORDER    /* ASC, DESC */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    MIN_SNAP_ID,
    PREV_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (PARTITION BY HSS2.INSTANCE_NUMBER ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER 
      ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
EVENT_HISTOGRAM_PER_SNAPSHOT AS
( SELECT /*+ MATERIALIZE */
    SS.DBID,
    SS.INSTANCE_NUMBER,
    SS.SNAP_ID,
    SS.BEGIN_INTERVAL_TIME,
    BI.EVENT_NAME,
    EH2.WAIT_TIME_MILLI,
    DECODE(SS.RESTART, 
      'YES', EH2.WAIT_COUNT,
      'NO',  EH2.WAIT_COUNT - EH1.WAIT_COUNT) WAIT_COUNT
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS,
    DBA_HIST_EVENT_HISTOGRAM EH1,
    DBA_HIST_EVENT_HISTOGRAM EH2
  WHERE
    EH2.DBID = SS.DBID AND
    EH1.DBID (+) = EH2.DBID AND
    EH2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
    EH1.INSTANCE_NUMBER (+) = EH2.INSTANCE_NUMBER AND
    SS.SNAP_ID != SS.MIN_SNAP_ID AND
    SS.PREV_SNAP_ID IS NOT NULL AND
    EH2.SNAP_ID = SS.SNAP_ID AND
    EH1.SNAP_ID = SS.PREV_SNAP_ID AND
    EH2.EVENT_NAME = BI.EVENT_NAME AND
    EH1.EVENT_NAME (+) = EH2.EVENT_NAME AND
    EH1.WAIT_TIME_MILLI (+) = EH2.WAIT_TIME_MILLI
) 
SELECT
  'INSTANCE: ' || DECODE(INSTANCE_NUMBER, -2, 'ALL', TO_CHAR(INSTANCE_NUMBER)) BEGIN_TIME,
  NULL TOTAL_S,
  NULL "   1",
  NULL "   2",
  NULL "   4",
  NULL "   8",
  NULL "  16",
  NULL "  32",
  NULL "  64",
  NULL " 128",
  NULL " 256",
  NULL " 512",
  NULL "1024",
  NULL "2048",
  NULL "MORE"
FROM 
  BASIS_INFO
UNION ALL
( SELECT 
    'EVENT: ' || EVENT_NAME BEGIN_TIME,
    NULL TOTAL_S,
    NULL "   1",
    NULL "   2",
    NULL "   4",
    NULL "   8",
    NULL "  16",
    NULL "  32",
    NULL "  64",
    NULL " 128",
    NULL " 256",
    NULL " 512",
    NULL "1024",
    NULL "2048",
    NULL "MORE"
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    NULL BEGIN_TIME,
    NULL TOTAL_S,
    NULL "   1",
    NULL "   2",
    NULL "   4",
    NULL "   8",
    NULL "  16",
    NULL "  32",
    NULL "  64",
    NULL " 128",
    NULL " 256",
    NULL " 512",
    NULL "1024",
    NULL "2048",
    NULL "MORE"
  FROM 
    DUAL
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT 
      BEGIN_TIME,
      TO_CHAR(TIME_WAITED_S, 9999990) TOTAL_S,
      TO_CHAR("   1", 990) "   1",
      TO_CHAR("   2", 990) "   2",
      TO_CHAR("   4", 990) "   4",
      TO_CHAR("   8", 990) "   8",
      TO_CHAR("  16", 990) "  16",
      TO_CHAR("  32", 990) "  32",
      TO_CHAR("  64", 990) "  64",
      TO_CHAR(" 128", 990) " 128",
      TO_CHAR(" 256", 990) " 256",
      TO_CHAR(" 512", 990) " 512",
      TO_CHAR("1024", 990) "1024",
      TO_CHAR("2048", 990) "2048",
      TO_CHAR("MORE", 990) "MORE"
    FROM
    ( SELECT
        BEGIN_TIME,
        SUM(TIME_WAITED_S) TIME_WAITED_S,
        SUM(DECODE(UPPER_WAIT_TIME_MS, 1, PERCENT, 0)) "   1",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 2, PERCENT, 0)) "   2",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 4, PERCENT, 0)) "   4",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 8, PERCENT, 0)) "   8",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 16, PERCENT, 0)) "  16",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 32, PERCENT, 0)) "  32",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 64, PERCENT, 0)) "  64",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 128, PERCENT, 0)) " 128",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 256, PERCENT, 0)) " 256",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 512, PERCENT, 0)) " 512",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 1024, PERCENT, 0)) "1024",
        SUM(DECODE(UPPER_WAIT_TIME_MS, 2048, PERCENT, 0)) "2048",
        SUM(DECODE(SIGN(UPPER_WAIT_TIME_MS - 3000), 1, PERCENT, 0)) "MORE",
        SORT_ORDER
      FROM
      ( SELECT
          BEGIN_TIME,
          TIME_WAITED_S,
          UPPER_WAIT_TIME_MS,
          RATIO_TO_REPORT(UPPER_WAIT_TIME_MS * 
            DECODE(UPPER_WAIT_TIME_MS, 1, 0.5, 0.75) * TOTAL_WAITS) OVER 
            (PARTITION BY BEGIN_TIME) * 100 PERCENT,
          SORT_ORDER
        FROM
        ( SELECT
            DECODE(BI.AGGREGATE_BY,
              'SNAPSHOT', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
              'DAY', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
              'HOUR_OF_DAY', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'HH24') || ':00',
              'INSTANCE', 'Instance: ' || TO_CHAR(EH.INSTANCE_NUMBER),
              'SS_INST', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') ||
                 ' (Instance: ' || TO_CHAR(EH.INSTANCE_NUMBER) || ')',
              'DAY_INST', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)') ||
                 ' (Instance: ' || TO_CHAR(EH.INSTANCE_NUMBER) || ')',
              'HOD_INST', TO_CHAR(EH.BEGIN_INTERVAL_TIME, 'HH24') || ':00' ||
                 ' (Instance: ' || TO_CHAR(EH.INSTANCE_NUMBER) || ')') BEGIN_TIME,
            EH.WAIT_TIME_MILLI UPPER_WAIT_TIME_MS,
            EH.WAIT_TIME_MILLI * DECODE(EH.WAIT_TIME_MILLI, 1, 0.5, 0.75) * 
              EH.WAIT_COUNT / 1000 TIME_WAITED_S,
            EH.WAIT_COUNT TOTAL_WAITS,
            BI.SORT_ORDER
          FROM
            BASIS_INFO BI,
            EVENT_HISTOGRAM_PER_SNAPSHOT EH
        )
      )
      GROUP BY 
        BEGIN_TIME,
        SORT_ORDER
    )
    ORDER BY
      DECODE(SORT_ORDER, 
        'ASC', BEGIN_TIME, '1'),
      DECODE(SORT_ORDER, 
        'DESC', BEGIN_TIME, '1') DESC
  )
)
))]]></sql>
				<binds>
					<bind id="EVENT_NAME">
						<prompt><![CDATA[EVENT_NAME]]></prompt>
						<tooltip><![CDATA[EVENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c8fa867-014d-1000-8018-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_EventMetric]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TIME_INTERVAL, NULL EVENT, NULL ACT_SESS, NULL PERCENT, NULL TIME_WAITED_S,
  NULL WAIT_COUNT, NULL AVG_WAIT_MS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TIME_INTERVAL, NULL EVENT, NULL ACT_SESS, NULL PERCENT, NULL TIME_WAITED_S,
  NULL WAIT_COUNT, NULL AVG_WAIT_MS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,   
    EVENT,
    MIN_WAIT_TIME_MS,
    EXCLUDE_IDLE_EVENTS,
    EXCLUDE_SYSTEM,
    EXCLUDE_ADMINISTRATIVE,
    AVG_RTT_US,
    ORDER_BY
  FROM
  ( SELECT 
      -1 INSTANCE_NUMBER,
      '%' EVENT,
      1 MIN_WAIT_TIME_MS,
      'X' EXCLUDE_IDLE_EVENTS,
      'X' EXCLUDE_SYSTEM,
      'X' EXCLUDE_ADMINISTRATIVE,
      400 AVG_RTT_US,      /* adapt with system specific roundtrip time in micro seconds */
      'TIME' ORDER_BY      /* TIME, EVENT */
    FROM
      DUAL
  )
)
SELECT
  TO_CHAR(BEGIN_TIME, 'dd.mm.yyyy hh24:mi:ss') || ' - ' ||
    TO_CHAR(END_TIME, 'dd.mm.yyyy hh24:mi:ss') TIME_INTERVAL,
  EVENT,
  TO_CHAR(ACTIVE_SESSIONS, 9990.99) ACT_SESS,
  TO_CHAR(RATIO_TO_REPORT(ACTIVE_SESSIONS) OVER () * 100, 990.99) PERCENT,
  TO_CHAR(TIME_WAITED_CS / 100, 999999990.99) TIME_WAITED_S,
  TO_CHAR(WAIT_COUNT, 999999990) WAIT_COUNT,
  TO_CHAR(DECODE(WAIT_COUNT, 0, 0, TIME_WAITED_CS * 10 / WAIT_COUNT), 9999990.99) AVG_WAIT_MS
FROM
( SELECT
    EM.BEGIN_TIME,
    EM.END_TIME,
    EN.NAME EVENT,
    EM.TIME_WAITED / 100 / ( EM.END_TIME - EM.BEGIN_TIME ) / 86400 ACTIVE_SESSIONS,
    EM.TIME_WAITED TIME_WAITED_CS,
    EM.WAIT_COUNT,
    BI.ORDER_BY
  FROM    
    BASIS_INFO BI,
    GV$EVENTMETRIC EM, 
    GV$EVENT_NAME EN
  WHERE
    BI.INSTANCE_NUMBER = EM.INST_ID AND
    EM.INST_ID = EN.INST_ID AND
    EN.NAME LIKE BI.EVENT AND
    EM.EVENT# = EN.EVENT# AND
    ( BI.MIN_WAIT_TIME_MS = -1 OR TIME_WAITED * 10 >= BI.MIN_WAIT_TIME_MS ) AND
    ( BI.EXCLUDE_IDLE_EVENTS != 'X' OR EN.WAIT_CLASS != 'Idle' ) AND
    ( BI.EXCLUDE_SYSTEM = ' ' OR 
      EN.WAIT_CLASS != 'System I/O'
    ) AND
    ( BI.EXCLUDE_ADMINISTRATIVE = ' ' OR 
      ( EN.WAIT_CLASS != 'Administrative' AND
        EN.NAME NOT IN ( 'ARCH wait on SENDREQ', 'LNS wait on SENDREQ' ) 
      )
    )
  UNION ALL
  ( SELECT
      SM.BEGIN_TIME,
      SM.END_TIME,
      'CPU' METRIC_NAME,
      SM.VALUE / 100 / ( SM.END_TIME - SM.BEGIN_TIME ) / 86400 ACTIVE_SESSIONS,
      SM.VALUE TIME_WAITED_CS,
      NULL WAIT_COUNT,
      BI.ORDER_BY
    FROM
      BASIS_INFO BI,
      GV$SYSMETRIC SM
    WHERE
      BI.INSTANCE_NUMBER = SM.INST_ID AND
      SM.GROUP_ID = 2 AND 
      SM.METRIC_NAME IN ('CPU Usage Per Sec', 'Host CPU Usage Per Sec') AND
      ( BI.MIN_WAIT_TIME_MS = -1 OR SM.VALUE * 10 >= BI.MIN_WAIT_TIME_MS )
  )
  UNION ALL
  ( SELECT
      SM.BEGIN_TIME,
      SM.END_TIME,
      'Network' METRIC_NAME,
      SM.VALUE * AVG_RTT_US / 1000000 ACTIVE_SESSIONS,
      SM.VALUE *  ( SM.END_TIME - SM.BEGIN_TIME ) * 86400 * AVG_RTT_US / 10000 TIME_WAITED_CS,
      SM.VALUE *  ( SM.END_TIME - SM.BEGIN_TIME ) * 86400 WAIT_COUNT,
      BI.ORDER_BY
    FROM
      BASIS_INFO BI,
      GV$SYSMETRIC SM
    WHERE
      BI.INSTANCE_NUMBER = SM.INST_ID AND
      SM.GROUP_ID = 2 AND 
      SM.METRIC_NAME = 'User Calls Per Sec' AND
      ( BI.MIN_WAIT_TIME_MS = -1 OR SM.VALUE * 10 >= BI.MIN_WAIT_TIME_MS )
  )
)
ORDER BY
  DECODE(ORDER_BY, 'TIME', TIME_WAITED_CS, 0) DESC,
  DECODE(ORDER_BY, 'EVENT', EVENT, NULL)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c91a6ce-014d-1000-8019-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_EventPerAWRInterval]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL INST, NULL ACT_SESS, NULL TOTAL_WAITS,
  NULL TOTAL_TIMEOUTS, NULL TIME_WAITED_S, NULL AVG_MS FROM DUAL
  WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL INST, NULL ACT_SESS, NULL TOTAL_WAITS,
  NULL TOTAL_TIMEOUTS, NULL TIME_WAITED_S, NULL AVG_MS  FROM DUAL
  WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    RTT_MICRO,
    EVENT,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY,
    MIN_AVG_DIRECT_PATH_TIME_MS,
    CONSIDER_TIMEOUTS,
    EXCLUDE_WEEKENDS,
    EXCLUDE_ZERO_LINES
  FROM
  ( SELECT
      -1 DBID,
      -3 INSTANCE_NUMBER,          /* -1: current instance, -2: all instances aggregated, -3: all instances individually */
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      400 RTT_MICRO,
      :EVENT_NAME EVENT,
      'SNAPSHOT' AGGREGATE_BY,    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
      1 MIN_AVG_DIRECT_PATH_TIME_MS,
      'X' CONSIDER_TIMEOUTS,
      ' ' EXCLUDE_WEEKENDS,
      'X' EXCLUDE_ZERO_LINES
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    PREV_SNAP_ID,
    MIN_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    SUM(INTERVAL_SECONDS) OVER () TOTAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        BI.INSTANCE_NUMBER = -3 OR
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER
      ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
TIMED_EVENTS_PER_SNAPSHOT AS
( SELECT /*+ MATERIALIZE */
    SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INSTANCE_NUMBER,
    INTERVAL_SECONDS,
    EVENT_NAME,
    TOTAL_WAITS - DECODE(CONSIDER_TIMEOUTS, 'X', TOTAL_TIMEOUTS, 0) TOTAL_WAITS,
    TOTAL_TIMEOUTS,      
    GREATEST(DECODE(SUBSTR(EVENT_NAME, 1, 6), 'direct', 
      MIN_AVG_DIRECT_PATH_TIME_MS * 1000 * TOTAL_WAITS, 0),
      TIME_WAITED_MICRO) TIME_WAITED_MICRO
  FROM
  ( SELECT
      SS.SNAP_ID,
      SS.BEGIN_INTERVAL_TIME,
      SS.END_INTERVAL_TIME,       
      SS.INSTANCE_NUMBER,
      SS.INTERVAL_SECONDS,
      HSE2.EVENT_NAME,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_WAITS - NVL(HSE1.TOTAL_WAITS, 0),
        HSE2.TOTAL_WAITS) TOTAL_WAITS,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_TIMEOUTS - NVL(HSE1.TOTAL_TIMEOUTS, 0),
        HSE2.TOTAL_TIMEOUTS) TOTAL_TIMEOUTS,
      DECODE(SS.RESTART, 'NO', HSE2.TIME_WAITED_MICRO - 
        NVL(HSE1.TIME_WAITED_MICRO, 0), HSE2.TIME_WAITED_MICRO) TIME_WAITED_MICRO,
      BI.MIN_AVG_DIRECT_PATH_TIME_MS,
      BI.CONSIDER_TIMEOUTS
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSTEM_EVENT HSE1, 
      DBA_HIST_SYSTEM_EVENT HSE2
    WHERE
      SS.DBID = HSE2.DBID AND
      HSE1.DBID (+) = HSE2.DBID AND
      SS.INSTANCE_NUMBER = HSE2.INSTANCE_NUMBER AND
      HSE1.INSTANCE_NUMBER (+) = HSE2.INSTANCE_NUMBER AND
      SS.SNAP_ID = HSE2.SNAP_ID AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      SS.SNAP_ID != SS.MIN_SNAP_ID AND
      HSE1.SNAP_ID (+) = HSE2.SNAP_ID - 1 AND
      HSE1.EVENT_NAME (+) = HSE2.EVENT_NAME AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      HSE2.WAIT_CLASS != 'Idle' AND
      HSE2.EVENT_NAME = BI.EVENT
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INSTANCE_NUMBER,
        SS.INTERVAL_SECONDS,
        'CPU' EVENT_NAME,
        NULL TOTAL_WAITS,
        NULL TOTAL_TIMEOUTS,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0) , 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYS_TIME_MODEL HSY1,  
        DBA_HIST_SYS_TIME_MODEL HSY2
      WHERE
        HSY1.DBID (+) = HSY2.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        HSY2.STAT_NAME = 'DB CPU' AND
        BI.EVENT = 'CPU'
    )
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INSTANCE_NUMBER,
        SS.INTERVAL_SECONDS,
        'NETWORK' EVENT_NAME,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE -
          NVL(HSY1.VALUE, 0), HSY2.VALUE) TOTAL_WAITS,
        0 TOTAL_TIMEOUTS,
          BI.RTT_MICRO * DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0), 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2
      WHERE
        SS.DBID = HSY2.DBID AND
        HSY1.DBID (+) = HSY2.DBID AND
        SS.INSTANCE_NUMBER = HSY2.INSTANCE_NUMBER AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        SS.SNAP_ID = HSY2.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        HSY2.STAT_NAME = 'user calls' AND
        BI.EVENT = 'NETWORK'                
    )
  )
)
SELECT
  'BEGIN TIME: ' || TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') TIMEFRAME,
  NULL INST,
  NULL ACT_SESS,
  NULL TOTAL_WAITS,
  NULL TOTAL_TIMEOUTS,
  NULL TIME_WAITED_S,
  NULL AVG_MS
FROM
  SNAPSHOTS
WHERE
  SNAP_ID != MIN_SNAP_ID
UNION ALL
( SELECT
    'END TIME:   ' || TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') TIMEFRAME,
    NULL INST,
    NULL ACT_SESS,
    NULL TOTAL_WAITS,
    NULL TOTAL_TIMEOUTS,
    NULL TIME_WAITED_S,
    NULL AVG_MS
  FROM
    SNAPSHOTS
)
UNION ALL
( SELECT
    'EVENT: ' || EVENT TIMEFRAME,
    NULL INST,
    NULL ACT_SESS,
    NULL TOTAL_WAITS,
    NULL TOTAL_TIMEOUTS,
    NULL TIME_WAITED_S,
    NULL AVG_MS
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'WEEKENDS EXCLUDED: ' || DECODE(EXCLUDE_WEEKENDS, 'X', 'YES', 'NO') TIMEFRAME,
    NULL INST,
    NULL ACT_SESS,
    NULL TOTAL_WAITS,
    NULL TOTAL_TIMEOUTS,
    NULL TIME_WAITED_S,
    NULL AVG_MS
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL TIMEFRAME,
    NULL INST,
    NULL ACT_SESS,
    NULL TOTAL_WAITS,
    NULL TOTAL_TIMEOUTS,
    NULL TIME_WAITED_S,
    NULL AVG_MS
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    BEGIN_TIME,
    INST,
    ACT_SESS,
    TOTAL_WAITS,
    TOTAL_TIMEOUTS,
    TIME_WAITED_S,
    AVG_MS
  FROM
  ( SELECT
      BEGIN_TIME,
      DECODE(INSTANCE_NUMBER, 0, 'any', TO_CHAR(INSTANCE_NUMBER, 990)) INST,
      EVENT_NAME,
      TO_CHAR(DECODE(INTERVAL_SECONDS, 0, 0, WAIT_TIME_MS / 1000 / INTERVAL_SECONDS), 9990.99) ACT_SESS,
      TO_CHAR(TOTAL_WAITs, 999999999990) TOTAL_WAITS,
      TO_CHAR(TOTAL_TIMEOUTS, 9999999999990) TOTAL_TIMEOUTS,
      TO_CHAR(WAIT_TIME_MS / 1000, 999999999990) TIME_WAITED_S,
      TO_CHAR(DECODE(TOTAL_WAITS, 0, 0, WAIT_TIME_MS / TOTAL_WAITS), 99999990.99) AVG_MS
    FROM
    ( SELECT
        BEGIN_TIME,
        INSTANCE_NUMBER,
        EVENT_NAME,
        SUM(INTERVAL_SECONDS) INTERVAL_SECONDS,
        SUM(WAIT_TIME_MS) WAIT_TIME_MS,
        SUM(TOTAL_WAITS) TOTAL_WAITS,
        SUM(TOTAL_TIMEOUTS) TOTAL_TIMEOUTS
      FROM
      ( SELECT
          BEGIN_TIME, 
          INSTANCE_NUMBER,
          MAX(INTERVAL_SECONDS) INTERVAL_SECONDS,
          EVENT_NAME,
          SUM(WAIT_TIME_MS) WAIT_TIME_MS,
          SUM(TOTAL_WAITS) TOTAL_WAITS,
          SUM(TOTAL_TIMEOUTS) TOTAL_TIMEOUTS
        FROM
        ( SELECT
            TE.SNAP_ID,
            MIN(TO_CHAR(BEGIN_INTERVAL_TIME, BI.AGGREGATE_BY)) OVER (PARTITION BY TE.SNAP_ID) BEGIN_TIME,
            DECODE(BI.INSTANCE_NUMBER, -2, 0, TE.INSTANCE_NUMBER) INSTANCE_NUMBER,
            TE.INTERVAL_SECONDS,
            TE.EVENT_NAME,
            TE.TIME_WAITED_MICRO / 1000 WAIT_TIME_MS,
            TE.TOTAL_WAITS,
            TE.TOTAL_TIMEOUTS,
            BI.AGGREGATE_BY
          FROM
            BASIS_INFO BI,
            TIMED_EVENTS_PER_SNAPSHOT TE  
          WHERE
            TE.EVENT_NAME = BI.EVENT AND
            ( BI.EXCLUDE_WEEKENDS = ' ' OR 
              TO_CHAR(TE.BEGIN_INTERVAL_TIME, 'D') NOT IN (7, 1) ) AND
            ( BI.EXCLUDE_ZERO_LINES = ' ' OR 
              TE.TOTAL_WAITS > 0 OR 
              TE.TIME_WAITED_MICRO > 0 )
        )
        GROUP BY
          BEGIN_TIME,
          SNAP_ID,
          INSTANCE_NUMBER,
          EVENT_NAME
      )
    GROUP BY
      BEGIN_TIME,
      INSTANCE_NUMBER,
      EVENT_NAME
    )
  ORDER BY
    BEGIN_TIME DESC,
    INSTANCE_NUMBER
  )
)
))]]></sql>
				<binds>
					<bind id="EVENT_NAME">
						<prompt><![CDATA[EVENT_NAME]]></prompt>
						<tooltip><![CDATA[EVENT_NAME]]></tooltip>
						<value><![CDATA[log file sync]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c933d3d-014d-1000-801a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_TopTimedEvents]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL EVENT_NAME, NULL TOTAL_WAITS, NULL TIME_WAITED,
  NULL AVG_MS, NULL PERCENT, NULL ACT_SESS FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL EVENT_NAME, NULL TOTAL_WAITS, NULL TIME_WAITED,
  NULL AVG_MS, NULL PERCENT, NULL ACT_SESS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM ( 
WITH BASIS_INFO AS
( SELECT 
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    RTT_MICRO,
    NUM_RECORDS,
    MIN_AVG_DIRECT_PATH_TIME_MS,
    CONSIDER_TIMEOUTS,
    EXCLUDE_SYSTEM,
    EXCLUDE_ADMINISTRATIVE,
    AGGREGATE_RAC_WAITS,
    TIME_UNIT,
    DECODE(TIME_UNIT, 'MS', 1, 'S', 1000, 'M', 60000, 'H', 3600000, 'D', 86400000) TIME_FACTOR
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.2011 11:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      400 RTT_MICRO,             /* replace with average round trip time in us */
      20 NUM_RECORDS,
      1 MIN_AVG_DIRECT_PATH_TIME_MS,
      'X' CONSIDER_TIMEOUTS,
      'X' EXCLUDE_SYSTEM,
      'X' EXCLUDE_ADMINISTRATIVE,
      'X' AGGREGATE_RAC_WAITS,
      'H' TIME_UNIT                     /* MS, S, M, H, D */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    MIN_SNAP_ID,
    PREV_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    GREATEST(SUM(INTERVAL_SECONDS) OVER (PARTITION BY INSTANCE_NUMBER)) TOTAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (PARTITION BY HSS2.INSTANCE_NUMBER ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER 
      ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
TOTAL_SECONDS AS
( SELECT /*+ MATERIALIZE */
    TOTAL_SECONDS
  FROM
    SNAPSHOTS
  WHERE
    ROWNUM = 1
),
TIMED_EVENTS_PER_SNAPSHOT AS
( SELECT /*+ MATERIALIZE */
    SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    EVENT_NAME,
    TOTAL_WAITS - DECODE(CONSIDER_TIMEOUTS, 'X', TOTAL_TIMEOUTS, 0) TOTAL_WAITS,
    TOTAL_TIMEOUTS,      
    GREATEST(DECODE(SUBSTR(EVENT_NAME, 1, 6), 'direct', 
      MIN_AVG_DIRECT_PATH_TIME_MS * 1000 * TOTAL_WAITS, 0),
      TIME_WAITED_MICRO) TIME_WAITED_MICRO
  FROM
  ( SELECT
      SS.SNAP_ID,
      SS.BEGIN_INTERVAL_TIME,
      SS.END_INTERVAL_TIME,       
      SS.INTERVAL_SECONDS,
      CASE 
        WHEN HSE2.WAIT_CLASS = 'Cluster' AND BI.AGGREGATE_RAC_WAITS = 'X'
      THEN 
        'RAC'
      ELSE
        HSE2.EVENT_NAME 
      END EVENT_NAME,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_WAITS - NVL(HSE1.TOTAL_WAITS, 0),
        HSE2.TOTAL_WAITS) TOTAL_WAITS,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_TIMEOUTS - NVL(HSE1.TOTAL_TIMEOUTS, 0),
        HSE2.TOTAL_TIMEOUTS) TOTAL_TIMEOUTS,
      DECODE(SS.RESTART, 'NO', HSE2.TIME_WAITED_MICRO - 
        NVL(HSE1.TIME_WAITED_MICRO, 0), HSE2.TIME_WAITED_MICRO) TIME_WAITED_MICRO,
      BI.MIN_AVG_DIRECT_PATH_TIME_MS,
      BI.CONSIDER_TIMEOUTS
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSTEM_EVENT HSE1, 
      DBA_HIST_SYSTEM_EVENT HSE2
    WHERE
      SS.DBID = HSE2.DBID AND
      HSE1.DBID (+) = HSE2.DBID AND
      SS.INSTANCE_NUMBER = HSE2.INSTANCE_NUMBER AND
      HSE1.INSTANCE_NUMBER (+) = HSE2.INSTANCE_NUMBER AND
      SS.SNAP_ID = HSE2.SNAP_ID AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      SS.SNAP_ID != SS.MIN_SNAP_ID AND
      HSE1.SNAP_ID (+) = HSE2.SNAP_ID - 1 AND
      HSE1.EVENT_NAME (+) = HSE2.EVENT_NAME AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      HSE2.WAIT_CLASS != 'Idle' AND
      ( BI.EXCLUDE_SYSTEM = ' ' OR 
        HSE2.WAIT_CLASS != 'System I/O'
      ) AND
      ( BI.EXCLUDE_ADMINISTRATIVE = ' ' OR 
        ( HSE2.WAIT_CLASS != 'Administrative' AND
          HSE2.EVENT_NAME NOT IN ( 'ARCH wait on SENDREQ', 'LNS wait on SENDREQ' ) 
        )
      )
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INTERVAL_SECONDS,
        'CPU' EVENT_NAME,
        NULL TOTAL_WAITS,
        NULL TOTAL_TIMEOUTS,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0) , 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYS_TIME_MODEL HSY1,  
        DBA_HIST_SYS_TIME_MODEL HSY2
      WHERE
        HSY1.DBID (+) = HSY2.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        HSY2.STAT_NAME = 'DB CPU' 
    )
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INTERVAL_SECONDS,
        'NETWORK' EVENT_NAME,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE -
          NVL(HSY1.VALUE, 0), HSY2.VALUE) TOTAL_WAITS,
        0 TOTAL_TIMEOUTS,
        BI.RTT_MICRO * DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0), 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2
      WHERE
        SS.DBID = HSY2.DBID AND
        HSY1.DBID (+) = HSY2.DBID AND
        SS.INSTANCE_NUMBER = HSY2.INSTANCE_NUMBER AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        SS.SNAP_ID = HSY2.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        HSY2.STAT_NAME = 'user calls'                 
    )
  )
)
SELECT
  'BEGIN:    ' || TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss')  EVENT_NAME,
  NULL TOTAL_WAITS,
  NULL TIME_WAITED,
  NULL AVG_MS,
  NULL PERCENT,
  NULL ACTIVE_SESSIONS
FROM 
  SNAPSHOTS
WHERE
  SNAP_ID != MIN_SNAP_ID
UNION ALL
( SELECT 
    'END:      ' || TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') EVENT_NAME,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED,
    NULL AVG_MS,
    NULL PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    SNAPSHOTS
)
UNION ALL
( SELECT 
    'INSTANCE: ' || DECODE(INSTANCE_NUMBER, -2, 'ALL', TO_CHAR(INSTANCE_NUMBER)) EVENT_NAME,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED,
    NULL AVG_MS,
    NULL PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    NULL EVENT_NAME,
    NULL TOTAL_WAITS,
    NULL TIME_WAITED,
    NULL AVG_MS,
    NULL PERCENT,
    NULL ACTIVE_SESSIONS
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    EVENT_NAME,
    TOTAL_WAITS,
    TIME_WAITED,
    AVG_MS,
    PERCENT,
    ACTIVE_SESSIONS
  FROM
  ( SELECT
      EVENT_NAME,
      TO_CHAR(TOTAL_WAITS, 999999999990) TOTAL_WAITS,
      LPAD(TO_CHAR(ROUND(TIME_WAITED_MS / TIME_FACTOR)) || ' ' || LOWER(TIME_UNIT), 17) TIME_WAITED,
      TO_CHAR(AVG_WAIT_MS, 9999990.99) AVG_MS,
      TO_CHAR(RATIO_TO_REPORT(TIME_WAITED_MS) OVER () * 100, 990.99) PERCENT,
      TO_CHAR(ACTIVE_SESSIONS, 999990.99) ACTIVE_SESSIONS,
      NUM_RECORDS
    FROM
    ( SELECT
        MIN(BEGIN_INTERVAL_TIME) BEGIN_INTERVAL_TIME,
        MAX(END_INTERVAL_TIME) END_INTERVAL_TIME,
        EVENT_NAME,
        SUM(TOTAL_WAITS) TOTAL_WAITS,
        SUM(TIME_WAITED_MICRO) / 1000 TIME_WAITED_MS,
        DECODE(SUM(TOTAL_WAITS), 0, 0, SUM(TIME_WAITED_MICRO) / SUM(TOTAL_WAITS) /
          1000) AVG_WAIT_MS,
        DECODE(TS.TOTAL_SECONDS, 0, 0, SUM(TIME_WAITED_MICRO) / 
          1000000 / TS.TOTAL_SECONDS) ACTIVE_SESSIONS,
        BI.NUM_RECORDS,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.TIME_UNIT,
        BI.TIME_FACTOR
      FROM
        BASIS_INFO BI,
        TOTAL_SECONDS TS,
        TIMED_EVENTS_PER_SNAPSHOT E
      GROUP BY
        E.EVENT_NAME,
        BI.NUM_RECORDS,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS,
        BI.TIME_UNIT,
        BI.TIME_FACTOR,
        TS.TOTAL_SECONDS
    )
    ORDER BY 
      TIME_WAITED_MS DESC
  )
  WHERE (NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS)
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c954c54-014d-1000-801b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[TimedEvents_TopTimedEventsPerAWRInterval]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL INST, NULL ACT_SESS, 
  NULL EVENT_1, NULL SESS_1, NULL "%_1", NULL AVG_MS_1, NULL WAITS_1,
  NULL EVENT_2, NULL SESS_2, NULL "%_2", NULL AVG_MS_2, NULL WAITS_2,
  NULL EVENT_3, NULL SESS_3, NULL "%_3", NULL AVG_MS_3, NULL WAITS_3,
  NULL EVENT_4, NULL SESS_4, NULL "%_4", NULL AVG_MS_4, NULL WAITS_4,
  NULL EVENT_5, NULL SESS_5, NULL "%_5", NULL AVG_MS_5, NULL WAITS_5
FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL BEGIN_TIME, NULL INST, NULL ACT_SESS, 
  NULL EVENT_1, NULL SESS_1, NULL "%_1", NULL AVG_MS_1, NULL WAITS_1,
  NULL EVENT_2, NULL SESS_2, NULL "%_2", NULL AVG_MS_2, NULL WAITS_2,
  NULL EVENT_3, NULL SESS_3, NULL "%_3", NULL AVG_MS_3, NULL WAITS_3,
  NULL EVENT_4, NULL SESS_4, NULL "%_4", NULL AVG_MS_4, NULL WAITS_4,
  NULL EVENT_5, NULL SESS_5, NULL "%_5", NULL AVG_MS_5, NULL WAITS_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    RTT_MICRO,
    MIN_AVG_DIRECT_PATH_TIME_MS,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY,
    CONSIDER_TIMEOUTS,
    EXCLUDE_WEEKENDS,
    EXCLUDE_SYSTEM,
    EXCLUDE_ADMINISTRATIVE,
    MIN_TIME_WAITED_S
  FROM
  ( SELECT
      -1 DBID,
      -3 INSTANCE_NUMBER,          /* -1: current instance, -2: all instances aggregated, -3: all instances individually */
      TO_DATE('01.01.1900 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      400 RTT_MICRO,
      'SNAPSHOT' AGGREGATE_BY,    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
      1 MIN_AVG_DIRECT_PATH_TIME_MS,
      'X' CONSIDER_TIMEOUTS,
      ' ' EXCLUDE_WEEKENDS,
      'X' EXCLUDE_SYSTEM,
      'X' EXCLUDE_ADMINISTRATIVE,
      600 MIN_TIME_WAITED_S
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    PREV_SNAP_ID,
    MIN_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        BI.INSTANCE_NUMBER = -3 OR
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER
      ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
TIMED_EVENTS_PER_SNAPSHOT AS
( SELECT /*+ MATERIALIZE */
    SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INSTANCE_NUMBER,
    INTERVAL_SECONDS,
    EVENT_NAME,
    TOTAL_WAITS - DECODE(CONSIDER_TIMEOUTS, 'X', TOTAL_TIMEOUTS, 0) TOTAL_WAITS,
    TOTAL_TIMEOUTS,      
    GREATEST(DECODE(SUBSTR(EVENT_NAME, 1, 6), 'direct', 
      MIN_AVG_DIRECT_PATH_TIME_MS * 1000 * TOTAL_WAITS, 0),
      TIME_WAITED_MICRO) TIME_WAITED_MICRO
  FROM
  ( SELECT
      SS.SNAP_ID,
      SS.BEGIN_INTERVAL_TIME,
      SS.END_INTERVAL_TIME,       
      SS.INSTANCE_NUMBER,
      SS.INTERVAL_SECONDS,
      HSE2.EVENT_NAME,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_WAITS - NVL(HSE1.TOTAL_WAITS, 0),
        HSE2.TOTAL_WAITS) TOTAL_WAITS,
      DECODE(SS.RESTART, 'NO', HSE2.TOTAL_TIMEOUTS - NVL(HSE1.TOTAL_TIMEOUTS, 0),
        HSE2.TOTAL_TIMEOUTS) TOTAL_TIMEOUTS,
      DECODE(SS.RESTART, 'NO', HSE2.TIME_WAITED_MICRO - 
        NVL(HSE1.TIME_WAITED_MICRO, 0), HSE2.TIME_WAITED_MICRO) TIME_WAITED_MICRO,
      BI.MIN_AVG_DIRECT_PATH_TIME_MS,
      BI.CONSIDER_TIMEOUTS
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSTEM_EVENT HSE1, 
      DBA_HIST_SYSTEM_EVENT HSE2
    WHERE
      SS.DBID = HSE2.DBID AND
      HSE1.DBID (+) = HSE2.DBID AND
      SS.INSTANCE_NUMBER = HSE2.INSTANCE_NUMBER AND
      HSE1.INSTANCE_NUMBER (+) = HSE2.INSTANCE_NUMBER AND
      SS.SNAP_ID = HSE2.SNAP_ID AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      SS.SNAP_ID != SS.MIN_SNAP_ID AND
      HSE1.SNAP_ID (+) = HSE2.SNAP_ID - 1 AND
      HSE1.EVENT_NAME (+) = HSE2.EVENT_NAME AND
      SS.PREV_SNAP_ID IS NOT NULL AND
      HSE2.WAIT_CLASS != 'Idle' AND
      HSE2.TIME_WAITED_MICRO >= 1000000 * BI.MIN_TIME_WAITED_S AND
      ( BI.EXCLUDE_SYSTEM = ' ' OR 
        HSE2.WAIT_CLASS != 'System I/O'
      ) AND
      ( BI.EXCLUDE_ADMINISTRATIVE = ' ' OR 
        ( HSE2.WAIT_CLASS != 'Administrative' AND
          HSE2.EVENT_NAME NOT IN ( 'ARCH wait on SENDREQ', 'LNS wait on SENDREQ' ) 
        )
      )
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INSTANCE_NUMBER,
        SS.INTERVAL_SECONDS,
        'CPU' EVENT_NAME,
        NULL TOTAL_WAITS,
        NULL TOTAL_TIMEOUTS,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0) , 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYS_TIME_MODEL HSY1,  
        DBA_HIST_SYS_TIME_MODEL HSY2
      WHERE
        HSY1.DBID (+) = HSY2.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        HSY2.STAT_NAME = 'DB CPU' 
    )
    UNION ALL
    ( SELECT 
        SS.SNAP_ID,
        SS.BEGIN_INTERVAL_TIME,
        SS.END_INTERVAL_TIME,
        SS.INSTANCE_NUMBER,
        SS.INTERVAL_SECONDS,
        'NETWORK' EVENT_NAME,
        DECODE(SS.RESTART, 'NO', HSY2.VALUE -
          NVL(HSY1.VALUE, 0), HSY2.VALUE) TOTAL_WAITS,
        0 TOTAL_TIMEOUTS,
          BI.RTT_MICRO * DECODE(SS.RESTART, 'NO', HSY2.VALUE - NVL(HSY1.VALUE, 0), 
          HSY2.VALUE) TIME_WAITED_MICRO,
        BI.MIN_AVG_DIRECT_PATH_TIME_MS,
        BI.CONSIDER_TIMEOUTS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2
      WHERE
        SS.DBID = HSY2.DBID AND
        HSY1.DBID (+) = HSY2.DBID AND
        SS.INSTANCE_NUMBER = HSY2.INSTANCE_NUMBER AND
        HSY1.INSTANCE_NUMBER (+) = HSY2.INSTANCE_NUMBER AND
        SS.SNAP_ID = HSY2.SNAP_ID AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        SS.SNAP_ID != SS.MIN_SNAP_ID AND
        HSY1.SNAP_ID (+) = HSY2.SNAP_ID - 1 AND
        HSY1.STAT_NAME (+) = HSY2.STAT_NAME AND
        SS.PREV_SNAP_ID IS NOT NULL AND
        HSY2.STAT_NAME = 'user calls'                 
    )
  )
)
SELECT
  'BEGIN TIME: ' || TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
  NULL INST,
  NULL ACT_SESS,
  NULL EVENT_1,
  NULL SESS_1,
  NULL "%_1",
  NULL AVG_MS_1,
  NULL WAITS_1,
  NULL EVENT_2,
  NULL SESS_2,
  NULL "%_2",
  NULL AVG_MS_2,
  NULL WAITS_2,
  NULL EVENT_3,
  NULL SESS_3,
  NULL "%_3",
  NULL AVG_MS_3,
  NULL WAITS_3,
  NULL EVENT_4,
  NULL SESS_4,
  NULL "%_4",
  NULL AVG_MS_4,
  NULL WAITS_4,
  NULL EVENT_5,
  NULL SESS_5,
  NULL "%_5",
  NULL AVG_MS_5,
  NULL WAITS_5
FROM 
  SNAPSHOTS
WHERE
  SNAP_ID != MIN_SNAP_ID
UNION ALL
( SELECT
    'END TIME:   ' || TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    NULL INST,
    NULL ACT_SESS,
    NULL EVENT_1,
    NULL SESS_1,
    NULL "%_1",
    NULL AVG_MS_1,
    NULL WAITS_1,
    NULL EVENT_2,
    NULL SESS_2,
    NULL "%_2",
    NULL AVG_MS_2,
    NULL WAITS_2,
    NULL EVENT_3,
    NULL SESS_3,
    NULL "%_3",
    NULL AVG_MS_3,
    NULL WAITS_3,
    NULL EVENT_4,
    NULL SESS_4,
    NULL "%_4",
    NULL AVG_MS_4,
    NULL WAITS_4,
    NULL EVENT_5,
    NULL SESS_5,
    NULL "%_5",
    NULL AVG_MS_5,
    NULL WAITS_5  
  FROM
    SNAPSHOTS
)
UNION ALL
( SELECT
    'AGGREGATED BY: ' || AGGREGATE_BY  BEGIN_TIME,
    NULL INST,
    NULL ACT_SESS,
    NULL EVENT_1,
    NULL SESS_1,
    NULL "%_1",
    NULL AVG_MS_1,
    NULL WAITS_1,
    NULL EVENT_2,
    NULL SESS_2,
    NULL "%_2",
    NULL AVG_MS_2,
    NULL WAITS_2,
    NULL EVENT_3,
    NULL SESS_3,
    NULL "%_3",
    NULL AVG_MS_3,
    NULL WAITS_3,
    NULL EVENT_4,
    NULL SESS_4,
    NULL "%_4",
    NULL AVG_MS_4,
    NULL WAITS_4,
    NULL EVENT_5,
    NULL SESS_5,
    NULL "%_5",
    NULL AVG_MS_5,
    NULL WAITS_5  
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'WEEKENDS EXCLUDED: ' || DECODE(EXCLUDE_WEEKENDS, 'X', 'YES', 'NO') BEGIN_TIME,
    NULL INST,
    NULL ACT_SESS,
    NULL EVENT_1,
    NULL SESS_1,
    NULL "%_1",
    NULL AVG_MS_1,
    NULL WAITS_1,
    NULL EVENT_2,
    NULL SESS_2,
    NULL "%_2",
    NULL AVG_MS_2,
    NULL WAITS_2,
    NULL EVENT_3,
    NULL SESS_3,
    NULL "%_3",
    NULL AVG_MS_3,
    NULL WAITS_3,
    NULL EVENT_4,
    NULL SESS_4,
    NULL "%_4",
    NULL AVG_MS_4,
    NULL WAITS_4,
    NULL EVENT_5,
    NULL SESS_5,
    NULL "%_5",
    NULL AVG_MS_5,
    NULL WAITS_5  
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL INST,
    NULL ACT_SESS,
    NULL EVENT_1,
    NULL SESS_1,
    NULL "%_1",
    NULL AVG_MS_1,
    NULL WAITS_1,
    NULL EVENT_2,
    NULL SESS_2,
    NULL "%_2",
    NULL AVG_MS_2,
    NULL WAITS_2,
    NULL EVENT_3,
    NULL SESS_3,
    NULL "%_3",
    NULL AVG_MS_3,
    NULL WAITS_3,
    NULL EVENT_4,
    NULL SESS_4,
    NULL "%_4",
    NULL AVG_MS_4,
    NULL WAITS_4,
    NULL EVENT_5,
    NULL SESS_5,
    NULL "%_5",
    NULL AVG_MS_5,
    NULL WAITS_5  
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    BEGIN_TIME,
    INST,
    ACT_SESS,
    EVENT_1,
    SESS_1,
    "%_1",
    AVG_MS_1,
    WAITS_1,
    EVENT_2,
    SESS_2,
    "%_2",
    AVG_MS_2,
    WAITS_2,
    EVENT_3,
    SESS_3,
    "%_3",
    AVG_MS_3,
    WAITS_3,
    EVENT_4,
    SESS_4,
    "%_4",
    AVG_MS_4,
    WAITS_4,
    EVENT_5,
    SESS_5,
    "%_5",
    AVG_MS_5,
    WAITS_5
  FROM
  ( SELECT 
      BEGIN_TIME,
      DECODE(INSTANCE_NUMBER, 0, 'any', TO_CHAR(INSTANCE_NUMBER, 990)) INST,
      TO_CHAR(ACT_SESS, 9990.99) ACT_SESS,
      EVENT_1,
      TO_CHAR(SESS_1, 990.99) SESS_1,
      TO_CHAR(DECODE(ACT_SESS, 0, 0, SESS_1 / ACT_SESS * 100), 
        990) "%_1",
      TO_CHAR(AVG_MS_1, 999990.99) AVG_MS_1,
      TO_CHAR(WAITS_1, 99999999990) WAITS_1,
      EVENT_2,
      TO_CHAR(SESS_2, 990.99) SESS_2,
      TO_CHAR(DECODE(ACT_SESS, 0, 0, SESS_2 / ACT_SESS * 100), 
        990) "%_2",
      TO_CHAR(AVG_MS_2, 999990.99) AVG_MS_2,
      TO_CHAR(WAITS_2, 99999999990) WAITS_2,
      EVENT_3,
      TO_CHAR(SESS_3, 990.99) SESS_3,
      TO_CHAR(DECODE(ACT_SESS, 0, 0, SESS_3 / ACT_SESS * 100), 
        990) "%_3",
      TO_CHAR(AVG_MS_3, 999990.99) AVG_MS_3,
      TO_CHAR(WAITS_3, 9999999990) WAITS_3,
      EVENT_4,
      TO_CHAR(SESS_4, 990.99) SESS_4,
      TO_CHAR(DECODE(ACT_SESS, 0, 0, SESS_4 / ACT_SESS * 100), 
        990) "%_4",
      TO_CHAR(AVG_MS_4, 999990.99) AVG_MS_4,
      TO_CHAR(WAITS_4, 9999999990) WAITS_4,
      EVENT_5,
      TO_CHAR(SESS_5, 990.99) SESS_5,
      TO_CHAR(DECODE(ACT_SESS, 0, 0, SESS_5 / ACT_SESS * 100), 
        990) "%_5",
      TO_CHAR(AVG_MS_5, 999990.99) AVG_MS_5,
      TO_CHAR(WAITS_5, 9999999990) WAITS_5
    FROM
    ( SELECT
        BEGIN_TIME,
        INSTANCE_NUMBER,
        POSITION,
        INTERVAL_SECONDS INTERVAL_S,
        ACT_SESS,
        EVENT_NAME EVENT_1,
        SESS SESS_1,
        AVG_MS AVG_MS_1,
        TOTAL_WAITS WAITS_1,
        LEAD(EVENT_NAME, 1) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) EVENT_2,
        LEAD(SESS, 1) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) SESS_2,
        LEAD(AVG_MS, 1) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) AVG_MS_2,
        LEAD(TOTAL_WAITS, 1) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) WAITS_2,
        LEAD(EVENT_NAME, 2) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) EVENT_3,
        LEAD(SESS, 2) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) SESS_3,
        LEAD(AVG_MS, 2) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) AVG_MS_3,
        LEAD(TOTAL_WAITS, 2) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) WAITS_3,
        LEAD(EVENT_NAME, 3) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) EVENT_4,
        LEAD(SESS, 3) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) SESS_4,
        LEAD(AVG_MS, 3) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) AVG_MS_4,
        LEAD(TOTAL_WAITS, 3) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) WAITS_4,
        LEAD(EVENT_NAME, 4) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) EVENT_5,
        LEAD(SESS, 4) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) SESS_5,
        LEAD(AVG_MS, 4) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) AVG_MS_5,
        LEAD(TOTAL_WAITS, 4) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY POSITION) WAITS_5
      FROM
      ( SELECT
          BEGIN_TIME,
          INSTANCE_NUMBER,
          EVENT_NAME,
          SUM(SESS) OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER) ACT_SESS,
          POSITION,
          INTERVAL_SECONDS,
          SESS,
          AVG_MS,
          TOTAL_WAITS
        FROM
        ( SELECT
            BEGIN_TIME,
            INSTANCE_NUMBER,
            EVENT_NAME,
            ROW_NUMBER() OVER (PARTITION BY BEGIN_TIME, INSTANCE_NUMBER ORDER BY WAIT_TIME_MS DESC) POSITION,
            INTERVAL_SECONDS,
            DECODE(INTERVAL_SECONDS, 0, 0, WAIT_TIME_MS / 1000 / INTERVAL_SECONDS) SESS,
            DECODE(TOTAL_WAITS, 0, 0, WAIT_TIME_MS / TOTAL_WAITS) AVG_MS,
            TOTAL_WAITS
          FROM
          ( SELECT
              BEGIN_TIME,
              INSTANCE_NUMBER,
              EVENT_NAME,
              SUM(INTERVAL_SECONDS) INTERVAL_SECONDS,
              SUM(WAIT_TIME_MS) WAIT_TIME_MS,
              SUM(TOTAL_WAITS) TOTAL_WAITS
            FROM
            ( SELECT
                BEGIN_TIME, 
                INSTANCE_NUMBER,
                MAX(INTERVAL_SECONDS) INTERVAL_SECONDS,
                EVENT_NAME,
                SUM(WAIT_TIME_MS) WAIT_TIME_MS,
                SUM(TOTAL_WAITS) TOTAL_WAITS
              FROM
              ( SELECT
                  TE.SNAP_ID,
                  MIN(TO_CHAR(BEGIN_INTERVAL_TIME, BI.AGGREGATE_BY)) OVER (PARTITION BY TE.SNAP_ID) BEGIN_TIME,
                  DECODE(BI.INSTANCE_NUMBER, -2, 0, TE.INSTANCE_NUMBER) INSTANCE_NUMBER,
                  TE.INTERVAL_SECONDS,
                  TE.EVENT_NAME,
                  TE.TIME_WAITED_MICRO / 1000 WAIT_TIME_MS,
                  TE.TOTAL_WAITS,
                  BI.AGGREGATE_BY
                FROM
                  BASIS_INFO BI,
                  TIMED_EVENTS_PER_SNAPSHOT TE
                WHERE
                ( BI.EXCLUDE_WEEKENDS = ' ' OR 
                  TO_CHAR(TE.BEGIN_INTERVAL_TIME, 'D') NOT IN (7, 1) )
              )
              GROUP BY
                BEGIN_TIME,
                SNAP_ID,
                INSTANCE_NUMBER,
                EVENT_NAME
            )
            GROUP BY
              BEGIN_TIME,
              INSTANCE_NUMBER,
              EVENT_NAME
          )
        )
      )
      WHERE
        POSITION <= 10
    )
    WHERE 
      POSITION = 1
    ORDER BY
      BEGIN_TIME DESC,
      DECODE(INSTANCE_NUMBER, 0, 'any', TO_CHAR(INSTANCE_NUMBER, 990)) 
  )
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[ASH]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2c9934a3-014d-1000-801c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_Aggregation]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL MIN_SAMPLE_TIME, NULL MAX_SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL SQL_TYPE, 
  NULL PLAN_HASH, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL EVENT, NULL OBJECT_NAME, 
  NULL OCCURRENCES, NULL SESSIONS, NULL PERCENT FROM DUAL WHERE 1 = 0 
UNION ALL (
SELECT NULL MIN_SAMPLE_TIME, NULL MAX_SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL SQL_TYPE, 
  NULL PLAN_HASH, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL EVENT, NULL OBJECT_NAME, 
  NULL OCCURRENCES, NULL SESSIONS, NULL PERCENT FROM DUAL WHERE 1 = 0 
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    XID,
    P1,
    EVENT,
    SESSION_ID,
    ONLY_PARALLEL,
    NUM_RECORDS,
    AGGREGATE_BY,
    DATA_SOURCE,
    MIN_PERCENT_THRESHOLD
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('01.01.1000 14:27:44', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 14:37:26', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:SQL_TYPE,'%') SQL_TYPE,
      -1 PLAN_HASH,
      NVL(:PROGRAM,'%') PROGRAM,
      NVL(:CLIENT_ID,'%') CLIENT_ID,
      NVL(:EVENT,'%') EVENT,
      -1 SESSION_ID,
      '%' XID,
      -1 P1,
      ' ' ONLY_PARALLEL,
      30 NUM_RECORDS,
      0.5 MIN_PERCENT_THRESHOLD,
      'EVENT OBJECT' AGGREGATE_BY,  /* 'XID SQL_ID SQL_TYPE EVENT SID OBJECT INSTANCE PLAN_HASH PROGRAM CLIENT_ID P1' or subset */
      'AWR' DATA_SOURCE            /* CURRENT, AWR */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME,
    SUM(TO_CHAR(LEAST(HSS.END_INTERVAL_TIME, BI.END_TIME), 'SSSSS') -
      TO_CHAR(GREATEST(HSS.BEGIN_INTERVAL_TIME, BI.BEGIN_TIME), 'SSSSS') +
      86400 * (TO_CHAR(LEAST(HSS.END_INTERVAL_TIME, BI.END_TIME), 'J') - 
               TO_CHAR(GREATEST(HSS.BEGIN_INTERVAL_TIME, BI.BEGIN_TIME), 'J')))
      SECONDS
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
TOTAL_SECONDS AS
( SELECT
    MAX(SECONDS) SECONDS
  FROM
  ( SELECT
      SECONDS
    FROM
      BASIS_INFO BI,
      SNAPSHOTS
    WHERE
      BI.DATA_SOURCE = 'AWR'
    UNION ALL
    ( SELECT
        ( TO_DATE(TO_CHAR(LEAST(MIN(BI.END_TIME), MAX(ASH.SAMPLE_TIME)), 
            'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') -
          TO_DATE(TO_CHAR(GREATEST(MIN(BI.BEGIN_TIME), MIN(ASH.SAMPLE_TIME)), 
            'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') ) *
        86400 SECONDS
      FROM
        BASIS_INFO BI,
        GV$ACTIVE_SESSION_HISTORY ASH
      WHERE
        BI.DATA_SOURCE = 'CURRENT' AND
        ( BI.INSTANCE_NUMBER = -2 OR
          BI.INSTANCE_NUMBER = ASH.INST_ID )
    )
  )
  WHERE
    SECONDS IS NOT NULL
),
ASH_DISTRIBUTION AS
( SELECT
    MIN(SAMPLE_TIME) MIN_SAMPLE_TIME,
    MAX(SAMPLE_TIME) MAX_SAMPLE_TIME,
    INSTANCE_NUMBER,
    SID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    EVENT,
    P1,
    XID,
    OBJECT_NAME,
    COUNT(*) OCCURRENCES
  FROM
  ( SELECT DISTINCT
      INSTANCE_NUMBER,
      SID,
      SQL_ID,
      TO_CHAR(RAWTOHEX(XID)) XID,
      SQL_TYPE,
      PLAN_HASH,
      PROGRAM,
      CLIENT_ID,
      SAMPLE_TIME,
      DECODE(SESSION_STATE,
        'WAITING', EVENT || DECODE(SUBSTR(EVENT, 1, 5),
        'enq: ', ' (' || TO_CHAR(BITAND(P1, 65535)) || ' / ' ||
        TO_CHAR(DECODE(BITAND(P1, 65535), 
          1, 'Null', 
          2, 'Sub-Share',
          3, 'Sub-Exclusive', 
          4, 'Share', 
          5, 'Share/Sub-Exclusive',
          6, 'Exclusive', 'Other')) || ')' ), 'CPU') EVENT,
      P1,
      WAIT_CLASS,
      CASE 
        WHEN EVENT = 'direct path read temp' OR
             EVENT = 'direct path write temp' OR
             EVENT = 'Data file init write'
          THEN
            'n/a'
        WHEN WAIT_CLASS = 'Application' OR
             WAIT_CLASS = 'Cluster' OR
             WAIT_CLASS = 'User I/O'
          THEN 
            NVL(OBJECT_NAME, DECODE(CURRENT_OBJ#, 
              -1, 'Header / Rollback / ANALYZE', 
               0, 'Undo Data', 
              SEGSTAT_OBJECT_NAME || ' (previous)'))
        ELSE
          'n/a' 
        END OBJECT_NAME,
      DECODE(WAIT_CLASS, 'User I/O', P3, 0) BLOCKS_ACCESSED,
      BI_SQL_TYPE
    FROM
    ( SELECT
        ASH.INSTANCE_NUMBER,
        ASH.SESSION_ID SID,
        ASH.SQL_ID,
        ASH.XID,
        ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.SAMPLE_TIME,
        ASH.SESSION_STATE,
        ASH.EVENT,
        ASH.P1,
        ASH.P3,
        ASH.WAIT_CLASS,
        ASH.CURRENT_OBJ#,
        A.NAME SQL_TYPE,
        O.OBJECT_NAME,
        SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
        BI.SQL_TYPE BI_SQL_TYPE
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        AUDIT_ACTIONS A,
        DBA_OBJECTS O,
        DBA_HIST_SEG_STAT_OBJ SSO
      WHERE
        SS.DBID = ASH.DBID AND
        ASH.DBID = SSO.DBID (+) AND
        SS.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER AND
        ( BI.BEGIN_SNAP_ID = -1 OR ASH.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
        ( BI.END_SNAP_ID = -1 OR ASH.SNAP_ID <= BI.END_SNAP_ID ) AND
        ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
        ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
        ASH.SQL_OPCODE = A.ACTION (+) AND
        ( ASH.SQL_ID IS NULL AND BI.SQL_ID = '%' OR 
          ASH.SQL_ID LIKE BI.SQL_ID ) AND
        ( BI.SQL_TYPE = '%' OR A.NAME = BI.SQL_TYPE ) AND
        ( BI.PLAN_HASH = -1 OR 
          NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
        ( ASH.PROGRAM IS NULL AND BI.PROGRAM = '%' OR
          ASH.PROGRAM LIKE BI.PROGRAM ) AND
        ( ASH.CLIENT_ID IS NULL AND BI.CLIENT_ID = '%' OR
          ASH.CLIENT_ID LIKE BI.CLIENT_ID ) AND
        ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
        ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
        ( BI.P1 = -1 OR ASH.P1 = BI.P1 ) AND
        DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
        ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
        BI.DATA_SOURCE = 'AWR'
      UNION
      ( SELECT
          ASH.INST_ID INSTANCE_NUMBER,
          ASH.SESSION_ID SID,
          ASH.SQL_ID,
          ASH.XID,
          ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
          ASH.PROGRAM,
          ASH.CLIENT_ID,
          ASH.SAMPLE_TIME,
          ASH.SESSION_STATE,
          ASH.EVENT,
          ASH.P1,
          ASH.P3,
          ASH.WAIT_CLASS,
          ASH.CURRENT_OBJ#,
          A.NAME SQL_TYPE,
          O.OBJECT_NAME,
          SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
          BI.SQL_TYPE BI_SQL_TYPE
        FROM
          BASIS_INFO BI,
          GV$ACTIVE_SESSION_HISTORY ASH,
          AUDIT_ACTIONS A,
          DBA_OBJECTS O,
          DBA_HIST_SEG_STAT_OBJ SSO
        WHERE
          (BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID) AND
          ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
          ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
          ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
          ASH.SQL_OPCODE = A.ACTION (+) AND
          ( ASH.SQL_ID IS NULL AND BI.SQL_ID = '%' OR 
            ASH.SQL_ID LIKE BI.SQL_ID ) AND
          ( BI.SQL_TYPE = '%' OR A.NAME = BI.SQL_TYPE ) AND
          ( BI.PLAN_HASH = -1 OR 
            NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
          ( ASH.PROGRAM IS NULL AND BI.PROGRAM = '%' OR
            ASH.PROGRAM LIKE BI.PROGRAM ) AND
          ( ASH.CLIENT_ID IS NULL AND BI.CLIENT_ID = '%' OR
            ASH.CLIENT_ID LIKE BI.CLIENT_ID ) AND
          ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
          ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
          DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
          ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
          BI.DATA_SOURCE = 'CURRENT'
      )
    )
  )
  GROUP BY
    SID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    EVENT,
    P1,
    XID,
    OBJECT_NAME,
    INSTANCE_NUMBER
)
SELECT
  MIN_SAMPLE_TIME,
  MAX_SAMPLE_TIME,
  INST_ID INST,
  SID,
  SQL_ID,
  SQL_TYPE,
  PLAN_HASH,
  PROGRAM,
  CLIENT_ID,
  XID,
  P1,
  EVENT,
  OBJECT_NAME,
  OCCURRENCES,
  SESSIONS,
  PERCENT
FROM
( SELECT
    TO_CHAR(MIN(MIN_SAMPLE_TIME), 'dd.mm.yyyy hh24:mi:ss') MIN_SAMPLE_TIME,
    TO_CHAR(MAX(MAX_SAMPLE_TIME), 'dd.mm.yyyy hh24:mi:ss') MAX_SAMPLE_TIME,
    INST_ID,
    SID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    XID,
    EVENT,
    P1,
    OBJECT_NAME,
    TO_CHAR(SUM(OCCURRENCES), 9999999990) OCCURRENCES,
    TO_CHAR(SUM(OCCURRENCES) * DECODE(DATA_SOURCE, 'AWR', 10, 1) / SECONDS, 
      9990.99)  SESSIONS, 
    TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 990.99) PERCENT,
    NUM_RECORDS,
    MIN_PERCENT_THRESHOLD
  FROM
  ( SELECT
      ASH.MIN_SAMPLE_TIME,
      ASH.MAX_SAMPLE_TIME,
      DECODE(BI.INSTANCE_NUMBER, -2, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'INSTANCE'), 
        0, ' any', TO_CHAR(ASH.INSTANCE_NUMBER, 990)), 'any') INST_ID,
      DECODE(BI.SESSION_ID, -1,  
        DECODE(INSTR(BI.AGGREGATE_BY, 'SID'), 0, 'any', TO_CHAR(ASH.SID, 99990)),
        TO_CHAR(ASH.SID, 99990)) SID,
      DECODE(INSTR(BI.SQL_ID, '%'), 0, ASH.SQL_ID, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_ID'), 0, 'any', ASH.SQL_ID)) SQL_ID,
      DECODE(INSTR(BI.SQL_TYPE, '%'), 0, ASH.SQL_TYPE, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_TYPE'), 0, 'any', ASH.SQL_TYPE)) SQL_TYPE,
      DECODE(BI.PLAN_HASH, -1, DECODE(INSTR(BI.AGGREGATE_BY, 
        'PLAN_HASH'), 0, 'any', TO_CHAR(ASH.PLAN_HASH)), TO_CHAR(ASH.PLAN_HASH)) PLAN_HASH,
      DECODE(INSTR(BI.PROGRAM, '%'), 0, TO_CHAR(ASH.PROGRAM), 
        DECODE(INSTR(BI.AGGREGATE_BY, 'PROGRAM'), 0, 'any', TO_CHAR(ASH.PROGRAM))) PROGRAM,
      DECODE(INSTR(BI.CLIENT_ID, '%'), 0, TO_CHAR(ASH.CLIENT_ID), 
        DECODE(INSTR(BI.AGGREGATE_BY, 'CLIENT_ID'), 0, 'any', TO_CHAR(ASH.CLIENT_ID))) CLIENT_ID,
      DECODE(INSTR(BI.EVENT, '%'), 0, ASH.EVENT, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'EVENT'), 0, 'any', ASH.EVENT)) EVENT,
      DECODE(INSTR(BI.AGGREGATE_BY, 'P1'), 0, 'any', ASH.P1) P1,
      DECODE(INSTR(BI.AGGREGATE_BY, 'OBJECT'), 0, 'any', OBJECT_NAME) OBJECT_NAME,
      DECODE(INSTR(BI.XID, '%'), 0, ASH.XID, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'XID'), 0, 'any', ASH.XID)) XID,
      ASH.OCCURRENCES,
      TS.SECONDS,
      BI.DATA_SOURCE,
      BI.NUM_RECORDS,
      BI.MIN_PERCENT_THRESHOLD
    FROM
      BASIS_INFO BI,
      TOTAL_SECONDS TS,
      ASH_DISTRIBUTION ASH
  )
  GROUP BY
    INST_ID,
    SID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    XID,
    EVENT,
    P1,
    OBJECT_NAME,
    DATA_SOURCE,
    SECONDS,
    NUM_RECORDS,
    MIN_PERCENT_THRESHOLD
  ORDER BY
    OCCURRENCES DESC
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS ) AND
  ( MIN_PERCENT_THRESHOLD = -1 OR PERCENT >= MIN_PERCENT_THRESHOLD )
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_TYPE">
						<prompt><![CDATA[SQL_TYPE]]></prompt>
						<tooltip><![CDATA[SQL_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PROGRAM">
						<prompt><![CDATA[PROGRAM]]></prompt>
						<tooltip><![CDATA[PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CLIENT_ID">
						<prompt><![CDATA[CLIENT_ID]]></prompt>
						<tooltip><![CDATA[CLIENT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2c9dce60-014d-1000-801d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_Aggregation_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE') */
  /* 11g: - PLAN_ID
          - SQL_EXEC_ID
          - TOP_LEVEL_SQL_ID
          - Activity information (HARD_PARSE, SOFT_PARSE, SQL_EXECUTION, ...) */
  NULL MIN_SAMPLE_TIME, NULL MAX_SAMPLE_TIME, NULL INST, NULL SESSION_TYPE, NULL SID, 
  NULL SQL_ID, NULL TOP_LEVEL_SQL_ID, NULL SQL_EXEC_ID, NULL PLAN_ID, NULL SQL_TYPE, 
  NULL PLAN_HASH, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL EVENT, NULL OBJECT_NAME, 
  NULL ACTIVITY, NULL OCCURRENCES, NULL SESSIONS, NULL PERCENT FROM DUAL WHERE 1 = 0 
UNION ALL (
SELECT   
  NULL MIN_SAMPLE_TIME, NULL MAX_SAMPLE_TIME, NULL INST, NULL SESSION_TYPE, NULL SID, 
  NULL SQL_ID, NULL TOP_LEVEL_SQL_ID, NULL SQL_EXEC_ID, NULL PLAN_ID, NULL SQL_TYPE, 
  NULL PLAN_HASH, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL EVENT, NULL OBJECT_NAME, 
  NULL ACTIVITY, NULL OCCURRENCES, NULL SESSIONS, NULL PERCENT FROM DUAL WHERE 1 = 0 
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    TOP_LEVEL_SQL_ID,
    SQL_EXEC_ID,
    SQL_TYPE,
    PLAN_HASH,
    PLAN_ID,
    PROGRAM,
    CLIENT_ID,
    XID,
    P1,
    EVENT,
    OBJECT_NAME,
    SESSION_ID,
    SESSION_TYPE,
    ACTIVITY,
    ONLY_PARALLEL,
    NUM_RECORDS,
    AGGREGATE_BY,
    DATA_SOURCE,
    ORDER_BY,
    MIN_PERCENT_THRESHOLD
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('01.01.1000 04:57:54', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 08:53:44', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      -1 SESSION_ID,
      '%' SESSION_TYPE,           /* FOREGROUND, BACKGROUND */
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:TOP_LEVEL_SQL_ID,'%') TOP_LEVEL_SQL_ID,
      -1 SQL_EXEC_ID,
      NVL(:SQL_TYPE,'%') SQL_TYPE,
      -1 PLAN_HASH,
      -1 PLAN_ID,
      NVL(:PROGRAM,'%') PROGRAM,
      NVL(:CLIENT_ID,'%') CLIENT_ID,
      NVL(:EVENT,'%') EVENT,
      NVL(:OBJECT_NAME,'%') OBJECT_NAME,
      NVL(:XID,'%') XID,
      -1 P1,
      '%' ACTIVITY,    /* SQL_EXEC, SOFT_PARSE, HARD_PARSE, BIND, CONN_MGMT, PLSQL_EXEC, PLSQL_RPC, PLSQL_COMP, JAVA_EXEC, CUR_CLOSE, SEQ_LOAD */
      ' ' ONLY_PARALLEL,
      30 NUM_RECORDS,
      0.5 MIN_PERCENT_THRESHOLD,
      'PLAN_ID PLAN_HASH' AGGREGATE_BY,  /* 'XID SID SQL_ID SQL_EXEC_ID SQL_TYPE EVENT OBJECT INSTANCE PLAN_HASH PLAN_ID PROGRAM CLIENT_ID ACTIVITY SESSION_TYPE P1' or subset */
      'SAMPLES' ORDER_BY,         /* TIME, SAMPLES */
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE       /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME,
    SUM(TO_CHAR(LEAST(HSS.END_INTERVAL_TIME, BI.END_TIME), 'SSSSS') -
      TO_CHAR(GREATEST(HSS.BEGIN_INTERVAL_TIME, BI.BEGIN_TIME), 'SSSSS') +
      86400 * (TO_CHAR(LEAST(HSS.END_INTERVAL_TIME, BI.END_TIME), 'J') - 
               TO_CHAR(GREATEST(HSS.BEGIN_INTERVAL_TIME, BI.BEGIN_TIME), 'J')))
      SECONDS
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
TOTAL_SECONDS AS
( SELECT /*+ MATERIALIZE */
    SECONDS
  FROM
  ( SELECT
      MAX(SECONDS) SECONDS
    FROM
      BASIS_INFO BI,
      SNAPSHOTS
    WHERE
      BI.DATA_SOURCE = 'AWR'
    UNION ALL
    ( SELECT
        ( TO_DATE(TO_CHAR(LEAST(MAX(BI.END_TIME), MAX(ASH.SAMPLE_TIME)), 
            'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') -
          TO_DATE(TO_CHAR(GREATEST(MAX(BI.BEGIN_TIME), MIN(ASH.SAMPLE_TIME)), 
            'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') ) *
        86400 SECONDS
      FROM
        BASIS_INFO BI,
        GV$ACTIVE_SESSION_HISTORY ASH
      WHERE
        BI.DATA_SOURCE = 'CURRENT' AND
        ( BI.INSTANCE_NUMBER = -2 OR
          BI.INSTANCE_NUMBER = ASH.INST_ID )
    )
  )
  WHERE
    SECONDS IS NOT NULL
),
ASH_DISTRIBUTION AS
( SELECT
    MIN(SAMPLE_TIME) MIN_SAMPLE_TIME,
    MAX(SAMPLE_TIME) MAX_SAMPLE_TIME,
    INSTANCE_NUMBER,
    SESSION_TYPE,
    SID,
    SQL_ID,
    TOP_LEVEL_SQL_ID,
    SQL_EXEC_ID,
    PLAN_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    CLIENT_ID,
    EVENT,
    P1,
    XID,
    OBJECT_NAME,
    ACTIVITY,
    COUNT(*) OCCURRENCES
  FROM
  ( SELECT DISTINCT
      INSTANCE_NUMBER,
      SESSION_TYPE,
      SID,
      SQL_ID,
      TOP_LEVEL_SQL_ID,
      SQL_EXEC_ID,
      TO_CHAR(RAWTOHEX(XID)) XID,
      SQL_TYPE,
      PLAN_HASH,
      PLAN_ID,
      PROGRAM,
      CLIENT_ID,
      SAMPLE_TIME,
      DECODE(SESSION_STATE,
        'WAITING', EVENT || DECODE(SUBSTR(EVENT, 1, 5),
        'enq: ', ' (' || TO_CHAR(BITAND(P1, 65535)) || ' / ' ||
        TO_CHAR(DECODE(BITAND(P1, 65535), 
          1, 'Null', 
          2, 'Sub-Share',
          3, 'Sub-Exclusive', 
          4, 'Share', 
          5, 'Share/Sub-Exclusive',
          6, 'Exclusive', 'Other')) || ')' ), 'CPU') EVENT,
      P1,
      WAIT_CLASS,
      CASE 
        WHEN EVENT = 'direct path read temp' OR
             EVENT = 'direct path write temp' OR
             EVENT = 'Data file init write'
          THEN
            'n/a'
        WHEN WAIT_CLASS = 'Application' OR
             WAIT_CLASS = 'Cluster' OR
             WAIT_CLASS = 'User I/O'
          THEN 
            NVL(OBJECT_NAME, DECODE(CURRENT_OBJ#, 
              -1, 'Header / Rollback / ANALYZE', 
               0, 'Undo Data', 
              SEGSTAT_OBJECT_NAME || ' (previous)'))
        ELSE
          'n/a' 
        END OBJECT_NAME,
      DECODE(WAIT_CLASS, 'User I/O', P3, 0) BLOCKS_ACCESSED,
      ACTIVITY,
      BI_SQL_TYPE
    FROM
    ( SELECT
        ASH.INSTANCE_NUMBER,
        ASH.SESSION_TYPE,
        ASH.SESSION_ID SID,
        ASH.SQL_ID,
        ASH.TOP_LEVEL_SQL_ID,
        ASH.SQL_EXEC_ID,
        ASH.XID,
        ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
        ASH.SQL_PLAN_LINE_ID PLAN_ID,
        ASH.PROGRAM,
        ASH.CLIENT_ID,
        ASH.SAMPLE_TIME,
        ASH.SESSION_STATE,
        ASH.EVENT,
        ASH.P1,
        ASH.P3,
        ASH.WAIT_CLASS,
        ASH.CURRENT_OBJ#,
        ASH.SQL_OPNAME SQL_TYPE,
        O.OBJECT_NAME,
        SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
        DECODE(ASH.IN_CONNECTION_MGMT,     'Y', 'CONN_MGMT ') ||
          DECODE(ASH.IN_PARSE,             'Y', 'SOFT_PARSE ') ||
          DECODE(ASH.IN_HARD_PARSE,        'Y', 'HARD_PARSE ') ||
          DECODE(ASH.IN_SQL_EXECUTION,     'Y', 'SQL_EXEC ') ||
          DECODE(ASH.IN_PLSQL_EXECUTION,   'Y', 'PLSQL_EXEC ') ||
          DECODE(ASH.IN_PLSQL_RPC,         'Y', 'PLSQL_RPC ') ||
          DECODE(ASH.IN_PLSQL_COMPILATION, 'Y', 'PLSQL_COMP ') ||
          DECODE(ASH.IN_JAVA_EXECUTION,    'Y', 'JAVA_EXEC ') ||
          DECODE(ASH.IN_BIND,              'Y', 'BIND ') ||
          DECODE(ASH.IN_CURSOR_CLOSE,      'Y', 'CUR_CLOSE ') ||
          DECODE(ASH.IN_SEQUENCE_LOAD,     'Y', 'SEQ_LOAD ') ACTIVITY,
        BI.SQL_TYPE BI_SQL_TYPE
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        DBA_OBJECTS O,
        DBA_HIST_SEG_STAT_OBJ SSO
      WHERE
        SS.DBID = ASH.DBID AND
        ASH.DBID = SSO.DBID (+) AND
        SS.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER AND
        ( BI.BEGIN_SNAP_ID = -1 OR ASH.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
        ( BI.END_SNAP_ID = -1 OR ASH.SNAP_ID <= BI.END_SNAP_ID ) AND
        ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
        ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
        ( ASH.SQL_ID IS NULL AND BI.SQL_ID = '%' OR 
          ASH.SQL_ID LIKE BI.SQL_ID ) AND
        ( ASH.TOP_LEVEL_SQL_ID IS NULL AND BI.TOP_LEVEL_SQL_ID = '%' OR 
          ASH.TOP_LEVEL_SQL_ID LIKE BI.TOP_LEVEL_SQL_ID ) AND
        ( BI.SQL_EXEC_ID = -1 OR ASH.SQL_EXEC_ID = BI.SQL_EXEC_ID ) AND
        ( BI.SQL_TYPE = '%' OR ASH.SQL_OPNAME = BI.SQL_TYPE ) AND
        ( BI.PLAN_HASH = -1 OR 
          NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
        ( ASH.PROGRAM IS NULL AND BI.PROGRAM = '%' OR
          ASH.PROGRAM LIKE BI.PROGRAM ) AND
        ( ASH.CLIENT_ID IS NULL AND BI.CLIENT_ID = '%' OR
          ASH.CLIENT_ID LIKE BI.CLIENT_ID ) AND
        ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
        ( ASH.SESSION_TYPE IS NULL OR ASH.SESSION_TYPE LIKE BI.SESSION_TYPE ) AND
        ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
        ( BI.P1 = -1 OR ASH.P1 = BI.P1 ) AND
        DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
        ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
        BI.DATA_SOURCE = 'AWR'
      UNION
      ( SELECT
          ASH.INST_ID INSTANCE_NUMBER,
          ASH.SESSION_TYPE,
          ASH.SESSION_ID SID,
          ASH.SQL_ID,
          ASH.TOP_LEVEL_SQL_ID,
          ASH.SQL_EXEC_ID,
          ASH.XID,
          ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
          ASH.SQL_PLAN_LINE_ID PLAN_ID,
          ASH.PROGRAM,
          ASH.CLIENT_ID,
          ASH.SAMPLE_TIME,
          ASH.SESSION_STATE,
          ASH.EVENT,
          ASH.P1,
          ASH.P3,
          ASH.WAIT_CLASS,
          ASH.CURRENT_OBJ#,
          ASH.SQL_OPNAME SQL_TYPE,
          O.OBJECT_NAME,
          SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
          DECODE(ASH.IN_CONNECTION_MGMT,     'Y', 'CONN_MGMT ') ||
            DECODE(ASH.IN_PARSE,             'Y', 'SOFT_PARSE ') ||
            DECODE(ASH.IN_HARD_PARSE,        'Y', 'HARD_PARSE ') ||
            DECODE(ASH.IN_SQL_EXECUTION,     'Y', 'SQL_EXEC ') ||
            DECODE(ASH.IN_PLSQL_EXECUTION,   'Y', 'PLSQL_EXEC ') ||
            DECODE(ASH.IN_PLSQL_RPC,         'Y', 'PLSQL_RPC ') ||
            DECODE(ASH.IN_PLSQL_COMPILATION, 'Y', 'PLSQL_COMP ') ||
            DECODE(ASH.IN_JAVA_EXECUTION,    'Y', 'JAVA_EXEC ') ||
            DECODE(ASH.IN_BIND,              'Y', 'BIND ') ||
            DECODE(ASH.IN_CURSOR_CLOSE,      'Y', 'CUR_CLOSE ') ||
            DECODE(ASH.IN_SEQUENCE_LOAD,     'Y', 'SEQ_LOAD ') ACTIVITY,
          BI.SQL_TYPE BI_SQL_TYPE
        FROM
          BASIS_INFO BI,
          GV$ACTIVE_SESSION_HISTORY ASH,
          DBA_OBJECTS O,
          DBA_HIST_SEG_STAT_OBJ SSO
        WHERE
          ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
          ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
          ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
          ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
          ( ASH.SQL_ID IS NULL AND BI.SQL_ID = '%' OR 
            ASH.SQL_ID LIKE BI.SQL_ID ) AND
          ( ASH.TOP_LEVEL_SQL_ID IS NULL AND BI.TOP_LEVEL_SQL_ID = '%' OR 
            ASH.TOP_LEVEL_SQL_ID LIKE BI.TOP_LEVEL_SQL_ID ) AND
          ( BI.SQL_EXEC_ID = -1 OR ASH.SQL_EXEC_ID = BI.SQL_EXEC_ID ) AND
          ( BI.SQL_TYPE = '%' OR ASH.SQL_OPNAME = BI.SQL_TYPE ) AND
          ( BI.PLAN_HASH = -1 OR  
            NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
          ( BI.PLAN_ID = -1 OR 
            NVL(ASH.SQL_PLAN_LINE_ID, 0) = BI.PLAN_ID ) AND
          ( ASH.PROGRAM IS NULL AND BI.PROGRAM = '%' OR
            ASH.PROGRAM LIKE BI.PROGRAM ) AND
          ( ASH.CLIENT_ID IS NULL AND BI.CLIENT_ID = '%' OR
            ASH.CLIENT_ID LIKE BI.CLIENT_ID ) AND
          ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
          ( ASH.SESSION_TYPE IS NULL OR ASH.SESSION_TYPE LIKE BI.SESSION_TYPE ) AND
          ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
          DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
          ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
          BI.DATA_SOURCE = 'CURRENT'
      )
    )
  ) ,
  ( SELECT OBJECT_NAME BI_OBJECT_NAME FROM BASIS_INFO )
  WHERE
    ( BI_OBJECT_NAME = '%' OR OBJECT_NAME LIKE BI_OBJECT_NAME )
  GROUP BY
    SID,
    SESSION_TYPE,
    SQL_ID,
    TOP_LEVEL_SQL_ID,
    SQL_EXEC_ID,
    SQL_TYPE,
    PLAN_HASH,
    PLAN_ID,
    PROGRAM,
    CLIENT_ID,
    EVENT,
    P1,
    XID,
    OBJECT_NAME,
    INSTANCE_NUMBER,
    ACTIVITY
)
SELECT
  MIN_SAMPLE_TIME,
  MAX_SAMPLE_TIME,
  INST_ID INST,
  SESSION_TYPE,
  SID,
  SQL_ID,
  TOP_LEVEL_SQL_ID,
  SQL_EXEC_ID,
  PLAN_ID,
  SQL_TYPE,
  PLAN_HASH,
  PROGRAM,
  CLIENT_ID,
  XID,
  P1,
  EVENT,
  OBJECT_NAME,
  ACTIVITY,
  OCCURRENCES,
  SESSIONS,
  PERCENT
FROM
( SELECT
    TO_CHAR(MIN(MIN_SAMPLE_TIME), 'dd.mm.yyyy hh24:mi:ss') MIN_SAMPLE_TIME,
    TO_CHAR(MAX(MAX_SAMPLE_TIME), 'dd.mm.yyyy hh24:mi:ss') MAX_SAMPLE_TIME,
    INST_ID,
    SID,
    SESSION_TYPE,
    SQL_ID,
    TOP_LEVEL_SQL_ID,
    SQL_EXEC_ID,
    SQL_TYPE,
    PLAN_HASH,
    PLAN_ID,
    PROGRAM,
    CLIENT_ID,
    XID,
    EVENT,
    P1,
    OBJECT_NAME,
    ACTIVITY,
    TO_CHAR(SUM(OCCURRENCES), 9999999990) OCCURRENCES,
    TO_CHAR(SUM(OCCURRENCES) * DECODE(DATA_SOURCE, 'AWR', 10, 1) / SECONDS, 
      9990.99)  SESSIONS, 
    TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 990.99) PERCENT,
    NUM_RECORDS,
    MIN_PERCENT_THRESHOLD
  FROM
  ( SELECT
      ASH.MIN_SAMPLE_TIME,
      ASH.MAX_SAMPLE_TIME,
      DECODE(BI.INSTANCE_NUMBER, -2, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'INSTANCE'), 
        0, ' any', TO_CHAR(ASH.INSTANCE_NUMBER, 990)), TO_CHAR(ASH.INSTANCE_NUMBER, 990)) INST_ID,
      DECODE(BI.SESSION_ID, -1,  
        DECODE(INSTR(BI.AGGREGATE_BY, 'SID'), 0, 'any', TO_CHAR(ASH.SID, 9990)),
        TO_CHAR(ASH.SID, 9990)) SID,
      DECODE(INSTR(BI.SESSION_TYPE, '%'), 0, ASH.SESSION_TYPE, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'SESSION_TYPE'), 
        0, 'any', ASH.SESSION_TYPE)) SESSION_TYPE,    
      DECODE(INSTR(BI.SQL_ID, '%'), 0, ASH.SQL_ID, DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_ID'), 
        0, 'any', ASH.SQL_ID)) SQL_ID,
      DECODE(BI.TOP_LEVEL_SQL_ID, '%', 'any', ASH.TOP_LEVEL_SQL_ID) TOP_LEVEL_SQL_ID,
      DECODE(BI.SQL_EXEC_ID, -1,  
        DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_EXEC_ID'), 0, 'any', ASH.SQL_EXEC_ID),
        ASH.SQL_EXEC_ID) SQL_EXEC_ID,
      DECODE(INSTR(BI.SQL_TYPE, '%'), 0, ASH.SQL_TYPE, DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_TYPE'), 
        0, 'any', ASH.SQL_TYPE)) SQL_TYPE,
      DECODE(BI.PLAN_HASH, -1, DECODE(INSTR(BI.AGGREGATE_BY, 
        'PLAN_HASH'), 0, 'any', TO_CHAR(ASH.PLAN_HASH)), TO_CHAR(ASH.PLAN_HASH)) PLAN_HASH,
      DECODE(BI.PLAN_ID, -1,  
        DECODE(INSTR(BI.AGGREGATE_BY, 'PLAN_ID'), 0, 'any', TO_CHAR(ASH.PLAN_ID, 999990)),
        TO_CHAR(ASH.PLAN_ID, 9990)) PLAN_ID,
      DECODE(INSTR(BI.PROGRAM, '%'), 0, TO_CHAR(ASH.PROGRAM), DECODE(INSTR(BI.AGGREGATE_BY, 
        'PROGRAM'), 0, 'any', TO_CHAR(ASH.PROGRAM))) PROGRAM,
      DECODE(INSTR(BI.CLIENT_ID, '%'), 0, TO_CHAR(ASH.CLIENT_ID), DECODE(INSTR(BI.AGGREGATE_BY, 
        'CLIENT_ID'), 0, 'any', TO_CHAR(ASH.CLIENT_ID))) CLIENT_ID,
      DECODE(INSTR(BI.EVENT, '%'), 0, ASH.EVENT, DECODE(INSTR(BI.AGGREGATE_BY, 
        'EVENT'), 0, 'any', ASH.EVENT)) EVENT,
      DECODE(INSTR(BI.AGGREGATE_BY, 'P1'), 0, 'any', ASH.P1) P1,
      DECODE(INSTR(BI.OBJECT_NAME, '%'), 0, ASH.OBJECT_NAME, DECODE(INSTR(BI.AGGREGATE_BY, 
        'OBJECT'), 0, 'any', ASH.OBJECT_NAME)) OBJECT_NAME,
      DECODE(INSTR(BI.XID, '%'), 0, ASH.XID, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'XID'), 0, 'any', ASH.XID)) XID,
      DECODE(INSTR(BI.ACTIVITY, '%'), 0, ASH.ACTIVITY, 
        DECODE(INSTR(BI.AGGREGATE_BY, 'ACTIVITY'), 0, 'any', ASH.ACTIVITY)) ACTIVITY,
      ASH.OCCURRENCES,
      TS.SECONDS,
      BI.DATA_SOURCE,
      BI.NUM_RECORDS,
      BI.MIN_PERCENT_THRESHOLD,
      BI.ORDER_BY
    FROM
      BASIS_INFO BI,
      TOTAL_SECONDS TS,
      ASH_DISTRIBUTION ASH
  )
  GROUP BY
    INST_ID,
    SID,
    SESSION_TYPE,
    SQL_ID,
    TOP_LEVEL_SQL_ID,
    SQL_EXEC_ID,
    SQL_TYPE,
    PLAN_HASH,
    PLAN_ID,
    PROGRAM,
    CLIENT_ID,
    XID,
    EVENT,
    P1,
    OBJECT_NAME,
    ACTIVITY,
    DATA_SOURCE,
    SECONDS,
    NUM_RECORDS,
    MIN_PERCENT_THRESHOLD,
    ORDER_BY
  ORDER BY
    DECODE(ORDER_BY, 'SAMPLES', OCCURRENCES) DESC,
    DECODE(ORDER_BY, 'TIME', MIN_SAMPLE_TIME)
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS ) AND
  ( MIN_PERCENT_THRESHOLD = -1 OR PERCENT >= MIN_PERCENT_THRESHOLD )
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TOP_LEVEL_SQL_ID">
						<prompt><![CDATA[TOP_LEVEL_SQL_ID]]></prompt>
						<tooltip><![CDATA[TOP_LEVEL_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_TYPE">
						<prompt><![CDATA[SQL_TYPE]]></prompt>
						<tooltip><![CDATA[SQL_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PROGRAM">
						<prompt><![CDATA[PROGRAM]]></prompt>
						<tooltip><![CDATA[PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CLIENT_ID">
						<prompt><![CDATA[CLIENT_ID]]></prompt>
						<tooltip><![CDATA[CLIENT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="OBJECT_NAME">
						<prompt><![CDATA[OBJECT_NAME]]></prompt>
						<tooltip><![CDATA[OBJECT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="XID">
						<prompt><![CDATA[XID]]></prompt>
						<tooltip><![CDATA[XID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2ca15237-014d-1000-801e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_AggregationPerTimeSlice]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL OCC_TOTAL, NULL ACT_SESS, NULL FIGURE_1, 
  NULL OCC_1, NULL PCT_1, NULL SESS_1, NULL FIGURE_2,
  NULL OCC_2, NULL PCT_2, NULL SESS_2, NULL FIGURE_3, NULL OCC_3, 
  NULL PCT_3, NULL SESS_3, NULL FIGURE_4, NULL OCC4,
  NULL PCT_4, NULL SESS_4, NULL FIGURE_5, NULL OCC_5, NULL PCT_5, 
  NULL SESS_5 FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL OCC_TOTAL, NULL ACT_SESS, NULL FIGURE_1, 
  NULL OCC_1, NULL PCT_1, NULL SESS_1, NULL FIGURE_2,
  NULL OCC_2, NULL PCT_2, NULL SESS_2, NULL FIGURE_3, NULL OCC_3, 
  NULL PCT_3, NULL SESS_3, NULL FIGURE_4, NULL OCC4,
  NULL PCT_4, NULL SESS_4, NULL FIGURE_5, NULL OCC_5, NULL PCT_5, 
  NULL SESS_5 FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */  
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    SQL_TYPE,
    EVENT,
    OBJECT_NAME,
    SESSION_ID,
    XID,
    PROGRAM,
    TIME_SLICE_S,
    ONLY_PARALLEL,
    DECODE(DATA_SOURCE, 'CURRENT', 1, ASH_SAMPLE_INTERVAL_S) ASH_SAMPLE_INTERVAL_S,
    AGGREGATE_BY,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,              /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 10:00:00', 
        'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 11:00:00', 
        'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,            /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:SQL_TYPE,'%') SQL_TYPE,
      NVL(:EVENT,'%') EVENT,
      NVL(:OBJECT_NAME,'%') OBJECT_NAME,
      -1 SESSION_ID,
      '%' XID,
      '%' PROGRAM,
      NVL(:TIME_SLICE_S,3600)  TIME_SLICE_S,
      ' ' ONLY_PARALLEL,
      10  ASH_SAMPLE_INTERVAL_S,   /* Change required if ASH history is sampled not every 10 seconds */  
      'SQL_TYPE' AGGREGATE_BY,     /* SQL_ID, EVENT, SID, OBJECT, SQL_TYPE, WAIT_CLASS, PROGRAM, MODULE, USER, CLIENT_ID, XID, PLAN_HASH or INSTANCE */
      NVL(:DATA_SOURCE,'AWR') DATA_SOURCE         /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    TO_DATE(TO_CHAR(MIN(HSS.BEGIN_INTERVAL_TIME), 
      'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    TO_DATE(TO_CHAR(MAX(HSS.END_INTERVAL_TIME), 
      'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_DATE
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR 
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
ASH_DISTRIBUTION AS
( SELECT 
    TRUNC((SAMPLE_DATE - BEGIN_DATE) * 86400 / TIME_SLICE_S) TIME_SLICE, 
    INSTANCE_NUMBER,
    SID,
    SQL_ID,
    SQL_TYPE,
    PLAN_HASH,
    PROGRAM,
    MODULE,
    EVENT,
    XID,
    OBJECT_NAME,
    WAIT_CLASS,
    CLIENT_ID,
    USER_NAME,
    COUNT(*) OCCURRENCES
  FROM
  ( SELECT DISTINCT
      INSTANCE_NUMBER,
      SID,
      SQL_ID,
      TO_CHAR(RAWTOHEX(XID)) XID,
      NVL(SQL_TYPE, 'n/a') SQL_TYPE,
      NVL(CLIENT_ID, 'n/a') CLIENT_ID,
      PLAN_HASH,
      PROGRAM,
      MODULE,
      SAMPLE_TIME,
      DECODE(SESSION_STATE,
        'WAITING', EVENT || DECODE(SUBSTR(EVENT, 1, 5),
        'enq: ', ' (' || TO_CHAR(BITAND(P1, 65535)) || ' / ' ||
        TO_CHAR(DECODE(BITAND(P1, 65535), 
          1, 'Null', 
          2, 'Sub-Share',
          3, 'Sub-Exclusive', 
          4, 'Share', 
          5, 'Share/Sub-Exclusive',
          6, 'Exclusive', 'Other')) || ')' ), 'CPU') EVENT,
      WAIT_CLASS,
      CASE 
        WHEN EVENT = 'direct path read temp' OR
             EVENT = 'direct path write temp' OR
             EVENT = 'Data file init write'
          THEN
            'n/a'
        WHEN WAIT_CLASS = 'Application' OR
             WAIT_CLASS = 'Cluster' OR
             WAIT_CLASS = 'User I/O'
          THEN 
            NVL(OBJECT_NAME, DECODE(CURRENT_OBJ#, 
              -1, 'Header / Rollback / ANALYZE', 
               0, 'Undo Data', 
              SEGSTAT_OBJECT_NAME || ' (previous)'))
        ELSE
          'n/a' 
        END OBJECT_NAME,
      DECODE(WAIT_CLASS, 'User I/O', P3, 0) BLOCKS_ACCESSED,
      BI_SQL_TYPE,
      TO_DATE(TO_CHAR(SAMPLE_TIME, 'dd.mm.yyyy hh24:mi:ss'), 
        'dd.mm.yyyy hh24:mi:ss') SAMPLE_DATE,
      USER_NAME,
      BEGIN_DATE,
      TIME_SLICE_S,
      BI_OBJECT_NAME
    FROM
    ( SELECT
        ASH.INSTANCE_NUMBER,
        ASH.SESSION_ID SID,
        ASH.SQL_ID,
        TO_CHAR(RAWTOHEX(ASH.XID)) XID,
        ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
        ASH.PROGRAM,
        ASH.MODULE,
        ASH.SAMPLE_TIME,
        ASH.SESSION_STATE,
        ASH.EVENT,
        ASH.P1,
        ASH.P3,
        ASH.WAIT_CLASS,
        ASH.CURRENT_OBJ#,
        ASH.CLIENT_ID,
        A.NAME SQL_TYPE,
        O.OBJECT_NAME,
        SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
        BI.SQL_TYPE BI_SQL_TYPE,
        BI.BEGIN_DATE,
        BI.TIME_SLICE_S,
        BI.OBJECT_NAME BI_OBJECT_NAME,
        U.USERNAME USER_NAME
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        AUDIT_ACTIONS A,
        DBA_OBJECTS O,
        DBA_HIST_SEG_STAT_OBJ SSO,
        DBA_USERS U
      WHERE
        SS.DBID = ASH.DBID AND
        ASH.DBID = SSO.DBID (+) AND
        ASH.USER_ID = U.USER_ID (+) AND
        SS.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER AND
        ( BI.BEGIN_SNAP_ID = -1 OR ASH.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
        ( BI.END_SNAP_ID = -1 OR ASH.SNAP_ID <= BI.END_SNAP_ID ) AND
        ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
        ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
        ASH.SQL_OPCODE = A.ACTION (+) AND
        ( BI.SQL_ID = '%' OR ASH.SQL_ID LIKE BI.SQL_ID ) AND
        ( BI.SQL_TYPE = '%' OR A.NAME = BI.SQL_TYPE ) AND
        ( BI.PROGRAM = '%' OR ASH.PROGRAM LIKE BI.PROGRAM ) AND
        ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
        ( BI.XID = '%' OR TO_CHAR(RAWTOHEX(ASH.XID)) LIKE BI.XID ) AND
        DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
        ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
        BI.DATA_SOURCE = 'AWR'
      UNION
      ( SELECT
          ASH.INST_ID INSTANCE_NUMBER,
          ASH.SESSION_ID SID,
          ASH.SQL_ID,
          TO_CHAR(RAWTOHEX(ASH.XID)) XID,
          ASH.SQL_PLAN_HASH_VALUE PLAN_HASH,
          ASH.PROGRAM,
          ASH.MODULE,
          ASH.SAMPLE_TIME,
          ASH.SESSION_STATE,
          ASH.EVENT,
          ASH.P1,
          ASH.P3,
          ASH.WAIT_CLASS,
          ASH.CURRENT_OBJ#,
          ASH.CLIENT_ID,
          A.NAME SQL_TYPE,
          O.OBJECT_NAME,
          SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
          BI.SQL_TYPE BI_SQL_TYPE,
          BI.BEGIN_DATE,
          BI.TIME_SLICE_S,
          BI.OBJECT_NAME BI_OBJECT_NAME,
          U.USERNAME USER_NAME
        FROM
          BASIS_INFO BI,
          GV$ACTIVE_SESSION_HISTORY ASH,
          AUDIT_ACTIONS A,
          DBA_OBJECTS O,
          DBA_HIST_SEG_STAT_OBJ SSO,
          DBA_USERS U
        WHERE
          ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
          ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
          ASH.USER_ID = U.USER_ID (+) AND
          ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
          ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
          ASH.SQL_OPCODE = A.ACTION (+) AND
          ( BI.SQL_ID = '%' OR ASH.SQL_ID LIKE BI.SQL_ID ) AND
          ( BI.SQL_TYPE = '%' OR A.NAME = BI.SQL_TYPE ) AND
          ( BI.PROGRAM = '%' OR ASH.PROGRAM LIKE BI.PROGRAM ) AND
          ( BI.SESSION_ID = -1 OR ASH.SESSION_ID = BI.SESSION_ID ) AND
          ( BI.XID = '%' OR TO_CHAR(RAWTOHEX(ASH.XID)) LIKE BI.XID ) AND
          DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') LIKE BI.EVENT AND
          ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL ) AND
          BI.DATA_SOURCE = 'CURRENT'
      )
    )
  )
  WHERE
    NVL(OBJECT_NAME, ' ') LIKE BI_OBJECT_NAME
  GROUP BY
    SID,
    XID,
    SQL_ID,
    PLAN_HASH,
    EVENT,
    OBJECT_NAME,
    INSTANCE_NUMBER,
    SQL_TYPE,
    WAIT_CLASS,
    PROGRAM,
    MODULE,
    CLIENT_ID,
    USER_NAME,
    TRUNC((SAMPLE_DATE - BEGIN_DATE) * 86400 / TIME_SLICE_S)
)
SELECT
  'SQL_ID:' BEGIN_TIME,
  SQL_ID OCC_TOTAL,
  NULL ACT_SESS,
  NULL FIGURE_1,
  NULL OCC_1,
  NULL PCT_1,
  NULL SESS_1,
  NULL FIGURE_2,
  NULL OCC_2,
  NULL PCT_2,
  NULL SESS_2,
  NULL FIGURE_3,
  NULL OCC_3,
  NULL PCT_3,
  NULL SESS_3,
  NULL FIGURE_4,
  NULL OCC_4,
  NULL PCT_4,
  NULL SESS_4,
  NULL FIGURE_5,
  NULL OCC_5,
  NULL PCT_5,
  NULL SESS_5
FROM
  BASIS_INFO
WHERE
  SQL_ID != '%'
UNION ALL
( SELECT
    'Aggregated by:' BEGIN_TIME,
    AGGREGATE_BY OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'Event:' BEGIN_TIME,
    EVENT OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
  WHERE
    EVENT != '%'
)
UNION ALL
( SELECT
    'Object:' BEGIN_TIME,
    OBJECT_NAME OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
  WHERE
    OBJECT_NAME != '%'
)
UNION ALL
( SELECT
    'Session:' BEGIN_TIME,
    TO_CHAR(SESSION_ID) OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
  WHERE 
    SESSION_ID != -1
)
UNION ALL
( SELECT
    'Instance:' BEGIN_TIME,
    TO_CHAR(DECODE(INSTANCE_NUMBER, -2, 'ALL', INSTANCE_NUMBER)) OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
  WHERE
    INSTANCE_NUMBER != -1
)
UNION ALL
( SELECT
    'Program:' BEGIN_TIME,
    PROGRAM OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
  WHERE
    PROGRAM != '%'
)
UNION ALL
( SELECT
    'Time slice:' BEGIN_TIME,
    TO_CHAR(TIME_SLICE_S) || ' s' OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL OCC_TOTAL,
    NULL ACT_SESS,
    NULL FIGURE_1,
    NULL OCC_1,
    NULL PCT_1,
    NULL SESS_1,
    NULL FIGURE_2,
    NULL OCC_2,
    NULL PCT_2,
    NULL SESS_2,
    NULL FIGURE_3,
    NULL OCC_3,
    NULL PCT_3,
    NULL SESS_3,
    NULL FIGURE_4,
    NULL OCC_4,
    NULL PCT_4,
    NULL SESS_4,
    NULL FIGURE_5,
    NULL OCC_5,
    NULL PCT_5,
    NULL SESS_5
  FROM
    DUAL
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      BEGIN_TIME,
      LPAD(TO_CHAR(OCC_TOTAL, 999999999990), GREATEST(13, LENGTH(EVENT))) OCC_TOTAL,
      TO_CHAR(OCC_TOTAL * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 9990.99) ACT_SESS,
      DECODE(AGGREGATE_BY, 'SID', TO_CHAR(FIGURE_1), 
        'INSTANCE', TO_CHAR(FIGURE_1), FIGURE_1) FIGURE_1,
      TO_CHAR(OCC_1, 99990) OCC_1,
      TO_CHAR(PCT_1, 9990) PCT_1,
      TO_CHAR(OCC_1 * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 990.99) SESS_1,
      DECODE(AGGREGATE_BY, 'SID', TO_CHAR(FIGURE_2), 
        'INSTANCE', TO_CHAR(FIGURE_2), FIGURE_2) FIGURE_2,
      TO_CHAR(OCC_2, 99990) OCC_2,
      TO_CHAR(PCT_2, 9990) PCT_2,
      TO_CHAR(OCC_2 * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 990.99) SESS_2,
      DECODE(AGGREGATE_BY, 'SID', TO_CHAR(FIGURE_3), 
        'INSTANCE', TO_CHAR(FIGURE_3), FIGURE_3) FIGURE_3,
      TO_CHAR(OCC_3, 99990) OCC_3,
      TO_CHAR(PCT_3, 9990) PCT_3,
      TO_CHAR(OCC_3 * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 990.99) SESS_3,
      DECODE(AGGREGATE_BY, 'SID', TO_CHAR(FIGURE_4), 
        'INSTANCE', TO_CHAR(FIGURE_4), FIGURE_4) FIGURE_4,
      TO_CHAR(OCC_4, 99990) OCC_4,
      TO_CHAR(PCT_4, 9990) PCT_4,
      TO_CHAR(OCC_4 * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 990.99) SESS_4,
      DECODE(AGGREGATE_BY, 'SID', TO_CHAR(FIGURE_5), 
        'INSTANCE', TO_CHAR(FIGURE_5), FIGURE_5) FIGURE_5,
      TO_CHAR(OCC_5, 99990) OCC_5,
      TO_CHAR(PCT_5, 9990) PCT_5,
      TO_CHAR(OCC_5 * ASH_SAMPLE_INTERVAL_S / 
        TIME_SLICE_S, 990.99) SESS_5
    FROM
    ( SELECT
        AGGREGATE_BY,
        ASH_SAMPLE_INTERVAL_S,
        TIME_SLICE_S,
        TIME_SLICE,
        BEGIN_TIME,
        SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) OCC_TOTAL,
        FIGURE FIGURE_1,
        OCCURRENCES OCC_1,
        ROUND(OCCURRENCES / SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) * 100) PCT_1,
        LEAD(FIGURE, 1) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) FIGURE_2,
        LEAD(OCCURRENCES, 1) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) OCC_2,
        DECODE(SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE), 0, 0,
          ROUND(LEAD(OCCURRENCES, 1) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) / 
          SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) * 100)) PCT_2,
        LEAD(FIGURE, 2) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) FIGURE_3,
        LEAD(OCCURRENCES, 2) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) OCC_3,
        DECODE(SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE), 0, 0,
          ROUND(LEAD(OCCURRENCES, 2) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) / 
          SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) * 100)) PCT_3,
        LEAD(FIGURE, 3) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) FIGURE_4,
        LEAD(OCCURRENCES, 3) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) OCC_4,
        DECODE(SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE), 0, 0,
          ROUND(LEAD(OCCURRENCES, 3) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) / 
          SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) * 100)) PCT_4,
        LEAD(FIGURE, 4) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) FIGURE_5,
        LEAD(OCCURRENCES, 4) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) OCC_5,
        DECODE(SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE), 0, 0,
          ROUND(LEAD(OCCURRENCES, 4) OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) / 
          SUM(OCCURRENCES) OVER (PARTITION BY TIME_SLICE) * 100)) PCT_5,
        ROW_NUMBER () OVER (PARTITION BY TIME_SLICE ORDER BY OCCURRENCES DESC) NUM,
        EVENT
      FROM
      ( SELECT
          BI.AGGREGATE_BY,
          BI.ASH_SAMPLE_INTERVAL_S,
          BI.TIME_SLICE_S,
          ASH.TIME_SLICE,
          TO_CHAR(BI.BEGIN_DATE + ASH.TIME_SLICE * BI.TIME_SLICE_S / 86400, 
            'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
          DECODE(BI.AGGREGATE_BY, 
            'SQL_ID', ASH.SQL_ID,
            'EVENT', ASH.EVENT,
            'SID', TO_CHAR(ASH.SID),
            'XID', TO_CHAR(RAWTOHEX(ASH.XID)),
            'OBJECT', ASH.OBJECT_NAME,
            'SQL_TYPE', ASH.SQL_TYPE,
            'WAIT_CLASS', ASH.WAIT_CLASS,
            'PROGRAM', ASH.PROGRAM,
            'MODULE', ASH.MODULE,
            'CLIENT_ID', ASH.CLIENT_ID,
            'USER', ASH.USER_NAME,
            'PLAN_HASH', TO_CHAR(ASH.PLAN_HASH),
            'INSTANCE', TO_CHAR(ASH.INSTANCE_NUMBER)) FIGURE,
          SUM(OCCURRENCES) OCCURRENCES,
          BI.EVENT
        FROM
          BASIS_INFO BI,
          ASH_DISTRIBUTION ASH
        GROUP BY
          BI.AGGREGATE_BY,
          BI.ASH_SAMPLE_INTERVAL_S,
          BI.BEGIN_DATE,
          BI.TIME_SLICE_S,
          ASH.TIME_SLICE,
          DECODE(BI.AGGREGATE_BY, 
            'SQL_ID', ASH.SQL_ID,
            'EVENT', ASH.EVENT,
            'SID', TO_CHAR(ASH.SID),
            'XID', TO_CHAR(RAWTOHEX(ASH.XID)),
            'OBJECT', ASH.OBJECT_NAME,
            'SQL_TYPE', ASH.SQL_TYPE,
            'WAIT_CLASS', ASH.WAIT_CLASS,
            'PROGRAM', ASH.PROGRAM,
            'MODULE', ASH.MODULE,
            'CLIENT_ID', ASH.CLIENT_ID,
            'USER', ASH.USER_NAME,
            'PLAN_HASH', TO_CHAR(ASH.PLAN_HASH),
            'INSTANCE', TO_CHAR(ASH.INSTANCE_NUMBER)),
          BI.EVENT
      )
    )
    WHERE 
      NUM = 1
    ORDER BY
      TIME_SLICE DESC
  )   
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_TYPE">
						<prompt><![CDATA[SQL_TYPE]]></prompt>
						<tooltip><![CDATA[SQL_TYPE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="OBJECT_NAME">
						<prompt><![CDATA[OBJECT_NAME]]></prompt>
						<tooltip><![CDATA[OBJECT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TIME_SLICE_S">
						<prompt><![CDATA[TIME_SLICE_S]]></prompt>
						<tooltip><![CDATA[TIME_SLICE_S]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2ca1d66f-014d-1000-801f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_Filter]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL ACTION, NULL TIME_US, NULL OBJECT_NAME, 
  NULL FILE_NAME, NULL SQL_TYPE, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL P2, NULL P3, NULL BLOCKING_SESSION,
  NULL COORDINATOR, NULL PLAN_HASH, NULL SQL_TEXT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL ACTION, NULL TIME_US, NULL OBJECT_NAME, 
  NULL FILE_NAME, NULL SQL_TYPE, NULL PROGRAM, NULL CLIENT_ID, NULL XID, NULL P1, NULL P2, NULL P3, NULL BLOCKING_SESSION,
  NULL COORDINATOR, NULL PLAN_HASH, NULL SQL_TEXT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    PLAN_HASH,
    EVENT,
    SESSION_ID,
    INCLUDE_SLAVES_FOR_SID,
    PROGRAM,
    CLIENT_ID,
    XID,
    ONLY_PARALLEL,
    MIN_TIME_WAITED_MS,
    NUM_RECORDS,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('01.01.1000 01:04:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 01:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      -1 PLAN_HASH,
      NVL(:EVENT,'%') EVENT,
      -1 SESSION_ID,   
      'X' INCLUDE_SLAVES_FOR_SID,
      '%' PROGRAM,
      '%' CLIENT_ID,
      '%' XID,
      -1 NUM_RECORDS,
      -1 MIN_TIME_WAITED_MS,
      ' ' ONLY_PARALLEL,
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) 
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
DATAFILES AS
( SELECT
    FILE_ID,
    FILE_NAME
  FROM
    DBA_DATA_FILES
  UNION ALL
  ( SELECT
      P.VALUE + DTF.FILE_ID FILE_ID,
      DTF.FILE_NAME
    FROM
      DBA_TEMP_FILES DTF,
      V$PARAMETER P
    WHERE
      UPPER(P.NAME) = 'DB_FILES'
  )
)
SELECT DISTINCT
  TO_CHAR(SAMPLE_TIME, 'YYYY-MM-DD HH24:MI:SS') SAMPLE_TIME, 
  INSTANCE_NUMBER INST,
  SESSION_ID SID,
  SQL_ID,
  DECODE(SESSION_STATE,
    'WAITING', EVENT || DECODE(SUBSTR(EVENT, 1, 5),
    'enq: ', ' (' || TO_CHAR(BITAND(P1, 65535)) || ' / ' ||
    TO_CHAR(DECODE(BITAND(P1, 65535), 
      1, 'Null', 
      2, 'Sub-Share',
      3, 'Sub-Exclusive', 
      4, 'Share', 
      5, 'Share/Sub-Exclusive',
      6, 'Exclusive', 'Other')) || ')' ), 'CPU') ACTION,
  TO_CHAR(TIME_WAITED, 999999990) TIME_US, 
  CASE 
    WHEN EVENT = 'direct path read temp' OR
         EVENT = 'direct path write temp' OR
         EVENT = 'Data file init write'
      THEN
        'n/a'
    WHEN WAIT_CLASS = 'Application' OR
         WAIT_CLASS = 'Cluster' OR
         WAIT_CLASS = 'User I/O'
      THEN 
        NVL(OBJECT_NAME, DECODE(CURRENT_OBJ#, 
          -1, 'Header / Rollback / ANALYZE', 
           0, 'Undo Data', 
          SEGSTAT_OBJECT_NAME || ' (previous)'))
    ELSE
      'n/a' 
    END OBJECT_NAME,
  DECODE(WAIT_CLASS, 'User I/O', 
    DECODE(EVENT, 'Data file init write', 
      NULL, FILE_NAME)) FILE_NAME,
  NAME SQL_TYPE,
  PROGRAM,
  CLIENT_ID,
  TO_CHAR(RAWTOHEX(XID)) XID,
  P1,
  P2,
  P3,
  DECODE(DECODE(SESSION_STATE, 'WAITING', EVENT, 'CPU'),
    'cursor: pin S wait on X', DECODE(SIGN(P2 - 4294967295), 1, 
    P2 / 4294967296, P2 / 65536), BLOCKING_SESSION) 
    BLOCKING_SESSION,  
  QC_SESSION_ID COORDINATOR,
  SQL_PLAN_HASH_VALUE PLAN_HASH,
  TO_CHAR(SUBSTR(NVL(SQL_TEXT, NAME), 1, 400)) SQL_TEXT 
FROM
( SELECT
    ASH.SAMPLE_TIME,
    ASH.INSTANCE_NUMBER,
    ASH.SESSION_ID,
    ASH.SQL_ID,
    ASH.SESSION_STATE,
    ASH.EVENT,
    ASH.TIME_WAITED,
    ASH.WAIT_CLASS,
    O.OBJECT_NAME,
    SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
    ASH.CURRENT_OBJ#,
    DF.FILE_NAME,
    A.NAME,
    ASH.PROGRAM,
    ASH.CLIENT_ID,
    ASH.XID,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    ASH.BLOCKING_SESSION,
    ASH.QC_SESSION_ID,
    ASH.SQL_PLAN_HASH_VALUE,
    TO_CHAR(SUBSTR(S.SQL_TEXT, 1, 400)) SQL_TEXT 
  FROM
    DBA_HIST_ACTIVE_SESS_HISTORY ASH, 
    DBA_HIST_SQLTEXT S,
    DATAFILES DF,
    DBA_OBJECTS O,
    DBA_HIST_SEG_STAT_OBJ SSO,
    AUDIT_ACTIONS A,
    SNAPSHOTS SS,
    BASIS_INFO BI
  WHERE 
    SS.DBID = ASH.DBID AND
    ASH.DBID = S.DBID (+) AND
    ASH.DBID = SSO.DBID (+) AND
    ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
    NVL(ASH.SQL_OPCODE, -99) = A.ACTION (+) AND
    NVL(ASH.SQL_ID, ' ') = S.SQL_ID (+) AND
    ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
    ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
    ( BI.PLAN_HASH = -1 OR 
      NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
    NVL(ASH.EVENT, 'CPU') LIKE BI.EVENT AND
    ( BI.INSTANCE_NUMBER = -2 OR 
      BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
    ( BI.SESSION_ID = -1 OR
      BI.SESSION_ID = ASH.SESSION_ID OR
      ( BI.INCLUDE_SLAVES_FOR_SID = 'X' AND
        BI.SESSION_ID = ASH.QC_SESSION_ID 
      )
    ) AND
    ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL) AND
    NVL(ASH.PROGRAM, ' ') LIKE BI.PROGRAM AND
    NVL(ASH.CLIENT_ID, ' ') LIKE BI.CLIENT_ID AND
    ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
    ASH.P1 = DF.FILE_ID (+) AND
    ( BI.MIN_TIME_WAITED_MS = -1 OR 
      ASH.TIME_WAITED >= BI.MIN_TIME_WAITED_MS * 1000 ) AND
    ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS ) AND
    BI.DATA_SOURCE = 'AWR'
  UNION ALL
  ( SELECT
      ASH.SAMPLE_TIME,
      ASH.INST_ID INSTANCE_NUMBER,
      ASH.SESSION_ID,
      ASH.SQL_ID,
      ASH.SESSION_STATE,
      ASH.EVENT,
      ASH.TIME_WAITED,
      ASH.WAIT_CLASS,
      O.OBJECT_NAME,
      SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
      ASH.CURRENT_OBJ#,
      DF.FILE_NAME,
      A.NAME,
      ASH.PROGRAM,
      ASH.CLIENT_ID,
      ASH.XID,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      ASH.BLOCKING_SESSION,
      ASH.QC_SESSION_ID,
      ASH.SQL_PLAN_HASH_VALUE,
      S.SQL_TEXT
    FROM
      GV$ACTIVE_SESSION_HISTORY ASH, 
      GV$SQLTEXT S,
      DATAFILES DF,
      DBA_OBJECTS O,
      DBA_HIST_SEG_STAT_OBJ SSO,
      AUDIT_ACTIONS A,
      BASIS_INFO BI
    WHERE
      NVL(ASH.SQL_OPCODE, -99) = A.ACTION (+) AND
      NVL(ASH.SQL_ID, ' ') = S.SQL_ID (+) AND
      S.PIECE (+) = 0 AND
      ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
      ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
      ( BI.PLAN_HASH = -1 OR 
        NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
      NVL(ASH.EVENT, 'CPU') LIKE BI.EVENT AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
      ( BI.SESSION_ID = -1 OR
        BI.SESSION_ID = ASH.SESSION_ID OR
        ( BI.INCLUDE_SLAVES_FOR_SID = 'X' AND
          BI.SESSION_ID = ASH.QC_SESSION_ID 
        )
      ) AND
      ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL) AND
      NVL(ASH.PROGRAM, ' ') LIKE BI.PROGRAM AND
      NVL(ASH.CLIENT_ID, ' ') LIKE BI.CLIENT_ID AND
      ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
      ASH.P1 = DF.FILE_ID (+) AND
      ( BI.MIN_TIME_WAITED_MS = -1 OR 
        ASH.TIME_WAITED >= BI.MIN_TIME_WAITED_MS * 1000 ) AND
      ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS ) AND
      BI.DATA_SOURCE = 'CURRENT'
  )
)
ORDER BY 
  SAMPLE_TIME DESC,
  INST,
  SID
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[read by other session]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2caae1fb-014d-1000-8021-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_Filter_11g+]]></name>
			<description><![CDATA[				]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE') */
  /* 11g: - PLAN_ID
          - SQL_EXEC_ID
          - Direct BLOCKING_SESSION for "cursor: pin S wait on X"
          - Activity information (HARD_PARSE, SOFT_PARSE, SQL_EXECUTION, ...) 
          - PGA and TEMP information
  */
  NULL SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL XID, NULL PLAN_ID, NULL ACTION, NULL TIME_US, 
  NULL OBJECT_NAME, NULL FILE_NAME, NULL SQL_TYPE, NULL CLIENT_ID, NULL PROGRAM, NULL MODULE, NULL P1, NULL P2, NULL P3, NULL BLOCKING_SESSION,
  NULL COORDINATOR, NULL PLAN_HASH, NULL ACTIVITY, NULL PGA_MB, NULL TEMP_MB, NULL SQL_TEXT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT   
  NULL SAMPLE_TIME, NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL XID, NULL PLAN_ID, NULL ACTION, NULL TIME_US, 
  NULL OBJECT_NAME, NULL FILE_NAME, NULL SQL_TYPE, NULL CLIENT_ID, NULL PROGRAM, NULL MODULE, NULL P1, NULL P2, NULL P3, NULL BLOCKING_SESSION,
  NULL COORDINATOR, NULL PLAN_HASH, NULL ACTIVITY, NULL PGA_MB, NULL TEMP_MB, NULL SQL_TEXT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SESSION_ID,
    SQL_ID,
    SQL_EXEC_ID,
    PLAN_HASH,
    PLAN_ID, 
    EVENT,
    PROGRAM,
    CLIENT_ID,
    XID,
    MIN_PGA_MB,
    MIN_TEMP_MB,
    ONLY_PARALLEL,
    TIME_WAITED_MS,
    NUM_RECORDS,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('01.01.1000 14:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 15:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SESSION_ID,-1) SESSION_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      -1 SQL_EXEC_ID,
      -1 PLAN_HASH,
      -1 PLAN_ID,
      NVL(:EVENT,'%') EVENT,
      NVL(:XID,'%') XID,
      NVL(:PROGRAM,'%') PROGRAM,
      NVL(:CLIENT_ID,'%') CLIENT_ID,
      -1 MIN_PGA_MB,
      -1 MIN_TEMP_MB,
      -1 NUM_RECORDS,
      -1 TIME_WAITED_MS,
      ' ' ONLY_PARALLEL,
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE              /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) 
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
DATAFILES AS
( SELECT
    FILE_ID,
    FILE_NAME
  FROM
    DBA_DATA_FILES
  UNION ALL
  ( SELECT
      P.VALUE + DTF.FILE_ID FILE_ID,
      DTF.FILE_NAME
    FROM
      DBA_TEMP_FILES DTF,
      V$PARAMETER P
    WHERE
      UPPER(P.NAME) = 'DB_FILES'
  )
)
SELECT DISTINCT
  TO_CHAR(SAMPLE_TIME, 'YYYY-MM-DD HH24:MI:SS') SAMPLE_TIME, 
  TO_CHAR(INSTANCE_NUMBER, 9990) INST,
  TO_CHAR(SESSION_ID, 99990) SID,
  SQL_ID,
  SQL_EXEC_ID,
  TO_CHAR(RAWTOHEX(XID)) XID,
  TO_CHAR(SQL_PLAN_LINE_ID, 999990) PLAN_ID,
  DECODE(SESSION_STATE, 'WAITING', EVENT, 'CPU') ACTION,
  TO_CHAR(TIME_WAITED, 999999990) TIME_US, 
  CASE 
    WHEN EVENT = 'direct path read temp' OR
         EVENT = 'direct path write temp' OR
         EVENT = 'Data file init write'
      THEN
        'n/a'
    WHEN WAIT_CLASS = 'Application' OR
         WAIT_CLASS = 'Cluster' OR
         WAIT_CLASS = 'User I/O'
      THEN 
        NVL(OBJECT_NAME, DECODE(CURRENT_OBJ#, 
          -1, 'Header / Rollback / ANALYZE', 
           0, 'Undo Data', 
          SEGSTAT_OBJECT_NAME || ' (previous)'))
    ELSE
      'n/a' 
    END OBJECT_NAME,
  CASE
    WHEN EVENT = 'free buffer waits' OR
         EVENT = 'local write wait' OR
         EVENT = 'write complete waits' OR
         EVENT = 'write complete waits: flash cache' OR
         EVENT = 'buffer read retry' OR
         EVENT = 'buffer busy waits' OR
         EVENT = 'gc buffer busy acquire' OR
         EVENT = 'gc buffer busy release' OR
         EVENT = 'read by other session' OR
         EVENT = 'pi renounce write complete' OR
         EVENT = 'db file sequential read' OR
         EVENT = 'db file scattered read' OR
         EVENT = 'db file single write' OR
         EVENT = 'gc current request' OR
         EVENT = 'gc cr request' OR
         EVENT = 'gc cr disk request' OR
         EVENT = 'gc cr multi block request' OR
         EVENT = 'gc current multi block request' OR
         EVENT = 'gc block recovery request' OR
         EVENT = 'gc remaster' OR
         EVENT = 'gc domain validation' OR
         EVENT = 'gc recovery quiesce' OR
         EVENT = 'buffer exterminate' OR
         EVENT = 'cr request retry' OR
         EVENT = 'recovery buffer pinned' OR
         EVENT = 'Auto BMR completion' 
    THEN
      FILE_NAME
    ELSE
      'n/a'
    END FILE_NAME,
  NAME SQL_TYPE,
  CLIENT_ID,
  PROGRAM,
  MODULE,
  P1,
  P2,
  P3,
  BLOCKING_SESSION,  
  QC_SESSION_ID COORDINATOR,
  SQL_PLAN_HASH_VALUE PLAN_HASH,
  DECODE(IN_CONNECTION_MGMT,     'Y', 'CONN_MGMT ') ||
    DECODE(IN_PARSE,             'Y', 'SOFT_PARSE ') ||
    DECODE(IN_HARD_PARSE,        'Y', 'HARD_PARSE ') ||
    DECODE(IN_SQL_EXECUTION,     'Y', 'SQL_EXEC ') ||
    DECODE(IN_PLSQL_EXECUTION,   'Y', 'PLSQL_EXEC ') ||
    DECODE(IN_PLSQL_RPC,         'Y', 'PLSQL_RPC ') ||
    DECODE(IN_PLSQL_COMPILATION, 'Y', 'PLSQL_COMP ') ||
    DECODE(IN_JAVA_EXECUTION,    'Y', 'JAVA_EXEC ') ||
    DECODE(IN_BIND,              'Y', 'BIND ') ||
    DECODE(IN_CURSOR_CLOSE,      'Y', 'CUR_CLOSE ') ||
    DECODE(IN_SEQUENCE_LOAD,     'Y', 'SEQ_LOAD ') ACTIVITY,
  TO_CHAR(PGA_ALLOCATED / 1024 / 1024, 9990.99) PGA_MB,
  TO_CHAR(TEMP_SPACE_ALLOCATED / 1024 / 1024, 999990.99) TEMP_MB,
  TO_CHAR(SUBSTR(NVL(SQL_TEXT, NAME), 1, 400)) SQL_TEXT 
FROM
( SELECT /*+ FULL(ASH.ASH) */
    ASH.SAMPLE_TIME,
    ASH.INSTANCE_NUMBER,
    ASH.SESSION_ID,
    ASH.SQL_ID,
    ASH.SQL_EXEC_ID,
    ASH.SESSION_STATE,
    ASH.EVENT,
    ASH.TIME_WAITED,
    ASH.WAIT_CLASS,
    O.OBJECT_NAME,
    SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
    ASH.CURRENT_OBJ#,
    DF.FILE_NAME,
    ASH.SQL_OPNAME NAME,
    ASH.PROGRAM,
    ASH.MODULE,
    ASH.CLIENT_ID,
    ASH.XID,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    ASH.BLOCKING_SESSION,
    ASH.QC_SESSION_ID,
    ASH.SQL_PLAN_HASH_VALUE,
    TO_CHAR(SUBSTR(S.SQL_TEXT, 1, 400)) SQL_TEXT,
    ASH.SQL_PLAN_LINE_ID,
    ASH.IN_CONNECTION_MGMT,
    ASH.IN_PARSE,
    ASH.IN_HARD_PARSE,
    ASH.IN_SQL_EXECUTION,
    ASH.IN_PLSQL_EXECUTION,
    ASH.IN_PLSQL_RPC,
    ASH.IN_PLSQL_COMPILATION,
    ASH.IN_JAVA_EXECUTION,
    ASH.IN_BIND,
    ASH.IN_CURSOR_CLOSE,
    ASH.IN_SEQUENCE_LOAD, 
    ASH.PGA_ALLOCATED,
    ASH.TEMP_SPACE_ALLOCATED
  FROM
    DBA_HIST_ACTIVE_SESS_HISTORY ASH, 
    DBA_HIST_SQLTEXT S,
    DATAFILES DF,
    DBA_OBJECTS O,
    DBA_HIST_SEG_STAT_OBJ SSO,
    SNAPSHOTS SS,
    BASIS_INFO BI
  WHERE
    SS.DBID = ASH.DBID AND
    ASH.DBID = S.DBID (+) AND
    ASH.DBID = SSO.DBID (+) AND
    ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
    NVL(ASH.SQL_ID, ' ') = S.SQL_ID (+) AND
    ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
    ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
    ( BI.SQL_EXEC_ID = -1 OR
      BI.SQL_EXEC_ID = ASH.SQL_EXEC_ID ) AND
    ( BI.PLAN_HASH = -1 OR 
      NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
    ( BI.PLAN_ID = -1 OR 
      NVL(ASH.SQL_PLAN_LINE_ID, 0) = BI.PLAN_ID ) AND
    NVL(ASH.EVENT, 'CPU') LIKE BI.EVENT AND
    ( BI.INSTANCE_NUMBER = -2 OR 
      BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
    ( BI.SESSION_ID = -1 OR
      BI.SESSION_ID = ASH.SESSION_ID ) AND
    ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL) AND
    NVL(ASH.PROGRAM, ' ') LIKE BI.PROGRAM AND
    NVL(ASH.CLIENT_ID, ' ') LIKE BI.CLIENT_ID AND
    ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
    ( BI.MIN_PGA_MB = -1 OR
      BI.MIN_PGA_MB <= NVL(ASH.PGA_ALLOCATED, 0) / 1024 / 1024 ) AND
    ( BI.MIN_TEMP_MB = -1 OR
      BI.MIN_TEMP_MB <= NVL(ASH.TEMP_SPACE_ALLOCATED, 0) / 1024 / 1024 ) AND
    ASH.P1 = DF.FILE_ID (+) AND
    ( BI.TIME_WAITED_MS = -1 OR 
      ASH.TIME_WAITED >= BI.TIME_WAITED_MS * 1000 ) AND
    ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS ) AND
    BI.DATA_SOURCE = 'AWR'
  UNION ALL
  ( SELECT DISTINCT
      ASH.SAMPLE_TIME,
      ASH.INST_ID INSTANCE_NUMBER,
      ASH.SESSION_ID,
      ASH.SQL_ID,
      ASH.SQL_EXEC_ID,
      ASH.SESSION_STATE,
      ASH.EVENT,
      ASH.TIME_WAITED,
      ASH.WAIT_CLASS,
      O.OBJECT_NAME,
      SSO.OBJECT_NAME SEGSTAT_OBJECT_NAME,
      ASH.CURRENT_OBJ#,
      DF.FILE_NAME,
      ASH.SQL_OPNAME NAME,
      ASH.PROGRAM,
      ASH.MODULE,
      ASH.CLIENT_ID,
      ASH.XID,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      ASH.BLOCKING_SESSION,
      ASH.QC_SESSION_ID,
      ASH.SQL_PLAN_HASH_VALUE,
      S.SQL_TEXT,
      ASH.SQL_PLAN_LINE_ID,
      ASH.IN_CONNECTION_MGMT,
      ASH.IN_PARSE,
      ASH.IN_HARD_PARSE,
      ASH.IN_SQL_EXECUTION,
      ASH.IN_PLSQL_EXECUTION,
      ASH.IN_PLSQL_RPC,
      ASH.IN_PLSQL_COMPILATION,
      ASH.IN_JAVA_EXECUTION,
      ASH.IN_BIND,
      ASH.IN_CURSOR_CLOSE,
      ASH.IN_SEQUENCE_LOAD, 
      ASH.PGA_ALLOCATED,
      ASH.TEMP_SPACE_ALLOCATED
    FROM
      GV$ACTIVE_SESSION_HISTORY ASH, 
      GV$SQLTEXT S,
      DATAFILES DF,
      DBA_OBJECTS O,
      DBA_HIST_SEG_STAT_OBJ SSO,
      BASIS_INFO BI
    WHERE
      NVL(ASH.SQL_ID, ' ') = S.SQL_ID (+) AND
      S.PIECE (+) = 0 AND
      ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
      ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
      ( BI.SQL_EXEC_ID = -1 OR
        BI.SQL_EXEC_ID = ASH.SQL_EXEC_ID ) AND
      ( BI.PLAN_HASH = -1 OR 
      NVL(ASH.SQL_PLAN_HASH_VALUE, 0) = BI.PLAN_HASH ) AND
      ( BI.PLAN_ID = -1 OR 
        NVL(ASH.SQL_PLAN_LINE_ID, 0) = BI.PLAN_ID ) AND
      NVL(ASH.EVENT, 'CPU') LIKE BI.EVENT AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
      ( BI.SESSION_ID = -1 OR
        BI.SESSION_ID = ASH.SESSION_ID ) AND
      ( BI.ONLY_PARALLEL = ' ' OR ASH.QC_SESSION_ID IS NOT NULL) AND
      NVL(ASH.PROGRAM, ' ') LIKE BI.PROGRAM AND
      NVL(ASH.CLIENT_ID, ' ') LIKE BI.CLIENT_ID AND
      ( ASH.XID IS NULL AND BI.XID = '%' OR ASH.XID LIKE BI.XID ) AND
      ( BI.MIN_PGA_MB = -1 OR
        BI.MIN_PGA_MB <= NVL(ASH.PGA_ALLOCATED, 0) / 1024 / 1024 ) AND
      ( BI.MIN_TEMP_MB = -1 OR
        BI.MIN_TEMP_MB <= NVL(ASH.TEMP_SPACE_ALLOCATED, 0) / 1024 / 1024 ) AND
      ASH.P1 = DF.FILE_ID (+) AND
      ( BI.TIME_WAITED_MS = -1 OR 
        ASH.TIME_WAITED >= BI.TIME_WAITED_MS * 1000 ) AND
      ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS ) AND
      BI.DATA_SOURCE = 'CURRENT'
  )
)
ORDER BY 
  SAMPLE_TIME DESC,
  INST,
  SID
))]]></sql>
				<binds>
					<bind id="SESSION_ID">
						<prompt><![CDATA[SESSION_ID]]></prompt>
						<tooltip><![CDATA[SESSION_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[read by other session]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="XID">
						<prompt><![CDATA[XID]]></prompt>
						<tooltip><![CDATA[XID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="PROGRAM">
						<prompt><![CDATA[PROGRAM]]></prompt>
						<tooltip><![CDATA[PROGRAM]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="CLIENT_ID">
						<prompt><![CDATA[CLIENT_ID]]></prompt>
						<tooltip><![CDATA[CLIENT_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cac2d92-014d-1000-8022-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_ParallelExecutions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 00:05:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 07:50:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:DATA_SOURCE,'AWR') DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
PX_SLAVES AS 
( SELECT /*+ MATERIALIZE */ 
    ASH.SAMPLE_TIME,
    ASH.SAMPLE_ID,
    ASH.INST_ID INSTANCE_NUMBER,
    ASH.SESSION_ID,
    ASH.QC_INSTANCE_ID,
    ASH.QC_SESSION_ID,
    DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.PROGRAM,
    ASH.SQL_ID
  FROM 
    BASIS_INFO BI,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    BI.DATA_SOURCE = 'CURRENT' AND
    ASH.QC_SESSION_ID IS NOT NULL AND
    ( ASH.QC_SESSION_ID != ASH.SESSION_ID OR ASH.QC_INSTANCE_ID != ASH.INST_ID )
  UNION ALL
  ( SELECT 
      ASH.SAMPLE_TIME,
      ASH.SAMPLE_ID,
      ASH.INSTANCE_NUMBER,
      ASH.SESSION_ID, 
      ASH.QC_INSTANCE_ID,
      ASH.QC_SESSION_ID,
      DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.PROGRAM,
      ASH.SQL_ID
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      ASH.DBID = BI.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      BI.DATA_SOURCE = 'AWR' AND
      ASH.QC_SESSION_ID IS NOT NULL AND
    ( ASH.QC_SESSION_ID != ASH.SESSION_ID OR ASH.QC_INSTANCE_ID != ASH.INSTANCE_NUMBER )
  )
),
PX_COORDINATORS AS
( SELECT /*+ MATERIALIZE */
    BS.SAMPLE_TIME,
    BS.SAMPLE_ID,
    BS.QC_INSTANCE_ID INSTANCE_NUMBER,
    BS.QC_SESSION_ID SESSION_ID,
    CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INST_ID = ASH.QC_INSTANCE_ID THEN 
      NULL ELSE ASH.QC_INSTANCE_ID END QC_INSTANCE_ID,
    CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INST_ID = ASH.QC_INSTANCE_ID THEN 
      NULL ELSE ASH.QC_SESSION_ID END QC_SESSION_ID,
    DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.PROGRAM,
    ASH.SQL_ID
  FROM
    BASIS_INFO BI,
    PX_SLAVES BS,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
    BS.QC_SESSION_ID = ASH.SESSION_ID (+) AND
    BS.QC_INSTANCE_ID = ASH.INST_ID (+) AND
    BI.DATA_SOURCE = 'CURRENT'
  UNION
  ( SELECT
      BS.SAMPLE_TIME,
      BS.SAMPLE_ID,
      BS.QC_INSTANCE_ID INSTANCE_NUMBER,
      BS.QC_SESSION_ID SESSION_ID,
      CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INSTANCE_NUMBER = ASH.QC_INSTANCE_ID THEN 
        NULL ELSE ASH.QC_INSTANCE_ID END QC_INSTANCE_ID,
      CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INSTANCE_NUMBER = ASH.QC_INSTANCE_ID THEN 
        NULL ELSE ASH.QC_SESSION_ID END QC_SESSION_ID,
      DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.PROGRAM,
      ASH.SQL_ID
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      PX_SLAVES BS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
      BS.QC_SESSION_ID = ASH.SESSION_ID (+) AND
      BS.QC_INSTANCE_ID = ASH.INSTANCE_NUMBER (+) AND
      BI.DATA_SOURCE = 'AWR'
  )
),
ALL_RELEVANT_SESSIONS AS
( SELECT
    *
  FROM
    PX_SLAVES
  UNION
  ( SELECT
      *
    FROM
      PX_COORDINATORS
  )
),
RELEVANT_SAMPLE_TIMES AS
( SELECT DISTINCT
    S.SAMPLE_TIME,
    S.SAMPLE_ID
  FROM
    BASIS_INFO BI,
    ALL_RELEVANT_SESSIONS S
  WHERE
    NVL(S.SQL_ID, ' ') LIKE BI.SQL_ID 
)
SELECT
  DECODE(LAG(SAMPLE_TIME, 1) OVER (ORDER BY RN), SAMPLE_TIME, NULL, 
    TO_CHAR(SAMPLE_TIME, 'dd.mm.yyyy hh24:mi:ss')) SAMPLE_TIME,
  INST_ID INST, 
  SID, 
  PROGRAM,
  ACTION,
  SQL_ID
FROM 
( SELECT 
    S.SAMPLE_TIME,
    LPAD(' ', 2 * (LEVEL - 1)) || S.SESSION_ID SID, 
    TO_CHAR(S.INSTANCE_NUMBER, 990) INST_ID,
    S.PROGRAM,
    S.ACTION,
    S.SQL_ID,
    ROWNUM RN
  FROM
    ALL_RELEVANT_SESSIONS S,
    RELEVANT_SAMPLE_TIMES T
  WHERE
    S.SAMPLE_ID = T.SAMPLE_ID
  CONNECT BY 
    PRIOR S.SAMPLE_ID = S.SAMPLE_ID AND
    PRIOR S.INSTANCE_NUMBER = S.QC_INSTANCE_ID AND
    PRIOR S.SESSION_ID = S.QC_SESSION_ID
  START WITH
    S.QC_SESSION_ID IS NULL
) S
ORDER BY
  S.SAMPLE_TIME DESC,
  RN
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2caf73a0-014d-1000-8023-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[ASH_PGAAndTEMPAllocation_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  NULL SAMPLE_TIME, NULL TOTAL_MB, NULL SQL_ID_1, NULL MB_1, 
  NULL "%_1", NULL SQL_ID_2, NULL MB_2, NULL "%_2", NULL SQL_ID_3, 
  NULL MB_3, NULL "%_3", NULL SQL_ID_4, NULL MB_4, NULL "%_4", 
  NULL SQL_ID_5, NULL MB_5, NULL "%_5" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT   
  NULL SAMPLE_TIME, NULL TOTAL_MB, NULL SQL_ID_1, NULL MB_1, 
  NULL "%_1", NULL SQL_ID_2, NULL MB_2, NULL "%_2", NULL SQL_ID_3, 
  NULL MB_3, NULL "%_3", NULL SQL_ID_4, NULL MB_4, NULL "%_4", 
  NULL SQL_ID_5, NULL MB_5, NULL "%_5" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    AREA,
    MIN_TOTAL_SPACE_MB,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('01.01.1000 00:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('12.12.9999 10:22:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:AREA,'TEMP') AREA,                   /* PGA, TEMP */
      NVL(:MIN_TOTAL_SPACE_MB,1000) MIN_TOTAL_SPACE_MB,
      NVL(:DATA_SOURCE,'AWR') DATA_SOURCE              /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) 
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
)
SELECT
  SAMPLE_TIME,
  TOTAL_MB,
  SQL_ID_1,
  TO_CHAR(MB_1, 999990.99) MB_1,
  TO_CHAR(MB_1 / TOTAL_MB * 100, 990.99) "%_1",
  SQL_ID_2,
  TO_CHAR(MB_2, 999990.99) MB_2,
  TO_CHAR(MB_2 / TOTAL_MB * 100, 990.99) "%_2",
  SQL_ID_3,
  TO_CHAR(MB_3, 999990.99) MB_3,
  TO_CHAR(MB_3 / TOTAL_MB * 100, 990.99) "%_3",
  SQL_ID_4,
  TO_CHAR(MB_4, 999990.99) MB_4,
  TO_CHAR(MB_4 / TOTAL_MB * 100, 990.99) "%_4",
  SQL_ID_5,
  TO_CHAR(MB_5, 999990.99) MB_5,
  TO_CHAR(MB_5 / TOTAL_MB * 100, 990.99) "%_5"
FROM
( SELECT DISTINCT 
    TO_CHAR(SAMPLE_TIME, 'YYYY-MM-DD HH24:MI:SS') SAMPLE_TIME, 
    TO_CHAR(SUM(SPACE_MB) OVER (PARTITION BY SAMPLE_TIME), 99999990.99) TOTAL_MB,
    MIN_TOTAL_SPACE_MB,
    NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) SQL_ID_1,
    NTH_VALUE(SPACE_MB, 1) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) MB_1,
    NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) SQL_ID_2,
    NTH_VALUE(SPACE_MB, 2) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) MB_2,
    NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) SQL_ID_3,
    NTH_VALUE(SPACE_MB, 3) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) MB_3,
    NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) SQL_ID_4,
    NTH_VALUE(SPACE_MB, 4) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) MB_4,
    NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) SQL_ID_5,
    NTH_VALUE(SPACE_MB, 5) OVER (PARTITION BY SAMPLE_TIME ORDER BY SPACE_MB DESC 
      ROWS BETWEEN UNBOUNDED PRECEDING AND 
      UNBOUNDED FOLLOWING) MB_5
  FROM
  ( SELECT
      ASH.SAMPLE_TIME,
      ASH.SQL_ID,
      DECODE(BI.AREA, 
        'PGA', ASH.PGA_ALLOCATED,
        'TEMP', ASH.TEMP_SPACE_ALLOCATED) / 1024 / 1024 SPACE_MB,
      BI.MIN_TOTAL_SPACE_MB
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      SS.DBID = ASH.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      BI.DATA_SOURCE = 'AWR'
    UNION ALL
    ( SELECT
        ASH.SAMPLE_TIME,
        ASH.SQL_ID,
        DECODE(BI.AREA, 
          'PGA', ASH.PGA_ALLOCATED,
          'TEMP', ASH.TEMP_SPACE_ALLOCATED) / 1024 / 1024 SPACE_MB,
        BI.MIN_TOTAL_SPACE_MB
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        GV$ACTIVE_SESSION_HISTORY ASH
      WHERE
        ( BI.INSTANCE_NUMBER = -2 OR 
          BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
        ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        BI.DATA_SOURCE = 'CURRENT'
    ) 
  )
  WHERE
    SPACE_MB IS NOT NULL
  ORDER BY 
    SAMPLE_TIME DESC
)
WHERE
  TOTAL_MB >= MIN_TOTAL_SPACE_MB
))]]></sql>
				<binds>
					<bind id="AREA">
						<prompt><![CDATA[AREA]]></prompt>
						<tooltip><![CDATA[AREA]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="MIN_TOTAL_SPACE_MB">
						<prompt><![CDATA[MIN_TOTAL_SPACE_MB]]></prompt>
						<tooltip><![CDATA[MIN_TOTAL_SPACE_MB]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Data]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2cb2437f-014d-1000-8024-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Data_ClusteringFactor_CBOStatistics_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /* 11g: V$SQLSTATS_PLAN_HASH */
  NULL INDEX_NAME, NULL RECORDS_READ, NULL EXECUTIONS,
  NULL ROWS_PER_EXEC, NULL DISTINCT_KEYS, NULL TAB_BLOCKS,
  NULL IND_ROWS, NULL CLUSTERING_FACTOR FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INDEX_NAME, NULL RECORDS_READ, NULL EXECUTIONS,
  NULL ROWS_PER_EXEC, NULL DISTINCT_KEYS, NULL TAB_BLOCKS,
  NULL IND_ROWS, NULL CLUSTERING_FACTOR FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    NVL(:TABLE_NAME,'%') TABLE_NAME,
    NVL(:INFO_SOURCE,'ALL') INFO_SOURCE,    /* ALL, CURRENT, AWR */
    'RECORDS' ORDER_BY
  FROM 
    DUAL
)
SELECT
  INDEX_NAME,
  TO_CHAR(SUM(RECORDS), 99999999990) RECORDS_READ,
  TO_CHAR(SUM(EXECUTIONS), 99999999990) EXECUTIONS,
  TO_CHAR(DECODE(SUM(EXECUTIONS), 0, 0, 
    SUM(RECORDS) / SUM(EXECUTIONS)), 999999990.99) ROWS_PER_EXEC,
  TO_CHAR(DISTINCT_KEYS, 999999999990) DISTINCT_KEYS,
  TO_CHAR(BLOCKS, 999999990) TAB_BLOCKS,
  TO_CHAR(NUM_ROWS, 9999999990) IND_ROWS,
  TO_CHAR(CLUSTERING_FACTOR, 9999999999999990) CLUSTERING_FACTOR
FROM
( SELECT
    I.INDEX_NAME,
    S.SQL_ID,
    I.DISTINCT_KEYS,
    T.BLOCKS,
    I.NUM_ROWS,
    I.CLUSTERING_FACTOR,
    NVL(S.ROWS_PROCESSED, 0) RECORDS,
    NVL(S.EXECUTIONS, 0) EXECUTIONS,
    BI.ORDER_BY
  FROM
    BASIS_INFO BI,
    DBA_TABLES T,
    DBA_INDEXES I,
    V$SQL_PLAN SP,
    V$SQLSTATS_PLAN_HASH S
  WHERE
    BI.INFO_SOURCE IN ('ALL', 'CURRENT') AND
    T.OWNER LIKE BI.OWNER AND
    T.TABLE_NAME LIKE BI.TABLE_NAME AND
    I.TABLE_OWNER = T.OWNER AND
    I.TABLE_NAME = T.TABLE_NAME AND
    SP.OBJECT_OWNER (+) = I.OWNER AND
    SP.OBJECT_NAME (+) = I.INDEX_NAME AND
    SP.OBJECT_TYPE (+) LIKE 'INDEX%' AND
    S.SQL_ID (+) = SP.SQL_ID AND
    S.PLAN_HASH_VALUE (+) = SP.PLAN_HASH_VALUE
  UNION ALL
  ( SELECT
      I.INDEX_NAME,
      S.SQL_ID,
      I.DISTINCT_KEYS,
      T.BLOCKS,
      I.NUM_ROWS,
      I.CLUSTERING_FACTOR,
      NVL(S.ROWS_PROCESSED_DELTA, 0) RECORDS,
      NVL(S.EXECUTIONS_DELTA, 0) EXECUTIONS,
      BI.ORDER_BY
    FROM
      BASIS_INFO BI,
      DBA_TABLES T,
      DBA_INDEXES I,
      DBA_HIST_SQL_PLAN SP,
      DBA_HIST_SQLSTAT S
    WHERE
      BI.INFO_SOURCE IN ('ALL', 'AWR') AND
      T.OWNER LIKE BI.OWNER AND
      T.TABLE_NAME LIKE BI.TABLE_NAME AND
      I.TABLE_OWNER = T.OWNER AND
      I.TABLE_NAME = T.TABLE_NAME AND
      SP.OBJECT_OWNER (+) = I.OWNER AND
      SP.OBJECT_NAME (+) = I.INDEX_NAME AND
      SP.OBJECT_TYPE (+) LIKE 'INDEX%' AND
      S.SQL_ID (+) = SP.SQL_ID AND
      S.PLAN_HASH_VALUE (+) = SP.PLAN_HASH_VALUE
   )
)
GROUP BY 
  INDEX_NAME,
  DISTINCT_KEYS,
  NUM_ROWS,
  BLOCKS,
  CLUSTERING_FACTOR,
  ORDER_BY
ORDER BY
  DECODE(ORDER_BY,
    'RECORDS', RECORDS_READ,
    'EXECUTIONS', EXECUTIONS, 1) DESC,
  DECODE(ORDER_BY,
    'INDEX', INDEX_NAME, 1)
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INFO_SOURCE">
						<prompt><![CDATA[INFO_SOURCE]]></prompt>
						<tooltip><![CDATA[INFO_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[IO]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2cbdb549-014d-1000-8026-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[IO_RedoLogsPerHour]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL DAY, 
  NULL "00", NULL "01", NULL "02", NULL "03", NULL "04",
  NULL "05", NULL "06", NULL "07", NULL "08", NULL "09",
  NULL "10", NULL "11", NULL "12", NULL "13", NULL "14",
  NULL "15", NULL "16", NULL "17", NULL "18", NULL "19",
  NULL "20", NULL "21", NULL "22", NULL "23"
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL DAY, 
  NULL "00", NULL "01", NULL "02", NULL "03", NULL "04",
  NULL "05", NULL "06", NULL "07", NULL "08", NULL "09",
  NULL "10", NULL "11", NULL "12", NULL "13", NULL "14",
  NULL "15", NULL "16", NULL "17", NULL "18", NULL "19",
  NULL "20", NULL "21", NULL "22", NULL "23"
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    THREAD#,
    MAX_INTERVAL_TIME_S,
    BEGIN_DATE,
    END_DATE
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,             /* -1 for current instance, -2 for all instances */
      -1 THREAD#,
      60 MAX_INTERVAL_TIME_S,
      TO_DATE('01.01.1000 14:27:44', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 14:37:26', 'dd.mm.yyyy hh24:mi:ss') END_DATE
    FROM
      DUAL
  )
)
SELECT
  DAY,
  TO_CHAR(SUM(DECODE(HOUR, 0, 1, 0)), 990) "00",
  TO_CHAR(SUM(DECODE(HOUR, 1, 1, 0)), 990) "01",
  TO_CHAR(SUM(DECODE(HOUR, 2, 1, 0)), 990) "02",
  TO_CHAR(SUM(DECODE(HOUR, 3, 1, 0)), 990) "03",
  TO_CHAR(SUM(DECODE(HOUR, 4, 1, 0)), 990) "04",
  TO_CHAR(SUM(DECODE(HOUR, 5, 1, 0)), 990) "05",
  TO_CHAR(SUM(DECODE(HOUR, 6, 1, 0)), 990) "06",
  TO_CHAR(SUM(DECODE(HOUR, 7, 1, 0)), 990) "07",
  TO_CHAR(SUM(DECODE(HOUR, 8, 1, 0)), 990) "08",
  TO_CHAR(SUM(DECODE(HOUR, 9, 1, 0)), 990) "09",
  TO_CHAR(SUM(DECODE(HOUR, 10, 1, 0)), 990) "10",
  TO_CHAR(SUM(DECODE(HOUR, 11, 1, 0)), 990) "11",
  TO_CHAR(SUM(DECODE(HOUR, 12, 1, 0)), 990) "12",
  TO_CHAR(SUM(DECODE(HOUR, 13, 1, 0)), 990) "13",
  TO_CHAR(SUM(DECODE(HOUR, 14, 1, 0)), 990) "14",
  TO_CHAR(SUM(DECODE(HOUR, 15, 1, 0)), 990) "15",
  TO_CHAR(SUM(DECODE(HOUR, 16, 1, 0)), 990) "16",
  TO_CHAR(SUM(DECODE(HOUR, 17, 1, 0)), 990) "17",
  TO_CHAR(SUM(DECODE(HOUR, 18, 1, 0)), 990) "18",
  TO_CHAR(SUM(DECODE(HOUR, 19, 1, 0)), 990) "19",
  TO_CHAR(SUM(DECODE(HOUR, 20, 1, 0)), 990) "20",
  TO_CHAR(SUM(DECODE(HOUR, 21, 1, 0)), 990) "21",
  TO_CHAR(SUM(DECODE(HOUR, 22, 1, 0)), 990) "22",
  TO_CHAR(SUM(DECODE(HOUR, 23, 1, 0)), 990) "23"
FROM
( SELECT
    TO_CHAR(LH2.FIRST_TIME, 'yyyy/mm/dd') DAY,
    TO_NUMBER(TO_CHAR(LH2.FIRST_TIME, 'hh24')) HOUR,
    (LH2.FIRST_TIME - LH1.FIRST_TIME) * 86400 SECONDS,
    BI.MAX_INTERVAL_TIME_S
  FROM
    BASIS_INFO BI,
    GV$LOGHIST LH1,
    GV$LOGHIST LH2
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = LH1.INST_ID ) AND
    ( BI.THREAD# = -1 OR BI.THREAD# = LH1.THREAD# ) AND
    LH1.FIRST_TIME BETWEEN BI.BEGIN_DATE AND BI.END_DATE AND
    LH1.INST_ID = LH2.INST_ID AND
    LH1.THREAD# = LH2.THREAD# AND
    LH1.SEQUENCE# = LH2.SEQUENCE# - 1 
)
WHERE
  ( MAX_INTERVAL_TIME_S = -1 OR 
    SECONDS <= MAX_INTERVAL_TIME_S )
GROUP BY
  DAY
ORDER BY
  DAY DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cbe7c71-014d-1000-8027-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[IO_SmallLogSwitchIntervals]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST_ID, NULL THREAD, NULL TIME_INTERVAL, NULL DURATION_S FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST_ID, NULL THREAD, NULL TIME_INTERVAL, NULL DURATION_S FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    MAX_INTERVAL_TIME_S,
    NUM_RECORDS
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,             /* -2 for all instances */
      60 MAX_INTERVAL_TIME_S,
      30 NUM_RECORDS
    FROM
      DUAL
  )
)
SELECT
  TO_CHAR(INST_ID, 999990) INST_ID,
  TO_CHAR(THREAD#, 99990) THREAD,
  TIME_INTERVAL,
  TO_CHAR(DURATION_S, 999999990) DURATION_S
FROM
( SELECT
    INST_ID,
    THREAD#,
    TO_CHAR(START_TIME, 'dd.mm.yyyy hh24:mi:ss') || '-' ||
      TO_CHAR(END_TIME, 'dd.mm.yyyy hh24:mi:ss') TIME_INTERVAL,
    SECONDS DURATION_S,
    NUM_RECORDS
  FROM
  ( SELECT
      LH1.INST_ID, 
      LH1.THREAD#,
      LH1.SEQUENCE#,
      LH1.FIRST_TIME START_TIME,
      LH2.FIRST_TIME END_TIME,
      ( LH2.FIRST_TIME - LH1.FIRST_TIME ) * 86400 SECONDS,
      BI.NUM_RECORDS,
      BI.MAX_INTERVAL_TIME_S
    FROM
      BASIS_INFO BI,
      GV$LOGHIST LH1,
      GV$LOGHIST LH2,
      V$DATABASE DB
    WHERE
      ( BI.INSTANCE_NUMBER = -2 OR
        BI.INSTANCE_NUMBER = LH1.INST_ID ) AND
      LH1.INST_ID = LH2.INST_ID AND
      LH1.THREAD# = LH2.THREAD# AND
      LH1.SEQUENCE# = LH2.SEQUENCE# - 1 AND
      LH1.FIRST_TIME > DB.RESETLOGS_TIME AND
      LH2.FIRST_TIME > DB.RESETLOGS_TIME
  )
  WHERE
    SECONDS <= MAX_INTERVAL_TIME_S
  ORDER BY
    START_TIME DESC,
    INST_ID
)
WHERE
  ROWNUM <= NUM_RECORDS
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Locks]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2cc060e0-014d-1000-8028-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_BlockingLocksInHistory]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID,
  NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL ROW_WAIT_OBJ#, NULL ROW_WAIT_FILE#, NULL ROW_WAIT_BLOCK#
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID,
  NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL ROW_WAIT_OBJ#, NULL ROW_WAIT_FILE#, NULL ROW_WAIT_BLOCK#
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    BLOCKED_SQL_ID,
    EVENT,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,
      TO_DATE('01.01.2010 12:01:30', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 13:02:40', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:BLOCKED_SQL_ID,'%') BLOCKED_SQL_ID,
      NVL(:EVENT,'%') EVENT,
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
BLOCKED_SESSIONS AS 
( SELECT /*+ MATERIALIZE */ 
    ASH.SAMPLE_TIME,
    ASH.SAMPLE_ID,
    ASH.INST_ID INSTANCE_NUMBER,
    ASH.SESSION_ID,
    ASH.BLOCKING_SESSION,
    DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    ASH.PROGRAM,
    ASH.SQL_ID,
    ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
    ASH.CURRENT_FILE# ROW_WAIT_FILE#,
    ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#
  FROM 
    BASIS_INFO BI,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    BI.DATA_SOURCE = 'CURRENT' AND
    ASH.BLOCKING_SESSION IS NOT NULL
  UNION ALL
  ( SELECT 
      ASH.SAMPLE_TIME,
      ASH.SAMPLE_ID,
      ASH.INSTANCE_NUMBER,
      ASH.SESSION_ID, 
      ASH.BLOCKING_SESSION,
      DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      ASH.PROGRAM,
      ASH.SQL_ID, 
      ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
      ASH.CURRENT_FILE# ROW_WAIT_FILE#,
      ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      ASH.DBID = BI.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      BI.DATA_SOURCE = 'AWR' AND
      ASH.BLOCKING_SESSION IS NOT NULL
  )
),
BLOCKING_SESSIONS AS
( SELECT DISTINCT /*+ MATERIALIZE */
    BS.SAMPLE_TIME,
    BS.SAMPLE_ID,
    BS.INSTANCE_NUMBER,
    BS.BLOCKING_SESSION SESSION_ID,
    ASH.BLOCKING_SESSION,
    DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    NVL(ASH.PROGRAM, S.PROGRAM || ' (?)') PROGRAM,
    ASH.SQL_ID,
    ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
    ASH.CURRENT_FILE# ROW_WAIT_FILE#,
    ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#
  FROM
    BASIS_INFO BI,
    BLOCKED_SESSIONS BS,
    GV$SESSION S,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
    BS.BLOCKING_SESSION = ASH.SESSION_ID (+) AND
    BS.BLOCKING_SESSION = S.SID (+) AND
    BI.DATA_SOURCE = 'CURRENT'
  UNION ALL
  ( SELECT DISTINCT
      BS.SAMPLE_TIME,
      BS.SAMPLE_ID,
      BS.INSTANCE_NUMBER,
      BS.BLOCKING_SESSION SESSION_ID,
      ASH.BLOCKING_SESSION,
      DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      NVL(ASH.PROGRAM, S.PROGRAM || ' (?)') PROGRAM,
      ASH.SQL_ID,
      ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
      ASH.CURRENT_FILE# ROW_WAIT_FILE#,
      ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      BLOCKED_SESSIONS BS,
      GV$SESSION S,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
      BS.BLOCKING_SESSION = ASH.SESSION_ID (+) AND
      BS.BLOCKING_SESSION = S.SID (+) AND
      BI.DATA_SOURCE = 'AWR'
  )
),
ALL_RELEVANT_SESSIONS AS
( SELECT
    *
  FROM
    BLOCKED_SESSIONS
  UNION
  ( SELECT
      *
    FROM
      BLOCKING_SESSIONS
  )
),
RELEVANT_SAMPLE_TIMES AS
( SELECT DISTINCT
    S.SAMPLE_TIME,
    S.SAMPLE_ID
  FROM
    BASIS_INFO BI,
    ALL_RELEVANT_SESSIONS S
  WHERE
    S.BLOCKING_SESSION IS NOT NULL AND
    NVL(S.SQL_ID, ' ') LIKE BI.BLOCKED_SQL_ID AND
    NVL(S.ACTION, ' ') LIKE BI.EVENT
)
SELECT
  DECODE(LAG(SAMPLE_TIME, 1) OVER (ORDER BY RN), SAMPLE_TIME, NULL, 
    TO_CHAR(SAMPLE_TIME, 'dd.mm.yyyy hh24:mi:ss')) SAMPLE_TIME,
  INST_ID INST, 
  SID, 
  PROGRAM,
  ACTION,
  SQL_ID,
  ENQ_TYPE,
  ENQ_REQUEST,
  TO_CHAR(ROW_WAIT_OBJ#, 999999999990) ROW_WAIT_OBJ#,
  TO_CHAR(ROW_WAIT_FILE#, 9999999999990) ROW_WAIT_FILE#,
  TO_CHAR(ROW_WAIT_BLOCK#, 99999999999990) ROW_WAIT_BLOCK#
FROM 
( SELECT 
    S.SAMPLE_TIME,
    LPAD(' ', 2 * (LEVEL - 1)) || S.SESSION_ID SID, 
    TO_CHAR(S.INSTANCE_NUMBER, 990) INST_ID,
    S.PROGRAM,
    S.ACTION,
    S.SQL_ID,
    DECODE(SUBSTR(S.ACTION, 1, 4), 'enq:', CHR(BITAND(P1, -16777216) / 16777215) ||       
      CHR(BITAND(P1, 16711680) / 65535), NULL) ENQ_TYPE,   
    DECODE(SUBSTR(S.ACTION, 1, 4), 'enq:', DECODE(BITAND(S.P1, 65535), 4, '4 (Shared)', 
      6, '6 (Exclusive)', BITAND(S.P1, 65535)), NULL) ENQ_REQUEST,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_OBJ#, NULL) ROW_WAIT_OBJ#,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_FILE#, NULL) ROW_WAIT_FILE#,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_BLOCK#, NULL) ROW_WAIT_BLOCK#,
    ROWNUM RN
  FROM
    ALL_RELEVANT_SESSIONS S,
    RELEVANT_SAMPLE_TIMES T
  WHERE
    S.SAMPLE_ID = T.SAMPLE_ID
  CONNECT BY 
    PRIOR S.SAMPLE_ID = S.SAMPLE_ID AND
    PRIOR S.SESSION_ID = S.BLOCKING_SESSION
  START WITH
    S.BLOCKING_SESSION IS NULL
) S
ORDER BY
  S.SAMPLE_TIME DESC,
  RN
))]]></sql>
				<binds>
					<bind id="BLOCKED_SQL_ID">
						<prompt><![CDATA[BLOCKED_SQL_ID]]></prompt>
						<tooltip><![CDATA[BLOCKED_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cc1706f-014d-1000-8029-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_BlockingLocksInHistory_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE' */ /* CURRENT_ROW# */
  NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID,
  NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL ROW_WAIT_OBJ#, NULL ROW_WAIT_FILE#, 
  NULL ROW_WAIT_BLOCK#, NULL CURRENT_ROW#
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID,
  NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL ROW_WAIT_OBJ#, NULL ROW_WAIT_FILE#, 
  NULL ROW_WAIT_BLOCK#, NULL CURRENT_ROW#
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    BLOCKED_SQL_ID,
    EVENT,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 22:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 22:01:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:BLOCKED_SQL_ID,'%') BLOCKED_SQL_ID,
      NVL(:EVENT,'%') EVENT,
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
BLOCKED_SESSIONS AS 
( SELECT /*+ MATERIALIZE */ 
    ASH.SAMPLE_TIME,
    ASH.SAMPLE_ID,
    ASH.INST_ID,
    ASH.SESSION_ID,
    ASH.BLOCKING_INST_ID,
    ASH.BLOCKING_SESSION BLOCKING_SESSION_ID,
    DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    ASH.PROGRAM,
    ASH.SQL_ID,
    ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
    ASH.CURRENT_FILE# ROW_WAIT_FILE#,
    ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#,
    ASH.CURRENT_ROW# ROW_WAIT_ROW#
  FROM 
    BASIS_INFO BI,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    BI.DATA_SOURCE = 'CURRENT' AND
    ASH.BLOCKING_SESSION IS NOT NULL
  UNION ALL
  ( SELECT 
      ASH.SAMPLE_TIME,
      ASH.SAMPLE_ID,
      ASH.INSTANCE_NUMBER INST_ID,
      ASH.SESSION_ID, 
      ASH.BLOCKING_INST_ID,
      ASH.BLOCKING_SESSION BLOCKING_SESSION_ID,
      DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      ASH.PROGRAM,
      ASH.SQL_ID, 
      ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
      ASH.CURRENT_FILE# ROW_WAIT_FILE#,
      ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#,
      ASH.CURRENT_ROW# ROW_WAIT_ROW#
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      ASH.DBID = BI.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      BI.DATA_SOURCE = 'AWR' AND
      ASH.BLOCKING_SESSION IS NOT NULL
  )
),
BLOCKING_SESSIONS AS
( SELECT DISTINCT /*+ MATERIALIZE */
    BS.SAMPLE_TIME,
    BS.SAMPLE_ID,
    BS.BLOCKING_INST_ID INST_ID,
    BS.BLOCKING_SESSION_ID SESSION_ID,
    ASH.BLOCKING_INST_ID,
    ASH.BLOCKING_SESSION BLOCKING_SESSION_ID,
    DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.P1,
    ASH.P2,
    ASH.P3,
    NVL(ASH.PROGRAM, S.PROGRAM || ' (?)') PROGRAM,
    ASH.SQL_ID,
    ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
    ASH.CURRENT_FILE# ROW_WAIT_FILE#,
    ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#,
    ASH.CURRENT_ROW# ROW_WAIT_ROW#
  FROM
    BASIS_INFO BI,
    BLOCKED_SESSIONS BS,
    GV$SESSION S,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
    BS.BLOCKING_SESSION_ID = ASH.SESSION_ID (+) AND
    BS.BLOCKING_SESSION_ID = S.SID (+) AND
    BS.BLOCKING_INST_ID = ASH.INST_ID (+) AND
    BS.BLOCKING_INST_ID = S.INST_ID (+) AND
    BI.DATA_SOURCE = 'CURRENT'
  UNION ALL
  ( SELECT DISTINCT
      BS.SAMPLE_TIME,
      BS.SAMPLE_ID,
      BS.BLOCKING_INST_ID INST_ID,
      BS.BLOCKING_SESSION_ID SESSION_ID,
      ASH.BLOCKING_INST_ID,
      ASH.BLOCKING_SESSION BLOCKING_SESSION_ID,
      DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.P1,
      ASH.P2,
      ASH.P3,
      NVL(ASH.PROGRAM, S.PROGRAM || ' (?)') PROGRAM,
      ASH.SQL_ID,
      ASH.CURRENT_OBJ# ROW_WAIT_OBJ#,
      ASH.CURRENT_FILE# ROW_WAIT_FILE#,
      ASH.CURRENT_BLOCK# ROW_WAIT_BLOCK#,
      ASH.CURRENT_ROW# ROW_WAIT_ROW#
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      BLOCKED_SESSIONS BS,
      GV$SESSION S,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
      BS.BLOCKING_SESSION_ID = ASH.SESSION_ID (+) AND
      BS.BLOCKING_SESSION_ID = S.SID (+) AND
      BS.BLOCKING_INST_ID = ASH.INSTANCE_NUMBER (+) AND
      BS.BLOCKING_INST_ID = S.INST_ID (+) AND
      BI.DATA_SOURCE = 'AWR'
  )
),
ALL_RELEVANT_SESSIONS AS
( SELECT
    *
  FROM
    BLOCKED_SESSIONS
  UNION
  ( SELECT
      *
    FROM
      BLOCKING_SESSIONS
  )
),
RELEVANT_SAMPLE_TIMES AS
( SELECT DISTINCT
    S.SAMPLE_TIME,
    S.SAMPLE_ID
  FROM
    BASIS_INFO BI,
    ALL_RELEVANT_SESSIONS S
  WHERE
    S.BLOCKING_SESSION_ID IS NOT NULL AND
    NVL(S.SQL_ID, ' ') LIKE BI.BLOCKED_SQL_ID AND
    NVL(S.ACTION, ' ') LIKE BI.EVENT
)
SELECT
  DECODE(LAG(SAMPLE_TIME, 1) OVER (ORDER BY RN), SAMPLE_TIME, NULL, 
    TO_CHAR(SAMPLE_TIME, 'dd.mm.yyyy hh24:mi:ss')) SAMPLE_TIME,
  INST_ID INST, 
  SID, 
  PROGRAM,
  ACTION,
  SQL_ID,
  ENQ_TYPE,
  ENQ_REQUEST,
  TO_CHAR(ROW_WAIT_OBJ#, 999999999990) ROW_WAIT_OBJ#,
  TO_CHAR(ROW_WAIT_FILE#, 9999999999990) ROW_WAIT_FILE#,
  TO_CHAR(ROW_WAIT_BLOCK#, 99999999999990) ROW_WAIT_BLOCK#,
  TO_CHAR(ROW_WAIT_ROW#, 999999999990) ROW_WAIT_ROW#
FROM 
( SELECT 
    S.SAMPLE_TIME,
    LPAD(' ', 2 * (LEVEL - 1)) || S.SESSION_ID SID, 
    TO_CHAR(S.INST_ID, 990) INST_ID,
    S.PROGRAM,
    S.ACTION,
    S.SQL_ID,
    DECODE(SUBSTR(S.ACTION, 1, 4), 'enq:', CHR(BITAND(P1, -16777216) / 16777215) ||       
      CHR(BITAND(P1, 16711680) / 65535), NULL) ENQ_TYPE,   
    DECODE(SUBSTR(S.ACTION, 1, 4), 'enq:', DECODE(BITAND(S.P1, 65535), 4, '4 (Shared)', 
      6, '6 (Exclusive)', BITAND(S.P1, 65535)), NULL) ENQ_REQUEST,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_OBJ#, NULL) ROW_WAIT_OBJ#,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_FILE#, NULL) ROW_WAIT_FILE#,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_BLOCK#, NULL) ROW_WAIT_BLOCK#,
    DECODE(S.ACTION, 'enq: TX - row lock contention', S.ROW_WAIT_ROW#, NULL) ROW_WAIT_ROW#,
    ROWNUM RN
  FROM
    ALL_RELEVANT_SESSIONS S,
    RELEVANT_SAMPLE_TIMES T
  WHERE
    S.SAMPLE_ID = T.SAMPLE_ID
  CONNECT BY 
    PRIOR S.SAMPLE_ID = S.SAMPLE_ID AND
    PRIOR S.SESSION_ID = S.BLOCKING_SESSION_ID AND
    PRIOR S.INST_ID = S.BLOCKING_INST_ID
  START WITH
    S.BLOCKING_SESSION_ID IS NULL AND
    S.BLOCKING_INST_ID IS NULL
) S
ORDER BY
  S.SAMPLE_TIME DESC,
  RN
))]]></sql>
				<binds>
					<bind id="BLOCKED_SQL_ID">
						<prompt><![CDATA[BLOCKED_SQL_ID]]></prompt>
						<tooltip><![CDATA[BLOCKED_SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cc29bf0-014d-1000-802a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_CurrentBlockingLocks_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /* 11g: Display of deadlocked sessions based on V$WAIT_CHAINS */ 
  NULL SID, NULL INST, NULL DEADLOCK, NULL PROCESS, NULL MACHINE,
  NULL ACTION, NULL COMMAND_TYPE, NULL SQL_ID, 
  NULL PREV_SQL_ID, NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL OBJECT_NAME,
  NULL ROW_WAIT_FILE#, NULL ROW_WAIT_BLOCK#, NULL ROW_WAIT_ROW#,
  NULL SECONDS_IN_WAIT, NULL ROW_EXTRACTION_COMMAND
FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL SID, NULL INST, NULL DEADLOCK, NULL PROCESS, NULL MACHINE,
  NULL ACTION, NULL COMMAND_TYPE, NULL SQL_ID, 
  NULL PREV_SQL_ID, NULL ENQ_TYPE, NULL ENQ_REQUEST, NULL OBJECT_NAME,
  NULL ROW_WAIT_FILE#, NULL ROW_WAIT_BLOCK#, NULL ROW_WAIT_ROW#,
  NULL SECONDS_IN_WAIT, NULL ROW_EXTRACTION_COMMAND
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH ALL_SESSIONS AS 
( SELECT /*+ MATERIALIZE */ 
    S.INST_ID,
    S.SID, 
    S.PROCESS,
    S.MACHINE,
    S.COMMAND,
    S.BLOCKING_SESSION,
    S.BLOCKING_INSTANCE,
    S.BLOCKING_SESSION_STATUS,
    DECODE(S.STATE, 'WAITING', S.EVENT, 'CPU') ACTION,
    S.P1,
    S.P2,
    S.P3,
    S.SECONDS_IN_WAIT, 
    S.SQL_ID, 
    S.PREV_SQL_ID,
    S.ROW_WAIT_OBJ#, 
    S.ROW_WAIT_FILE#, 
    S.ROW_WAIT_BLOCK#, 
    S.ROW_WAIT_ROW#,
    DECODE(NVL(WC.CHAIN_IS_CYCLE, ' '), 'TRUE', 'X', ' ') DEADLOCK,
    AA.NAME COMMAND_TYPE
  FROM 
    GV$SESSION S,
    V$WAIT_CHAINS WC,
    AUDIT_ACTIONS AA
  WHERE
    S.INST_ID = WC.INSTANCE (+) AND
    S.SID = WC.SID (+) AND
    S.SERIAL# = WC.SESS_SERIAL# (+) AND
    S.COMMAND = AA.ACTION (+)
),
BLOCKED_SESSIONS AS
( SELECT
    INST_ID,
    SID,
    ROW_WAIT_OBJ#
  FROM
    ALL_SESSIONS
  WHERE
    BLOCKING_SESSION_STATUS = 'VALID'
),
BLOCKING_SESSIONS AS
( SELECT DISTINCT 
    BLOCKING_INSTANCE INST_ID,
    BLOCKING_SESSION SID
  FROM
    ALL_SESSIONS
),
PRIMARY_BLOCKING_SESSIONS AS
( SELECT
    INST_ID,
    SID
  FROM
    BLOCKING_SESSIONS
  WHERE
    ( INST_ID, SID ) NOT IN
    ( SELECT
        INST_ID,
        SID
      FROM
        BLOCKED_SESSIONS
    )
),
LOCKED_OBJECTS AS
( SELECT DISTINCT /*+ MATERIALIZE */
    O.OWNER OWNER,
    O.OBJECT_NAME OBJECT_NAME,
    O.OBJECT_ID OBJECT_ID,
    O.DATA_OBJECT_ID DATA_OBJECT_ID
  FROM
    DBA_OBJECTS O,
    BLOCKED_SESSIONS BS
  WHERE
    BS.ROW_WAIT_OBJ# = O.OBJECT_ID
)
SELECT
  SID, 
  TO_CHAR(INST_ID, 990) INST, 
  DEADLOCK,
  PROCESS,
  MACHINE,
  ACTION,
  COMMAND_TYPE,
  SQL_ID,
  PREV_SQL_ID,
  ENQ_TYPE,
  ENQ_REQUEST,
  OBJECT_NAME,
  TO_CHAR(ROW_WAIT_FILE#, 9999999999990) ROW_WAIT_FILE#,
  TO_CHAR(ROW_WAIT_BLOCK#, 99999999999990) ROW_WAIT_BLOCK#,
  TO_CHAR(ROW_WAIT_ROW#, 999999999990) ROW_WAIT_ROW#,
  TO_CHAR(SECONDS_IN_WAIT, 99999999999990) SECONDS_IN_WAIT,
  ROW_EXTRACTION_COMMAND
FROM 
( SELECT 
    LPAD(' ', 2 * (LOCK_LEVEL - 1)) || SID SID, 
    INST_ID,
    DEADLOCK,
    PROCESS,
    MACHINE,
    ACTION,
    COMMAND_TYPE,
    SQL_ID,
    PREV_SQL_ID,
    DECODE(SUBSTR(ACTION, 1, 4), 'enq:', CHR(BITAND(P1, -16777216) / 16777215) ||       
      CHR(BITAND(P1, 16711680) / 65535), NULL) ENQ_TYPE,   
    DECODE(SUBSTR(ACTION, 1, 4), 'enq:', DECODE(BITAND(P1, 65535), 4, '4 (Shared)', 
      6, '6 (Exclusive)', BITAND(P1, 65535)), NULL) ENQ_REQUEST,
    DECODE(ACTION, 'enq: TX - row lock contention', NVL(OBJECT_NAME, ROW_WAIT_OBJ#), NULL) OBJECT_NAME,
    DECODE(ACTION, 'enq: TX - row lock contention', ROW_WAIT_FILE#, NULL) ROW_WAIT_FILE#,
    DECODE(ACTION, 'enq: TX - row lock contention', ROW_WAIT_BLOCK#, NULL) ROW_WAIT_BLOCK#,
    DECODE(ACTION, 'enq: TX - row lock contention', ROW_WAIT_ROW#, NULL) ROW_WAIT_ROW#,
    DECODE(ACTION, 'enq: TX - row lock contention', SECONDS_IN_WAIT) SECONDS_IN_WAIT,
    DECODE(ACTION, 'enq: TX - row lock contention', 
      DECODE(BITAND(P1, 65535), 6, 
      'SELECT * FROM "' || OWNER || '"."' || OBJECT_NAME || 
      '" WHERE ROWID = DBMS_ROWID.ROWID_CREATE(1, ' ||                       
      DATA_OBJECT_ID || ', ' || ROW_WAIT_FILE# || ', ' || ROW_WAIT_BLOCK# || ', ' ||             
      ROW_WAIT_ROW# || ');', 'No exclusive lock'), 'No row lock contention') ROW_EXTRACTION_COMMAND
  FROM
  ( SELECT
      LEVEL LOCK_LEVEL,
      S.*,
      LO.*
    FROM
      ALL_SESSIONS S,
      LOCKED_OBJECTS LO
    WHERE
      S.ROW_WAIT_OBJ# = LO.OBJECT_ID (+)
    CONNECT BY NOCYCLE
      PRIOR SID = BLOCKING_SESSION AND
      PRIOR INST_ID = BLOCKING_INSTANCE
    START WITH
      (INST_ID, SID) IN
      ( SELECT 
          INST_ID, SID 
        FROM 
          PRIMARY_BLOCKING_SESSIONS
      ) OR
      S.DEADLOCK = 'X'
  )
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2ccb4ff3-014d-1000-802b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_LockHolderActivities_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT  /* 11g: BLOCKING_INST_ID */ /*+ OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE') */
  NULL SQL_ID, NULL ACTION, NULL NUM_WAITERS, NULL "WAITERS_%", NULL AVG_WAITERS, NULL SAMPLE_TIMES
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT 
  NULL SQL_ID, NULL ACTION, NULL NUM_WAITERS, NULL "WAITERS_%", NULL AVG_WAITERS, NULL SAMPLE_TIMES
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    EVENT,
    NUM_RECORDS,
    HOLDER_AGGREGATION
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 00:01:30', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 00:01:40', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:EVENT,'enq: TX - row lock contention') EVENT,
      20 NUM_RECORDS,
      '' HOLDER_AGGREGATION      /* 'EVENT': Aggregation by event, 'SQL_ID': Aggregation by SQL_ID, NULL: Aggregation by event and SQL_ID */ 
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE ) 
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
)
SELECT 
  'BEGIN TIME:' SQL_ID,
  TO_CHAR(MAX(GREATEST(BI.BEGIN_TIME, SS.BEGIN_TIME)), 'dd.mm.yyyy hh24:mi:ss') ACTION,
  NULL NUM_WAITERS,
  NULL "WAITERS_%",
  NULL AVG_WAITERS,
  NULL SAMPLE_TIMES
FROM
  BASIS_INFO BI,
  SNAPSHOTS SS
UNION ALL
( SELECT 
    'END TIME:' SQL_ID,
    TO_CHAR(MIN(LEAST(BI.END_TIME, SS.END_TIME)), 'dd.mm.yyyy hh24:mi:ss') ACTION,
    NULL NUM_WAITERS,
    NULL "WAITERS_%",
    NULL AVG_WAITERS,
    NULL SAMPLE_TIMES
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS
)
UNION ALL
( SELECT
    'SQL_ID:' SQL_ID,
    DECODE(SQL_ID, '%', 'any', SQL_ID) ACTION,
    NULL NUM_WAITERS,
    NULL "WAITERS_%",
    NULL AVG_WAITERS,
    NULL SAMPLE_TIMES
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'EVENT:' SQL_ID,
    DECODE(EVENT, '%', 'any', EVENT) ACTION,
    NULL NUM_WAITERS,
    NULL "WAITERS_%",
    NULL AVG_WAITERS,
    NULL SAMPLE_TIMES
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL SQL_ID,
    NULL ACTION,
    NULL NUM_WAITERS,
    NULL "WAITERS_%",
    NULL AVG_WAITERS,
    NULL SAMPLE_TIMES
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    SQL_ID,
    ACTION,
    TO_CHAR(TOTAL_WAITERS, 9999999990) NUM_WAITERS,
    TO_CHAR(RATIO_TO_REPORT(TOTAL_WAITERS) OVER () * 100, 99990.99) "WAITERS_%",
    TO_CHAR(AVG_WAITERS, 9999990.99) AVG_WAITERS,
    TO_CHAR(OCCURRENCES, 99999999990) SAMPLE_TIMES
  FROM
  ( SELECT
      COUNT(*) OCCURRENCES,
      ACTION,
      SQL_ID,
      SUM(NUM_WAITERS) TOTAL_WAITERS,
      ROUND(SUM(NUM_WAITERS) / COUNT(*), 2) AVG_WAITERS,
      NUM_RECORDS
    FROM
    ( SELECT /*+ CARDINALITY(ASW.ASH 10000) */ 
        TO_CHAR(ASW.SAMPLE_TIME, 'YYYY-MM-DD HH24:MI:SS') SAMPLE_TIME,
        COUNT(*) "NUM_WAITERS",
        DECODE(BI.HOLDER_AGGREGATION, 'SQL_ID', 'any',
          DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 
            'WAITING', ASH.EVENT, 'CPU')) ACTION,
        DECODE(BI.HOLDER_AGGREGATION, 'EVENT', 'any', ASH.SQL_ID) SQL_ID,
        BI.HOLDER_AGGREGATION,
        BI.NUM_RECORDS
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH, 
        DBA_HIST_ACTIVE_SESS_HISTORY ASW
      WHERE
        BI.DBID = ASW.DBID AND 
        ASW.DBID = ASH.DBID (+) AND
        SS.INSTANCE_NUMBER = ASW.INSTANCE_NUMBER AND
        ASW.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
        ASW.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        ASH.SAMPLE_TIME (+) = ASW.SAMPLE_TIME AND
        ASH.SESSION_ID (+) =  ASW.BLOCKING_SESSION AND
        ASH.INSTANCE_NUMBER (+) = ASW.BLOCKING_INST_ID AND
        ASW.EVENT LIKE BI.EVENT AND
        ASW.SESSION_STATE = 'WAITING' AND
        NVL(ASW.SQL_ID, ' ') LIKE BI.SQL_ID
      GROUP BY
        ASW.SAMPLE_TIME,
        DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 
          'WAITING', ASH.EVENT, 'CPU'),
        ASH.SQL_ID,
        BI.HOLDER_AGGREGATION,
        BI.NUM_RECORDS
    )
    GROUP BY
      ACTION,
      SQL_ID,
      NUM_RECORDS
    ORDER BY
      COUNT(*) DESC
  )
  WHERE 
    ROWNUM <= NUM_RECORDS
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cd17d59-014d-1000-802d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_NonPopularLatches_ASH]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL LATCH_NAME, NULL LATCH#, NULL OCCURRENCES, NULL PERCENT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL LATCH_NAME, NULL LATCH#, NULL OCCURRENCES, NULL PERCENT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    SESSION_ID,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,          /* -2 for all instances, -1 for current instance */
      TO_DATE('30.03.1000 11:59:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('30.03.9999 12:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:SESSION_ID,-1) SESSION_ID,   
      NVL(:DATA_SOURCE,'CURRENT') DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) 
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
)
SELECT
  'SQL_ID: ' || SQL_ID LATCH_NAME,
  NULL LATCH#,
  NULL OCCURRENCES,
  NULL PERCENT
FROM
  BASIS_INFO
WHERE
  SQL_ID != '%'
UNION ALL
( SELECT
    'SESSION: ' || SESSION_ID LATCH_NAME,
  NULL LATCH#,
  NULL OCCURRENCES,
  NULL PERCENT
FROM
  BASIS_INFO
WHERE
  SESSION_ID != -1
)
UNION ALL
( SELECT
  NULL LATCH_NAME,
  NULL LATCH#,
  NULL OCCURRENCES,
  NULL PERCENT
FROM
  BASIS_INFO
WHERE
  SESSION_ID != -1 OR
  SQL_ID != '%'
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      NAME LATCH_NAME,
      TO_CHAR(LATCH#, 99990) LATCH#,
      TO_CHAR(OCCURRENCES, 9999999990) OCCURRENCES,
      TO_CHAR(PERCENT, 990.99) PERCENT
    FROM
    ( SELECT /*+ FULL(ASH.ASH) */
        L.NAME,
        L.LATCH#,
        COUNT(*) OCCURRENCES,
        ROUND(RATIO_TO_REPORT(COUNT(*)) OVER () * 100, 2) PERCENT
      FROM
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_ACTIVE_SESS_HISTORY ASH,
        V$LATCH L
      WHERE
        ASH.DBID = SS.DBID AND
        ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
        ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
        NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
        ( BI.INSTANCE_NUMBER = -2 OR 
          BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
        ( BI.SESSION_ID = -1 OR
          BI.SESSION_ID = ASH.SESSION_ID ) AND
        BI.DATA_SOURCE = 'AWR' AND
        ASH.P2 = L.LATCH# AND
        ASH.EVENT = 'latch free' AND
        ASH.SESSION_STATE = 'WAITING'
      GROUP BY
        L.LATCH#,
        L.NAME
      UNION ALL
      ( SELECT
          L.NAME,
          L.LATCH#,
          COUNT(*) OCCURRENCES,
          ROUND(RATIO_TO_REPORT(COUNT(*)) OVER () * 100, 2) PERCENT
        FROM
          BASIS_INFO BI,
          SNAPSHOTS SS,
          GV$ACTIVE_SESSION_HISTORY ASH,
          V$LATCH L
        WHERE
          ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
          NVL(ASH.SQL_ID, ' ') LIKE BI.SQL_ID AND
          ( BI.INSTANCE_NUMBER = -2 OR 
            BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
          ( BI.SESSION_ID = -1 OR
            BI.SESSION_ID = ASH.SESSION_ID ) AND
          BI.DATA_SOURCE = 'CURRENT' AND
          ASH.P2 = L.LATCH# AND
          ASH.EVENT = 'latch free' AND
          ASH.SESSION_STATE = 'WAITING'
        GROUP BY
          L.LATCH#,
          L.NAME 
      )
    )
    ORDER BY
      OCCURRENCES DESC
  )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SESSION_ID">
						<prompt><![CDATA[SESSION_ID]]></prompt>
						<tooltip><![CDATA[SESSION_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATA_SOURCE">
						<prompt><![CDATA[DATA_SOURCE]]></prompt>
						<tooltip><![CDATA[DATA_SOURCE]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cd37eb0-014d-1000-802e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Locks_TopRows_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OBJECT_ID, NULL "FILE", NULL "BLOCK", NULL "ROW",
  NULL OCCURRENCES, NULL PERCENT FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OBJECT_ID, NULL "FILE", NULL "BLOCK", NULL "ROW",
  NULL OCCURRENCES, NULL PERCENT FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    EVENT,
    NUM_RECORDS
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,                 /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.2011 14:55:30', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 00:01:40', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SQL_ID,'%') SQL_ID,
      NVL(:EVENT,'%') EVENT,
      10 NUM_RECORDS
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE ) 
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
)
SELECT DISTINCT
  'BEGIN TIME:' OBJECT_ID,
  TO_CHAR(GREATEST(BI.BEGIN_TIME, SS.BEGIN_TIME), 'dd.mm.yyyy') "FILE",
  TO_CHAR(GREATEST(BI.BEGIN_TIME, SS.BEGIN_TIME), 'hh24:mi:ss') "BLOCK",
  NULL "ROW",
  NULL OCCURRENCES,
  NULL PERCENT
FROM
  BASIS_INFO BI,
  SNAPSHOTS SS
UNION ALL
( SELECT DISTINCT
    'END TIME:' OBJECT_ID,
    TO_CHAR(LEAST(BI.END_TIME, SS.END_TIME), 'dd.mm.yyyy') "FILE",
    TO_CHAR(LEAST(BI.END_TIME, SS.END_TIME), 'hh24:mi:ss') "BLOCK",
    NULL "ROW",
    NULL OCCURRENCES,
    NULL PERCENT
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS
)
UNION ALL
( SELECT
    'SQL_ID: ' || DECODE(SQL_ID, '%', 'any', SQL_ID) OBJECT_ID,
    NULL "FILE",
    NULL "BLOCK",
    NULL "ROW",
    NULL OCCURRENCES,
    NULL PERCENT
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'EVENT: ' || DECODE(EVENT, '%', 'any', EVENT) OBJECT_ID,
    NULL "FILE",
    NULL "BLOCK",
    NULL "ROW",
    NULL OCCURRENCES,
    NULL PERCENT
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL OBJECT_ID,
    NULL "FILE",
    NULL "BLOCK",
    NULL "ROW",
    NULL OCCURRENCES,
    NULL PERCENT
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    LPAD(CURRENT_OBJ#, GREATEST(19, LENGTH(EVENT) + 8)) OBJECT_ID,
    TO_CHAR(CURRENT_FILE#, 999999990) "FILE",
    TO_CHAR(CURRENT_BLOCK#, 9999990) "BLOCK",
    TO_CHAR(CURRENT_ROW#, 9990) "ROW",
    TO_CHAR(OCCURRENCES, 9999999990) OCCURRENCES,
    TO_CHAR(PERCENT, 990.99) PERCENT
  FROM
  ( SELECT
      ASH.CURRENT_OBJ#,
      ASH.CURRENT_FILE#,
      ASH.CURRENT_BLOCK#,
      ASH.CURRENT_ROW#,
      COUNT(*) OCCURRENCES,
      TO_CHAR(RATIO_TO_REPORT (COUNT(*)) OVER () * 100, 990.99) PERCENT,
      BI.NUM_RECORDS,
      ASH.EVENT
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      SS.DBID = ASH.DBID AND
      SS.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      ASH.EVENT LIKE BI.EVENT AND
      ASH.SQL_ID LIKE BI.SQL_ID AND
      ASH.SESSION_STATE = 'WAITING' 
    GROUP BY
      ASH.CURRENT_OBJ#,
      ASH.CURRENT_FILE#,
      ASH.CURRENT_BLOCK#,
      ASH.CURRENT_ROW#,
      BI.NUM_RECORDS,
      ASH.EVENT
    ORDER BY 
      PERCENT DESC 
  )
  WHERE
    ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="EVENT">
						<prompt><![CDATA[EVENT]]></prompt>
						<tooltip><![CDATA[EVENT]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Segments]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2cd8fb5d-014d-1000-802f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Segments_Indexes_IndexColumns]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INDEX_NAME, NULL U, NULL B, NULL P, NULL F, NULL CM, NULL NUM_ROWS, 
  NULL DIST_KEYS, NULL COLUMN_NAME, 
  NULL NUM_DISTINCT, NULL AVG_COL_LEN, NULL ROWS_PER_VALUE FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INDEX_NAME, NULL U, NULL B, NULL P, NULL F, NULL CM, NULL NUM_ROWS, 
  NULL DIST_KEYS, NULL COLUMN_NAME, 
  NULL NUM_DISTINCT, NULL AVG_COL_LEN, NULL ROWS_PER_VALUE FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    NVL(:TABLE_NAME,'%') TABLE_NAME,
    NVL(:INDEX_NAME,'%') INDEX_NAME
  FROM
    DUAL
)
SELECT
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', IC.INDEX_NAME) INDEX_NAME,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', DECODE(I.UNIQUENESS, 'UNIQUE', 'X', ' ')) U,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', DECODE(I.INDEX_TYPE, 'BITMAP', 'X', ' ')) B,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', DECODE(I.PARTITIONED, 'YES', 'X', ' ')) P,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', DECODE(I.INDEX_TYPE, 'FUNCTION-BASED NORMAL', 'X', ' ')) F,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', I.PREFIX_LENGTH) CM,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', TO_CHAR(I.NUM_ROWS, 9999999990)) NUM_ROWS,
  DECODE(LAG(IC.INDEX_NAME, 1) OVER (ORDER BY IC.INDEX_OWNER, IC.INDEX_NAME, IC.COLUMN_POSITION),
    IC.INDEX_NAME, ' ', TO_CHAR(I.DISTINCT_KEYS, 9999999990)) DIST_KEYS,
  IC.COLUMN_NAME,
  TO_CHAR(TC.NUM_DISTINCT, 99999999990) NUM_DISTINCT,
  TO_CHAR(TC.AVG_COL_LEN, 9999999990) AVG_COL_LEN,
  TO_CHAR(DECODE(TC.NUM_DISTINCT, 0, 0, I.NUM_ROWS / TC.NUM_DISTINCT), 9999999990.99) ROWS_PER_VALUE
FROM
  BASIS_INFO BI,
  DBA_TAB_COLS TC,
  DBA_IND_COLUMNS IC,
  DBA_INDEXES I
WHERE
  TC.OWNER LIKE BI.OWNER AND
  TC.TABLE_NAME LIKE BI.TABLE_NAME AND
  IC.INDEX_NAME LIKE BI.INDEX_NAME AND
  IC.TABLE_OWNER = TC.OWNER AND
  IC.TABLE_NAME = TC.TABLE_NAME AND
  IC.COLUMN_NAME = TC.COLUMN_NAME AND
  I.TABLE_OWNER = IC.TABLE_OWNER AND
  I.INDEX_NAME = IC.INDEX_NAME 
ORDER BY
  IC.INDEX_OWNER,
  IC.INDEX_NAME,
  IC.COLUMN_POSITION
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="INDEX_NAME">
						<prompt><![CDATA[INDEX_NAME]]></prompt>
						<tooltip><![CDATA[INDEX_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cda8ec5-014d-1000-8030-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Segments_MaterializedViewLogs]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL LOG_OWNER, NULL MASTER, NULL LOG_TABLE, NULL CREATED, 
  NULL MASTER_SIZE_MB, NULL LOG_SIZE_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL LOG_OWNER, NULL MASTER, NULL LOG_TABLE, NULL CREATED, 
  NULL MASTER_SIZE_MB, NULL LOG_SIZE_MB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    '%' OWNER
  FROM
    DUAL
)
SELECT
  M.LOG_OWNER,
  M.MASTER,
  M.LOG_TABLE,
  TO_CHAR(O.CREATED, 'dd.mm.yyyy hh24:mi:ss') CREATED,
  TO_CHAR(ST.BYTES / 1024 / 1024, 9999999990.99) MASTER_SIZE_MB,
  TO_CHAR(SL.BYTES / 1024 / 1024, 9999990.99) LOG_SIZE_MB
FROM
  BASIS_INFO BI,
  DBA_MVIEW_LOGS M,
  DBA_OBJECTS O,
  DBA_SEGMENTS ST,
  DBA_SEGMENTS SL
WHERE
  M.LOG_OWNER LIKE BI.OWNER AND
  ST.OWNER = M.LOG_OWNER AND
  O.OBJECT_NAME = M.LOG_TABLE AND
  ST.SEGMENT_NAME = M.MASTER AND
  SL.SEGMENT_NAME = M.LOG_TABLE
ORDER BY
  O.CREATED
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cdaf9ec-014d-1000-8031-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Segments_MaterializedViews]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL MVIEW_NAME, NULL CREATED, NULL SIZE_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL MVIEW_NAME, NULL CREATED, NULL SIZE_MB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    '%' OWNER
  FROM
    DUAL
)
SELECT
  M.OWNER,
  M.MVIEW_NAME,
  TO_CHAR(O.CREATED, 'dd.mm.yyyy hh24:mi:ss') CREATED,
  TO_CHAR(S.BYTES / 1024 / 1024, 9999990.99) SIZE_MB
FROM
  BASIS_INFO BI,
  DBA_MVIEWS M,
  DBA_OBJECTS O,
  DBA_SEGMENTS S
WHERE
  M.OWNER LIKE BI.OWNER AND
  O.OBJECT_NAME = M.MVIEW_NAME AND
  O.OBJECT_NAME = S.SEGMENT_NAME
ORDER BY
  O.CREATED
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cdd2153-014d-1000-8032-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Segments_Tables_TopDMLRate]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL TABLE_NAME, NULL PART, NULL STAT_AGE_DAYS,
  NULL DML_TOTAL_PER_S, NULL INS_PER_S, NULL UPD_PER_S, NULL DEL_PER_S,
  NULL CHANGE_MB_PER_H
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TABLE_NAME, NULL PART, NULL DAYS_SINCE_STAT_RUN,
  NULL DML_TOTAL_PER_S, NULL INSERTS_PER_S, NULL UPDATES_PER_S, NULL DELETES_PER_S,
  NULL CHANGE_MB_PER_H
FROM DUAL WHERE 1 = 0
)
UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    50 NUM_RECORDS,
    'TOTAL' ORDER_BY         /* TOTAL, INSERT, UPDATE, DELETE */
  FROM
    DUAL
)
SELECT
  OWNER,
  TABLE_NAME,
  PARTITION_NAME PART,
  TO_CHAR(SECONDS / 86400, 999999990.99) STAT_AGE_DAYS,
  TO_CHAR(DML_TOTAL / SECONDS, 99999999990.99) DML_TOTAL_PER_S,
  TO_CHAR(INSERTS / SECONDS, 99990.99) INS_PER_S,
  TO_CHAR(UPDATES / SECONDS, 99990.99) UPD_PER_S,
  TO_CHAR(DELETES / SECONDS, 99990.99) DEL_PER_S,
  TO_CHAR(AVG_ROW_LEN * DML_TOTAL / SECONDS * 3600 / 1024 / 1024, 
    99999999990.99) CHANGE_MB_PER_H
FROM
( SELECT
    OWNER,
    TABLE_NAME,
    PARTITION_NAME,
    DML_TOTAL,
    INSERTS,
    UPDATES,
    DELETES,
    AVG_ROW_LEN,
    SECONDS,
    NUM_RECORDS
  FROM
  ( SELECT
      T.OWNER,
      T.TABLE_NAME,
      T.PARTITION_NAME,
      T.LAST_ANALYZED,
      TO_CHAR(SYSDATE, 'SSSSS') - TO_CHAR(T.LAST_ANALYZED, 'SSSSS') +
        86400 * (TO_CHAR(SYSDATE, 'J') - TO_CHAR(T.LAST_ANALYZED, 'J')) SECONDS,
      TM.INSERTS + TM.UPDATES + TM.DELETES DML_TOTAL,
      TM.INSERTS,
      TM.UPDATES,
      TM.DELETES,
      NVL(T.AVG_ROW_LEN, 0) AVG_ROW_LEN,
      BI.NUM_RECORDS,
      BI.ORDER_BY
    FROM
      BASIS_INFO BI,
      ALL_TAB_MODIFICATIONS TM,
      DBA_TAB_STATISTICS T
    WHERE
      TM.TABLE_OWNER LIKE BI.OWNER AND
      TM.TABLE_OWNER = T.OWNER AND
      TM.TABLE_NAME = T.TABLE_NAME AND
      NVL(TM.PARTITION_NAME, ' ') = NVL(T.PARTITION_NAME, ' ') AND
      T.LAST_ANALYZED IS NOT NULL 
  )
  ORDER BY
    DECODE(ORDER_BY, 'TOTAL', DML_TOTAL / SECONDS, 'INSERT', INSERTS / SECONDS,
      'UPDATE', UPDATES / SECONDS, 'DELETE', DELETES / SECONDS) DESC
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2ce50500-014d-1000-8033-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SegmentStatistics_TopSegmentsForStatisticPerAWRInterval_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT
  NULL BEGIN_TIME, NULL TOTAL_VALUE, NULL VALUE_PER_S,
  NULL SEGMENT_1, NULL VALUE_1, NULL "%_1",
  NULL SEGMENT_2, NULL VALUE_2, NULL "%_2",
  NULL SEGMENT_3, NULL VALUE_3, NULL "%_3",
  NULL SEGMENT_4, NULL VALUE_4, NULL "%_4",
  NULL SEGMENT_5, NULL VALUE_5, NULL "%_5"
FROM DUAL
  WHERE 1 = 0
UNION ALL ( 
SELECT
  NULL BEGIN_TIME, NULL TOTAL_VALUE, NULL VALUE_PER_S,
  NULL SEGMENT_1, NULL VALUE_1, NULL "%_1",
  NULL SEGMENT_2, NULL VALUE_2, NULL "%_2",
  NULL SEGMENT_3, NULL VALUE_3, NULL "%_3",
  NULL SEGMENT_4, NULL VALUE_4, NULL "%_4",
  NULL SEGMENT_5, NULL VALUE_5, NULL "%_5"
FROM DUAL
  WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    STAT_NAME,
    AGGREGATE_BY,
    EXCLUDE_WEEKENDS
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 23:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 00:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      NVL(:STAT_NAME,'Row Lock Waits') STAT_NAME,
      NVL(:AGGREGATE_BY,'DAY') AGGREGATE_BY,  /* SNAPSHOT, DAY, HOUR_OF_DAY */
      ' ' EXCLUDE_WEEKENDS
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    MIN_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    SUM(INTERVAL_SECONDS) OVER () TOTAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2,
      BASIS_INFO BI
    WHERE
      BI.DBID = HSS2.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      BI.INSTANCE_NUMBER = HSS2.INSTANCE_NUMBER AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  )
),
INTERVAL_SECONDS AS
( SELECT
    DECODE(BI.AGGREGATE_BY,
      'SNAPSHOT', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
      'DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
      'HOUR_OF_DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'HH24') || ':00') BEGIN_TIME,
    SUM(SS.INTERVAL_SECONDS) SECONDS
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS
  GROUP BY
    DECODE(BI.AGGREGATE_BY,
      'SNAPSHOT', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
      'DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
      'HOUR_OF_DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'HH24') || ':00')
)
SELECT
  'BEGIN TIME:' BEGIN_TIME,
  TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'dd.mm.yyyy') TOTAL_VALUE,
  TO_CHAR(MIN(BEGIN_INTERVAL_TIME), 'hh24:mi:ss') VALUE_PER_S,
  NULL SEGMENT_1,
  NULL VALUE_1,
  NULL "%_1",
  NULL SEGMENT_2,
  NULL VALUE_2,
  NULL "%_2",
  NULL SEGMENT_3,
  NULL VALUE_3,
  NULL "%_3",
  NULL SEGMENT_4,
  NULL VALUE_4,
  NULL "%_4",
  NULL SEGMENT_5,
  NULL VALUE_5,
  NULL "%_5"
FROM
  SNAPSHOTS
WHERE
  SNAP_ID != MIN_SNAP_ID
UNION ALL
( SELECT
    'END TIME:' BEGIN_TIME,
    TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy') TOTAL_VALUE,
    TO_CHAR(MAX(END_INTERVAL_TIME), 'hh24:mi:ss') VALUE_PER_S,
    NULL SEGMENT_1,
    NULL VALUE_1,
    NULL "%_1",
    NULL SEGMENT_2,
    NULL VALUE_2,
    NULL "%_2",
    NULL SEGMENT_3,
    NULL VALUE_3,
    NULL "%_3",
    NULL SEGMENT_4,
    NULL VALUE_4,
    NULL "%_4",
    NULL SEGMENT_5,
    NULL VALUE_5,
    NULL "%_5"
  FROM
    SNAPSHOTS
)
UNION ALL
( SELECT
    'STAT NAME:' BEGIN_TIME,
    STAT_NAME TOTAL_VALUE,
    NULL VALUE_PER_S,
    NULL SEGMENT_1,
    NULL VALUE_1,
    NULL "%_1",
    NULL SEGMENT_2,
    NULL VALUE_2,
    NULL "%_2",
    NULL SEGMENT_3,
    NULL VALUE_3,
    NULL "%_3",
    NULL SEGMENT_4,
    NULL VALUE_4,
    NULL "%_4",
    NULL SEGMENT_5,
    NULL VALUE_5,
    NULL "%_5"
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'AGGREGATED BY:' BEGIN_TIME,
    AGGREGATE_BY TOTAL_VALUE,
    NULL VALUE_PER_S,
    NULL SEGMENT_1,
    NULL VALUE_1,
    NULL "%_1",
    NULL SEGMENT_2,
    NULL VALUE_2,
    NULL "%_2",
    NULL SEGMENT_3,
    NULL VALUE_3,
    NULL "%_3",
    NULL SEGMENT_4,
    NULL VALUE_4,
    NULL "%_4",
    NULL SEGMENT_5,
    NULL VALUE_5,
    NULL "%_5"
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'WEEKENDS EXCLUDED:' BEGIN_TIME,
    DECODE(EXCLUDE_WEEKENDS, 'X', 'YES', 'NO') TOTAL_VALUE,
    NULL VALUE_PER_S,
    NULL SEGMENT_1,
    NULL VALUE_1,
    NULL "%_1",
    NULL SEGMENT_2,
    NULL VALUE_2,
    NULL "%_2",
    NULL SEGMENT_3,
    NULL VALUE_3,
    NULL "%_3",
    NULL SEGMENT_4,
    NULL VALUE_4,
    NULL "%_4",
    NULL SEGMENT_5,
    NULL VALUE_5,
    NULL "%_5"
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL TOTAL_VALUE,
    NULL VALUE_PER_S,
    NULL SEGMENT_1,
    NULL VALUE_1,
    NULL "%_1",
    NULL SEGMENT_2,
    NULL VALUE_2,
    NULL "%_2",
    NULL SEGMENT_3,
    NULL VALUE_3,
    NULL "%_3",
    NULL SEGMENT_4,
    NULL VALUE_4,
    NULL "%_4",
    NULL SEGMENT_5,
    NULL VALUE_5,
    NULL "%_5"
  FROM
    DUAL
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT 
      BEGIN_TIME,
      LPAD(TOTAL_VALUE, GREATEST(11, LENGTH(STAT_NAME))) TOTAL_VALUE,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SEGMENT_1,
      TO_CHAR(VALUE_1, 99999999990) VALUE_1,
      TO_CHAR(DECODE(TOTAL_VALUE, 0, 0, VALUE_1 / TOTAL_VALUE * 100), 990) "%_1",
      SEGMENT_2,
      TO_CHAR(VALUE_2, 99999999990) VALUE_2,
      TO_CHAR(DECODE(TOTAL_VALUE, 0, 0, VALUE_2 / TOTAL_VALUE * 100), 990) "%_2",
      SEGMENT_3,
      TO_CHAR(VALUE_3, 99999999990) VALUE_3,
      TO_CHAR(DECODE(TOTAL_VALUE, 0, 0, VALUE_3 / TOTAL_VALUE * 100), 990) "%_3",
      SEGMENT_4,
      TO_CHAR(VALUE_4, 99999999990) VALUE_4,
      TO_CHAR(DECODE(TOTAL_VALUE, 0, 0, VALUE_4 / TOTAL_VALUE * 100), 990) "%_4",
      SEGMENT_5,
      TO_CHAR(VALUE_5, 99999999990) VALUE_5,
      TO_CHAR(DECODE(TOTAL_VALUE, 0, 0, VALUE_5 / TOTAL_VALUE * 100), 990) "%_5"
    FROM
    ( SELECT DISTINCT
        SS.BEGIN_TIME,
        STAT_NAME,
        SUM(VALUE) OVER (PARTITION BY SS.BEGIN_TIME) TOTAL_VALUE,
        SUM(VALUE) OVER (PARTITION BY SS.BEGIN_TIME) / INS.SECONDS VALUE_PER_S,
        NTH_VALUE(SEGMENT_NAME, 1) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SEGMENT_1,
        NTH_VALUE(VALUE, 1) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SEGMENT_NAME, 2) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SEGMENT_2,
        NTH_VALUE(VALUE, 2) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SEGMENT_NAME, 3) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SEGMENT_3,
        NTH_VALUE(VALUE, 3) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SEGMENT_NAME, 4) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SEGMENT_4,
        NTH_VALUE(VALUE, 4) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SEGMENT_NAME, 5) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SEGMENT_5,
        NTH_VALUE(VALUE, 5) OVER (PARTITION BY SS.BEGIN_TIME ORDER BY VALUE DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5
      FROM
      ( SELECT
          DECODE(BI.AGGREGATE_BY,
            'SNAPSHOT', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
            'DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
            'HOUR_OF_DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'HH24') || ':00') BEGIN_TIME,
          BI.STAT_NAME,
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, NVL(SSO.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#))) SEGMENT_NAME,
          SUM(DECODE(BI.STAT_NAME, 
            'Physical Reads',         PHYSICAL_READS_DELTA, 
            'Logical Reads',          LOGICAL_READS_DELTA,
            'Buffer Busy Waits',      BUFFER_BUSY_WAITS_DELTA,
            'DB Block Changes',       DB_BLOCK_CHANGES_DELTA,
            'Physical Writes',        PHYSICAL_WRITES_DELTA,
            'Physical Reads Direct',  PHYSICAL_READS_DIRECT_DELTA,
            'Physical Writes Direct', PHYSICAL_WRITES_DIRECT_DELTA,
            'ITL Waits',              ITL_WAITS_DELTA,
            'Row Lock Waits',         ROW_LOCK_WAITS_DELTA,
            'GC CR Blocks Served',    GC_CR_BLOCKS_SERVED_DELTA,
            'GC CU Blocks Served',    GC_CU_BLOCKS_SERVED_DELTA,
            'GC Buffer Busy',         GC_BUFFER_BUSY_DELTA,
            'GC CR Blocks Received',  GC_CR_BLOCKS_RECEIVED_DELTA,
            'GC CU Blocks Received',  GC_CU_BLOCKS_RECEIVED_DELTA,
            'Space Used',             SPACE_USED_DELTA,
            'Space Allocated',        SPACE_ALLOCATED_DELTA,
            'Table Scans',            TABLE_SCANS_DELTA,
            0)) VALUE
        FROM
          BASIS_INFO BI,
          DBA_HIST_SEG_STAT S,
          DBA_HIST_SEG_STAT_OBJ SSO,
          DBA_OBJECTS O,
          DBA_OBJECTS O2,
          SNAPSHOTS SS
        WHERE
          S.DBID = SS.DBID AND
          S.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
          S.SNAP_ID = SS.SNAP_ID AND
          SS.SNAP_ID != SS.MIN_SNAP_ID AND
          S.OBJ# = O.OBJECT_ID (+) AND
          S.DATAOBJ# = O.DATA_OBJECT_ID (+) AND
          S.OBJ# = SSO.OBJ# (+) AND
          S.DATAOBJ# = SSO.DATAOBJ# (+) AND
          S.OBJ# = O2.OBJECT_ID (+) AND
          ( BI.EXCLUDE_WEEKENDS = ' ' OR 
            TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'D') NOT IN (7, 1) )
        GROUP BY
          DECODE(BI.AGGREGATE_BY,
            'SNAPSHOT', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
            'DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
            'HOUR_OF_DAY', TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'HH24') || ':00'),
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, NVL(SSO.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#))),
          BI.STAT_NAME
      ) SS,
        INTERVAL_SECONDS INS
      WHERE
        SS.BEGIN_TIME = INS.BEGIN_TIME
      GROUP BY
        SS.BEGIN_TIME,
        SS.STAT_NAME,
        SS.VALUE,
        INS.SECONDS,
        SS.SEGMENT_NAME
    )
    ORDER BY
      BEGIN_TIME DESC
  )
)
))]]></sql>
				<binds>
					<bind id="STAT_NAME">
						<prompt><![CDATA[STAT_NAME]]></prompt>
						<tooltip><![CDATA[STAT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="AGGREGATE_BY">
						<prompt><![CDATA[AGGREGATE_BY]]></prompt>
						<tooltip><![CDATA[AGGREGATE_BY]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Space]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2ce997e5-014d-1000-8034-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_ChainedRows_SegmentStatistics_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL TABLE_NAME, NULL PART_NAME, NULL TOTAL_ROWS,
  NULL CHAINED_ROWS, NULL "CHAIN_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TABLE_NAME, NULL PART_NAME, NULL TOTAL_ROWS,
  NULL CHAINED_ROWS, NULL "CHAIN_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    OWNER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    MIN_CHAINED_ROW_THRESHOLD
  FROM
  ( SELECT
      '%' OWNER,
      TO_DATE('01.01.1000 14:27:44', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 14:37:26', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 MIN_CHAINED_ROW_THRESHOLD
    FROM
      DUAL
  )
),
SNAPSHOTS AS
( SELECT 
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MAX(HSS.SNAP_ID) END_SNAP_ID
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  OWNER,
  TABLE_NAME,
  PART_NAME,
  TO_CHAR(TOTAL_ROWS, 9999999999999990) TOTAL_ROWS,
  TO_CHAR(CHAINED_ROWS, 999999999999999999990) CHAINED_ROWS,
  TO_CHAR(DECODE(TOTAL_ROWS, 0, 0, CHAINED_ROWS / TOTAL_ROWS * 100), 9999999999999990.99) "CHAIN_%"
FROM
( SELECT
    SSO.OWNER,
    SSO.OBJECT_NAME TABLE_NAME,
    SSO.SUBOBJECT_NAME PART_NAME,
    NVL(T.NUM_ROWS, 0) TOTAL_ROWS,
    MAX(HSS.CHAIN_ROW_EXCESS_TOTAL) CHAINED_ROWS,
    BI.MIN_CHAINED_ROW_THRESHOLD
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS,
    DBA_HIST_SEG_STAT HSS,
    DBA_HIST_SEG_STAT_OBJ SSO,
    DBA_TABLES T
  WHERE
    HSS.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
    SSO.OWNER LIKE BI.OWNER AND
    HSS.OBJ# = SSO.OBJ# AND
    HSS.DATAOBJ# = SSO.DATAOBJ# AND
    SSO.OWNER = T.OWNER AND
    SSO.OBJECT_NAME = T.TABLE_NAME 
  GROUP BY
    SSO.OWNER,
    SSO.OBJECT_NAME,
    SSO.SUBOBJECT_NAME,
    T.NUM_ROWS,
    BI.MIN_CHAINED_ROW_THRESHOLD
)
WHERE
  ( MIN_CHAINED_ROW_THRESHOLD = -1 AND CHAINED_ROWS > 0 OR
    MIN_CHAINED_ROW_THRESHOLD >= 0 AND CHAINED_ROWS >= MIN_CHAINED_ROW_THRESHOLD )
ORDER BY
  CHAINED_ROWS DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cf66820-014d-1000-8035-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_Datafiles_ExtentsAtTheEnd]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL FILE_NAME, NULL FILE_ID, NULL FILESIZE_MB, 
  NULL FREE_MB_0, NULL SEGMENT_NAME_1, NULL EXTSIZE_MB_1, 
  NULL FREE_MB_1, NULL SEGMENT_NAME_2, NULL EXTSIZE_MB_2, 
  NULL FREE_MB_2, NULL SEGMENT_NAME_3, NULL EXTSIZE_MB_3,
  NULL RESIZE_COMMAND
FROM DUAL WHERE 1 = 0
UNION ALL ( 
SELECT NULL FILE_NAME, NULL FILE_ID, NULL FILESIZE_MB, 
  NULL FREE_MB_0, NULL SEGMENT_NAME_1, NULL EXTSIZE_MB_1, 
  NULL FREE_MB_1, NULL SEGMENT_NAME_2, NULL EXTSIZE_MB_2, 
  NULL FREE_MB_2, NULL SEGMENT_NAME_3, NULL EXTSIZE_MB_3,
  NULL RESIZE_COMMAND
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
SELECT
  FILE_NAME,
  TO_CHAR(FILE_ID, 999990) FILE_ID,
  TO_CHAR(FILE_BLOCKS * 8192 / 1024 / 1024, 9999990.99) FILESIZE_MB,
  TO_CHAR((FILE_BLOCKS - NVL(END_BLOCK_1, 0)) * 8192 / 1024 / 1024, 99990.99) FREE_MB_0,
  SEGMENT_NAME_1,
  TO_CHAR((END_BLOCK_1 - START_BLOCK_1 + 1) * 8192 / 1024 / 1024, 99999990.99) EXTSIZE_MB_1,
  TO_CHAR((FILE_BLOCKS - NVL(END_BLOCK_2, 0)) * 8192 / 1024 / 1024, 99990.99) FREE_MB_1,
  SEGMENT_NAME_2,
  TO_CHAR((END_BLOCK_2 - START_BLOCK_2 + 1) * 8192 / 1024 / 1024, 99999990.99) EXTSIZE_MB_2,
  TO_CHAR((FILE_BLOCKS - NVL(END_BLOCK_3, 0)) * 8192 / 1024 / 1024, 99990.99) FREE_MB_2,
  SEGMENT_NAME_3,
  TO_CHAR((END_BLOCK_3 - START_BLOCK_3 + 1) * 8192 / 1024 / 1024, 99999990.99) EXTSIZE_MB_3,
  'ALTER DATABASE DATAFILE ' || FILE_ID || ' RESIZE ' || 
    NVL(END_BLOCK_1, 0) * 8192 || ';' RESIZE_COMMAND
FROM
( SELECT
    FILE_NAME,
    FILE_ID,
    FILE_BLOCKS,
    SEGMENT_NAME SEGMENT_NAME_1,
    START_BLOCK START_BLOCK_1,
    END_BLOCK END_BLOCK_1,
    LEAD(SEGMENT_NAME, 1) OVER
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) SEGMENT_NAME_2,
    LEAD(START_BLOCK, 1) OVER 
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) START_BLOCK_2,
    LEAD(END_BLOCK, 1) OVER 
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) END_BLOCK_2,
    LEAD(SEGMENT_NAME, 2) OVER
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) SEGMENT_NAME_3,
    LEAD(START_BLOCK, 2) OVER 
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) START_BLOCK_3,
    LEAD(END_BLOCK, 2) OVER 
      (PARTITION BY FILE_NAME ORDER BY START_BLOCK DESC) END_BLOCK_3,
    POSITION
  FROM
  ( SELECT
      FILE_NAME,
      FILE_ID,
      FILE_BLOCKS,
      SEGMENT_NAME,
      BLOCK_ID START_BLOCK,
      BLOCK_ID + BLOCKS - 1 END_BLOCK,
      POSITION
    FROM
    ( SELECT DISTINCT
        DDF.FILE_NAME,
        DDF.FILE_ID,
        DDF.BLOCKS FILE_BLOCKS,
        DE.SEGMENT_NAME,
        DE.BLOCK_ID,
        DE.BLOCKS,
        ROW_NUMBER() OVER (PARTITION BY DDF.FILE_NAME ORDER BY DE.BLOCK_ID DESC) POSITION
      FROM
        DBA_DATA_FILES DDF,
        DBA_EXTENTS DE
      WHERE
        DDF.FILE_ID = DE.FILE_ID (+)
    )
    WHERE
      POSITION < = 3  
  )
)
WHERE
  POSITION = 1
ORDER BY
  FILE_ID
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cf844c6-014d-1000-8036-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_Datafiles_FreespaceAtTheEnd]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TABLESPACE_NAME, NULL FILE_NAME, NULL FREESPACE_AREAS_AT_END,
  NULL FREESPACE_AT_END_MB, NULL RESIZE_COMMAND FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TABLESPACE_NAME, NULL FILE_NAME, NULL FREESPACE_AREAS_AT_END,
  NULL FREESPACE_AT_END_MB, NULL RESIZE_COMMAND FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:TABLESPACE_NAME,'%') TABLESPACE_NAME,
    NVL(:DATAFILE_NAME,'%') DATAFILE_NAME,
    NVL(:MIN_FREESPACE_MB,100) MIN_FREESPACE_MB,
    'FREESPACE' ORDER_BY    /* FREESPACE, FILENAME, TABLESPACE */
  FROM
    DUAL
)
SELECT
  TABLESPACE_NAME,
  FILE_NAME,
  TO_CHAR(FREESPACE_AREAS_AT_END, 999999999999999999990) FREESPACE_AREAS_AT_END,
  TO_CHAR(FREESPACE_AT_END_MB, 999999999999990.99) FREESPACE_AT_END_MB,
  'ALTER DATABASE DATAFILE ' || FILE_ID || ' RESIZE ' || MIN_RESIZE_BYTE || ';' RESIZE_COMMAND
FROM
( SELECT
    TABLESPACE_NAME,
    FILE_NAME,
    FILE_ID,
    COUNT(*) FREESPACE_AREAS_AT_END,
    (MAX(END_OF_FRAGMENT) - MIN(START_OF_FRAGMENT)) / 1024 / 1024 FREESPACE_AT_END_MB,
    MIN(START_OF_FRAGMENT) MIN_RESIZE_BYTE,
    ORDER_BY,
    MIN_FREESPACE_MB
  FROM
  ( SELECT
      TS.TABLESPACE_NAME,
      DF.FILE_NAME,
      DF.FILE_ID,
      TS.BLOCK_SIZE * FS.BLOCK_ID START_OF_FRAGMENT,
      TS.BLOCK_SIZE * (FS.BLOCK_ID + FS.BLOCKS) END_OF_FRAGMENT,
      BI.ORDER_BY,
      BI.MIN_FREESPACE_MB
    FROM
      BASIS_INFO BI,
      DBA_FREE_SPACE FS,
      DBA_DATA_FILES DF,
      DBA_TABLESPACES TS
    WHERE
      FS.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      DF.FILE_NAME LIKE BI.DATAFILE_NAME AND
      DF.FILE_ID = FS.FILE_ID AND
      DF.TABLESPACE_NAME = TS.TABLESPACE_NAME
    CONNECT BY 
      PRIOR FS.BLOCK_ID = FS.BLOCK_ID + FS.BLOCKS AND
      PRIOR FS.FILE_ID = FS.FILE_ID
      START WITH
        (FS.BLOCK_ID + FS.BLOCKS - 1) * TS.BLOCK_SIZE = DF.BYTES 
  )
  GROUP BY
    MIN_FREESPACE_MB,
    ORDER_BY,
    TABLESPACE_NAME,
    FILE_NAME,
    FILE_ID
)
WHERE
  FREESPACE_AT_END_MB >= MIN_FREESPACE_MB
ORDER BY
  DECODE(ORDER_BY, 'FREESPACE', FREESPACE_AT_END_MB, 1) DESC,
  DECODE(ORDER_BY, 'FILENAME', FILE_NAME, 'TABLESPACE', TABLESPACE_NAME)
))]]></sql>
				<binds>
					<bind id="TABLESPACE_NAME">
						<prompt><![CDATA[TABLESPACE_NAME]]></prompt>
						<tooltip><![CDATA[TABLESPACE_NAME]]></tooltip>
						<value><![CDATA[SIEBEL_TBL]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="DATAFILE_NAME">
						<prompt><![CDATA[DATAFILE_NAME]]></prompt>
						<tooltip><![CDATA[DATAFILE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="MIN_FREESPACE_MB">
						<prompt><![CDATA[MIN_FREESPACE_MB]]></prompt>
						<tooltip><![CDATA[MIN_FREESPACE_MB]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cf9041f-014d-1000-8037-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_Datafiles_HighAutoextendIncrement]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TABLESPACE_NAME, NULL DATAFILE_NAME, NULL INCREMENT_BY_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TABLESPACE_NAME, NULL DATAFILE_NAME, NULL INCREMENT_BY_MB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    100 LOWER_INCREMENT_LIMIT_MB
  FROM
    DUAL
)
SELECT
  DF.TABLESPACE_NAME,
  DF.FILE_NAME DATAFILE_NAME,
  TO_CHAR(DF.INCREMENT_BY * TS.BLOCK_SIZE / 1024 / 1024, 99999999990.99) INCREMENT_BY_MB
FROM
  BASIS_INFO BI,
  DBA_DATA_FILES DF,
  DBA_TABLESPACES TS
WHERE
  DF.INCREMENT_BY * TS.BLOCK_SIZE / 1024 / 1024 > LOWER_INCREMENT_LIMIT_MB AND
  DF.TABLESPACE_NAME = TS.TABLESPACE_NAME
ORDER BY
  TABLESPACE_NAME,
  DATAFILE_NAME
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cfaba95-014d-1000-8038-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_FreespaceFragmentsInTablespace]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL FRAGMENT_SIZE_MB, NULL FRAGMENTS, NULL TOTAL_SIZE_GB,
  NULL "TOTAL_SIZE_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL FRAGMENT_SIZE_MB, NULL FRAGMENTS, NULL TOTAL_SIZE_GB,
  NULL "TOTAL_SIZE_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:TABLESPACE_NAME,'GENUSER') TABLESPACE_NAME
  FROM
    DUAL
)
SELECT
  TO_CHAR(BYTES / 1024 / 1024, 999999999990.99) FRAGMENT_SIZE_MB,
  TO_CHAR(COUNT(*), 99999990) FRAGMENTS,
  TO_CHAR(SUM(BYTES) / 1024 / 1024 / 1024, 999999990.99) TOTAL_SIZE_GB,
  TO_CHAR(RATIO_TO_REPORT(SUM(BYTES)) OVER () * 100, 99999990.99) "TOTAL_SIZE_%"
FROM
  BASIS_INFO BI,
  DBA_FREE_SPACE FS
WHERE 
  FS.TABLESPACE_NAME = BI.TABLESPACE_NAME
GROUP BY
  BYTES
ORDER BY 
  BYTES
))]]></sql>
				<binds>
					<bind id="TABLESPACE_NAME">
						<prompt><![CDATA[TABLESPACE_NAME]]></prompt>
						<tooltip><![CDATA[TABLESPACE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cfbf4c5-014d-1000-8039-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_GrowthOfSegmentInHistory]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL UNUSED_MB, NULL "QUALITY_%", NULL GROSS_MB,
  NULL NET_MB, NULL GROSS_DELTA_MB, NULL NET_DELTA_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL UNUSED_MB, NULL "QUALITY_%", NULL GROSS_MB,
  NULL NET_MB, NULL GROSS_DELTA_MB, NULL NET_DELTA_MB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SEGMENT_NAME,
    PARTITION_NAME,
    DECODE(B.INSTANCE_NUMBER, -1, I.INSTANCE_NUMBER) INSTANCE_NUMBER
  FROM
  ( SELECT
      TO_DATE('01.01.1000 18:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      NVL(:SEGMENT_NAME,'S_USER') SEGMENT_NAME,
      '%' PARTITION_NAME,
      -1 INSTANCE_NUMBER
    FROM
      DUAL
  ) B,
  ( SELECT INSTANCE_NUMBER FROM V$INSTANCE ) I
),
SNAPSHOTS AS
( SELECT 
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.INSTANCE_NUMBER
)
SELECT
  TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
  TO_CHAR((SPACE_ALLOC_TOTAL - SPACE_USED_TOTAL) / 1024 / 1024, 9999990.99) UNUSED_MB,
  TO_CHAR(DECODE(SPACE_ALLOC_TOTAL, 0, 0, SPACE_USED_TOTAL / 
    SPACE_ALLOC_TOTAL) * 100, 99990.99) "QUALITY_%",
  TO_CHAR(SPACE_ALLOC_TOTAL / 1024 / 1024, 9999990.99) GROSS_MB,
  TO_CHAR(SPACE_USED_TOTAL / 1024 / 1024, 999990.99) NET_MB,
  TO_CHAR(SPACE_ALLOC_DELTA / 1024 / 1024, 9999999990.99) GROSS_DELTA_MB,
  TO_CHAR(SPACE_USED_DELTA / 1024 / 1024, 99999990.99) NET_DELTA_MB
FROM
( SELECT
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    SUM(SS.SPACE_USED_TOTAL) SPACE_USED_TOTAL,
    SUM(SS.SPACE_USED_DELTA) SPACE_USED_DELTA,
    SUM(SS.SPACE_ALLOCATED_TOTAL) SPACE_ALLOC_TOTAL,
    SUM(SS.SPACE_ALLOCATED_DELTA) SPACE_ALLOC_DELTA
  FROM
    BASIS_INFO BI,
    SNAPSHOTS S,
    DBA_HIST_SNAPSHOT HSS,
    DBA_HIST_SEG_STAT SS,
    DBA_HIST_SEG_STAT_OBJ SSO
  WHERE
    SSO.OBJECT_NAME = BI.SEGMENT_NAME AND
    NVL(SSO.SUBOBJECT_NAME, ' ') LIKE BI.PARTITION_NAME AND
    HSS.SNAP_ID BETWEEN S.BEGIN_SNAP_ID AND S.END_SNAP_ID AND
    SS.SNAP_ID = HSS.SNAP_ID AND
    SSO.OBJ# = SS.OBJ# AND
    SSO.DATAOBJ# = SS.DATAOBJ#
  GROUP BY
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME
)
ORDER BY
  SNAP_ID DESC
))]]></sql>
				<binds>
					<bind id="SEGMENT_NAME">
						<prompt><![CDATA[SEGMENT_NAME]]></prompt>
						<tooltip><![CDATA[SEGMENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2cff4993-014d-1000-803a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_HighWaterMarkFragmentation]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL OWNER, NULL SEGMENT_NAME, NULL SEGMENT_TYPE, NULL INITIAL_EXTENT_MB, 
  NULL SEGMENT_SIZE_MB, NULL HIGH_WATER_MARK_MB, NULL WASTED_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL SEGMENT_NAME, NULL SEGMENT_TYPE, NULL INITIAL_EXTENT_MB, 
  NULL SEGMENT_SIZE_MB, NULL HIGH_WATER_MARK_MB, NULL WASTED_MB FROM DUAL WHERE 1 = 0
) UNION ALL (SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    NVL(:TABLE_NAME,'S_USER') TABLE_NAME,
    100 WASTED_MB_THRESHOLD,
    5 BRANCH_BLOCK_OVERHEAD_PCT,
    'X' INITIAL_GREATER_THAN_HWM
  FROM
    DUAL
)
SELECT
  OWNER,
  SEGMENT_NAME,
  SEGMENT_TYPE,
  TO_CHAR(INITIAL_EXTENT_MB, 9999999999990.99) INITIAL_EXTENT_MB,
  TO_CHAR(SEGMENT_SIZE_MB, 99999999990.99) SEGMENT_SIZE_MB,
  TO_CHAR(HIGH_WATER_MARK_MB, 99999999999990.99) HIGH_WATER_MARK_MB,
  TO_CHAR(WASTED_MB, 99990.99) WASTED_MB
FROM
( SELECT
    T.OWNER OWNER,
    T.TABLE_NAME SEGMENT_NAME,
    'TABLE' SEGMENT_TYPE,
    T.INITIAL_EXTENT / 1024 / 1024 INITIAL_EXTENT_MB,
    T.NEXT_EXTENT / 1024 / 1024 NEXT_EXTENT_MB,
    S.BLOCKS * 8192 / 1024 / 1024 SEGMENT_SIZE_MB,
    T.BLOCKS * 8192 / 1024 / 1024 HIGH_WATER_MARK_MB,
    (S.BLOCKS - T.BLOCKS) * 8192 / 1024 / 1024 WASTED_MB,
    BI.WASTED_MB_THRESHOLD
  FROM
    BASIS_INFO BI,
    DBA_TABLES T, 
    DBA_SEGMENTS S
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.TABLE_NAME LIKE BI.TABLE_NAME AND
    T.OWNER = S.OWNER AND
    T.TABLE_NAME = S.SEGMENT_NAME AND
    ( BI.INITIAL_GREATER_THAN_HWM = ' ' OR
      T.INITIAL_EXTENT > T.BLOCKS * 8192 AND S.BYTES < T.INITIAL_EXTENT + 10 * 1024 * 1024 )
  UNION ALL
  ( SELECT
      I.OWNER OWNER,
      I.INDEX_NAME SEGMENT_NAME,
      'INDEX' SEGMENT_TYPE,
      I.INITIAL_EXTENT / 1024 / 1024 INITIAL_EXTENT_MB,
      I.NEXT_EXTENT / 1024 / 1024 NEXT_EXTENT_MB,
      S.BLOCKS * 8192 / 1024 / 1024 SEGMENT_SIZE_MB,
      I.LEAF_BLOCKS * (1 + BI.BRANCH_BLOCK_OVERHEAD_PCT / 100 ) * 8192 / 1024 / 1024 HIGH_WATER_MARK_MB,
      (S.BLOCKS - I.LEAF_BLOCKS * (1 + BI.BRANCH_BLOCK_OVERHEAD_PCT / 100 )) * 8192 / 1024 / 1024 WASTED_MB,
      BI.WASTED_MB_THRESHOLD
    FROM
      BASIS_INFO BI,
      DBA_INDEXES I, 
      DBA_SEGMENTS S
    WHERE
      I.OWNER LIKE BI.OWNER AND
      I.TABLE_NAME LIKE BI.TABLE_NAME AND
      I.OWNER = S.OWNER AND
      I.INDEX_NAME = S.SEGMENT_NAME AND
      ( BI.INITIAL_GREATER_THAN_HWM = ' ' OR
        I.INITIAL_EXTENT > I.LEAF_BLOCKS * (1 + BI.BRANCH_BLOCK_OVERHEAD_PCT / 100 ) * 8192 AND 
          S.BYTES < I.INITIAL_EXTENT + 10 * 1024 * 1024 )
  )
)
WHERE
  WASTED_MB >= WASTED_MB_THRESHOLD
ORDER BY
  WASTED_MB DESC
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d040b81-014d-1000-803b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_LargestTables]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_OPTIMIZER_DISTINCT_AGG_TRANSFORM', 'FALSE') */ 
  NULL OWNER, NULL TABLE_NAME, NULL B, NULL POS, NULL TOTAL_GB, NULL "TOTAL_%", NULL "CUM_%", NULL "PART.",
  NULL TABLE_GB, NULL TAB_TABSPACE, NULL "IND.", NULL INDEX_GB,
  NULL IND_TABSPACE, NULL LOBS, NULL LOB_GB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL OWNER, NULL TABLE_NAME, NULL B, NULL POS, NULL TOTAL_GB, NULL "TOTAL_%", NULL "CUM_%", NULL "PART.",
  NULL TABLE_GB, NULL TAB_TABSPACE, NULL "IND.", NULL INDEX_GB,
  NULL IND_TABSPACE, NULL LOBS, NULL LOB_GB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    '%' TABLESPACE_NAME,
    '%' TABLE_NAME,
    100 NUM_RECORDS,
    -1 MIN_TOTAL_SIZE_MB,
    ' ' ONLY_BASIS_TABLES
  FROM
    DUAL
),
SEGMENTS AS
( SELECT /*+ MATERIALIZE */
    S.OWNER,
    S.SEGMENT_NAME,
    S.PARTITION_NAME,
    S.SEGMENT_TYPE,
    S.TABLESPACE_NAME,
    S.BYTES
  FROM
    BASIS_INFO BI,
    DBA_SEGMENTS S
  WHERE
    S.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME
),
TOTAL_SEGMENT_SIZE AS
( SELECT /*+ MATERIALIZE */
    SUM(BYTES) DB_NET_SIZE_BYTE
  FROM
    SEGMENTS
),
INDEXES AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    TABLE_NAME,
    INDEX_NAME,
    TABLESPACE_NAME
  FROM
    DBA_INDEXES
),
LOBS AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    TABLE_NAME,
    SEGMENT_NAME,
    TABLESPACE_NAME, 
    INDEX_NAME,
    COLUMN_NAME
  FROM
    DBA_LOBS
),
TABLE_SEGMENT_MAPPING AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    SEGMENT_NAME TABLE_NAME,
    MIN(TABLESPACE_NAME) TABLESPACE_NAME,
    'TABLE' SEGMENT_TYPE,
    1 SEGMENTS,
    SUM(DECODE(PARTITION_NAME, NULL, 0, 1)) PARTITIONS,
    SUM(BYTES) BYTES
  FROM
    SEGMENTS
  WHERE
    SEGMENT_TYPE IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
  GROUP BY
    OWNER,
    SEGMENT_NAME
  UNION ALL
  ( SELECT
      I.OWNER OWNER,
      I.TABLE_NAME TABLE_NAME,
      MIN(S.TABLESPACE_NAME) TABLESPACE_NAME,
      'INDEX' SEGMENT_TYPE,
      COUNT(DISTINCT(I.INDEX_NAME)) SEGMENTS,
      SUM(DECODE(S.PARTITION_NAME, NULL, 0, 1)) PARTITIONS,
      SUM(S.BYTES) BYTES
    FROM
      SEGMENTS S,
      INDEXES I
    WHERE
      S.OWNER = I.OWNER AND
      S.SEGMENT_NAME = I.INDEX_NAME AND
      S.SEGMENT_TYPE IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
    GROUP BY
      I.OWNER,
      I.TABLE_NAME
  )
  UNION ALL
  ( SELECT
      L.OWNER OWNER,
      L.TABLE_NAME TABLE_NAME,
      MIN(S.TABLESPACE_NAME) TABLESPACE_NAME,
      'LOB' SEGMENT_TYPE,
      COUNT(DISTINCT(L.COLUMN_NAME)) SEGMENTS,
      SUM(DECODE(S.PARTITION_NAME, NULL, 0, 1)) PARTITIONS,
      SUM(S.BYTES) BYTES
    FROM
      SEGMENTS S,
      LOBS L
    WHERE
      S.OWNER = L.OWNER AND
      S.SEGMENT_NAME IN ( L.SEGMENT_NAME, L.INDEX_NAME ) AND
      S.SEGMENT_TYPE IN ('LOBSEGMENT', 'LOBINDEX', 'LOB PARTITION')
    GROUP BY
      L.OWNER,
      L.TABLE_NAME
  )
),
BASIS_TABLES AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    TABLE_NAME
  FROM
    DBA_TABLES
  WHERE
    TABLE_NAME IN
    ( 'BALHDR', 'BALHDRP', 'BALM', 'BALMP', 'BALDAT', 'BALC', 
      'BAL_INDX', 'EDIDS', 'EDIDC', 'EDIDOC', 'EDI30C', 'EDI40',
      'IDOCREL', 'SRRELROLES', 'SWFGPROLEINST', 'SWP_HEADER', 'SWP_NODEWI', 'SWPNODE',
      'SWPNODELOG', 'SWPSTEPLOG', 'SWW_CONT', 'SWW_CONTOB', 'SWW_WI2OBJ', 'SWWCNTP0',
      'SWWCNTPADD', 'SWWEI', 'SWWLOGHIST', 'SWWLOGPARA', 'SWWWIDEADL', 'SWWWIHEAD', 
      'SWWWIRET', 'SWZAI', 'SWZAIENTRY', 'SWZAIRET', 'SWWUSERWI',                  
      'BDCP', 'BDCPS', 'BDCP2', 'DBTABLOG', 'DBTABPRT', 
      'ARFCSSTATE', 'ARFCSDATA', 'ARFCRSTATE', 'TRFCQDATA',
      'TRFCQIN', 'TRFCQOUT', 'TRFCQSTATE', 'SDBAH', 'SDBAD', 'DBMSGORA', 'DDLOG',
      'APQD', 'TST01', 'TST03', 'TSPEVJOB', 'TXMILOGRAW', 'TSPEVDEV', 
      'SNAP', 'SMO8FTCFG', 'SMO8FTSTP', 'SMO8_TMSG', 'SMO8_TMDAT', 
      'SMO8_DLIST', 'SMW3_BDOC', 'SMW3_BDOC1', 'SMW3_BDOC2', 
      'SMW3_BDOC4', 'SMW3_BDOC5', 'SMW3_BDOC6', 'SMW3_BDOC7', 'SMW3_BDOCQ', 'SMWT_TRC',
      'TPRI_PAR', 'RSMONMESS', 'RSSELDONE', 'VBDATA', 'VBMOD', 'VBHDR', 'VBERROR',
      'VDCHGPTR', 'JBDCPHDR2', 'JBDCPPOS2', 'SWELOG', 'SWELTS', 'SWFREVTLOG',
      'ARDB_STAT0', 'ARDB_STAT1', 'ARDB_STAT2', 'QRFCTRACE', 'QRFCLOG',
      'DDPRS', 'TBTCO', 'TBTCP', 'MDMFDBEVENT', 'MDMFDBID', 'MDMFDBPR',
      'RSRWBSTORE', '"/SAPAPO/LISMAP"', '"/SAPAPO/LISLOG"', 
      'CCMLOG', 'CCMLOGD', 'CCMSESSION', 'CCMOBJLST', 'CCMOBJKEYS',
      'SXMSPMAST', 'SXMSPMAST2', 'SXMSPHIST', 'RSBATCHDATA',
      'SXMSPHIST2', 'SXMSPFRAWH', 'SXMSPFRAWD', 'SXMSCLUR', 'SXMSCLUR2', 'SXMSCLUP',
      'SXMSCLUP2', 'SWFRXIHDR', 'SWFRXICNT', 'SWFRXIPRC', 'XI_AF_MSG', 
      'XI_AF_MSG_AUDIT', 'SMW0REL', 'SRRELROLES', 'COIX_DATA40', 'T811E', 'T811ED', 
      'T811ED2', 'RSDDSTATAGGR', 'RSDDSTATAGGRDEF', 'RSDDSTATCOND', 'RSDDSTATDTP',
      'RSDDSTATDELE', 'RSDDSTATDM', 'RSDDSTATEVDATA', 'RSDDSTATHEADER',
      'RSDDSTATINFO', 'RSDDSTATLOGGING', 'RSERRORHEAD', 'RSERRORLOG',
      'DFKKDOUBTD_W', 'DFKKDOUBTD_RET_W', 'RSBERRORLOG', 'INDX',
      'SOOD', 'SOOS', 'SOC3', 'SOFFCONT1', 'BCST_SR', 'BCST_CAM',
      'SICFRECORDER', 'CRM_ICI_TRACES', 'RSPCINSTANCE',
      'GVD_BGPROCESS', 'GVD_BUFF_POOL_ST', 'GVD_LATCH_MISSES', 
      'GVD_ENQUEUE_STAT', 'GVD_FILESTAT', 'GVD_INSTANCE',    
      'GVD_PGASTAT', 'GVD_PGA_TARGET_A', 'GVD_PGA_TARGET_H',
      'GVD_SERVERLIST', 'GVD_SESSION_EVT', 'GVD_SESSION_WAIT',
      'GVD_SESSION', 'GVD_PROCESS', 'GVD_PX_SESSION',  
      'GVD_WPTOTALINFO', 'GVD_ROWCACHE', 'GVD_SEGMENT_STAT',
      'GVD_SESSTAT', 'GVD_SGACURRRESIZ', 'GVD_SGADYNFREE',  
      'GVD_SGA', 'GVD_SGARESIZEOPS', 'GVD_SESS_IO',     
      'GVD_SGASTAT', 'GVD_SGADYNCOMP', 'GVD_SEGSTAT',     
      'GVD_SPPARAMETER', 'GVD_SHAR_P_ADV', 'GVD_SQLAREA',     
      'GVD_SQL', 'GVD_SQLTEXT', 'GVD_SQL_WA_ACTIV',
      'GVD_SQL_WA_HISTO', 'GVD_SQL_WORKAREA', 'GVD_SYSSTAT',     
      'GVD_SYSTEM_EVENT', 'GVD_DATABASE', 'GVD_CURR_BLKSRV', 
      'GVD_DATAGUARD_ST', 'GVD_DATAFILE', 'GVD_LOCKED_OBJEC',
      'GVD_LOCK_ACTIVTY', 'GVD_DB_CACHE_ADV', 'GVD_LATCHHOLDER', 
      'GVD_LATCHCHILDS', 'GVD_LATCH', 'GVD_LATCHNAME',   
      'GVD_LATCH_PARENT', 'GVD_LIBRARYCACHE', 'GVD_LOCK',        
      'GVD_MANGD_STANBY', 'GVD_OBJECT_DEPEN', 'GVD_PARAMETER',   
      'GVD_LOGFILE', 'GVD_PARAMETER2', 'GVD_TEMPFILE',    
      'GVD_UNDOSTAT', 'GVD_WAITSTAT', 'ORA_SNAPSHOT',
      '/TXINTF/TRACE', 'RSECLOG', 'RSECUSERAUTH_CL', 'RSWR_DATA',
      'RSECVAL_CL', 'RSECHIE_CL', 'RSECTXT_CL', 'RSECSESSION_CL',
      'UPC_STATISTIC', 'UPC_STATISTIC2', 'UPC_STATISTIC3',
      'RSTT_CALLSTACK'
    ) OR
    TABLE_NAME LIKE '/BI0/0%'
),
LINES AS
( SELECT 1 LINENR, 'TOTAL' DESCRIPTION FROM DUAL UNION ALL
  ( SELECT 2 LINENR, 'TABLE' DESCRIPTION FROM DUAL ) UNION ALL
  ( SELECT 3 LINENR, 'INDEX' DESCRIPTION FROM DUAL ) UNION ALL
  ( SELECT 4 LINENR, 'LOB' DESCRIPTION FROM DUAL )
)
SELECT
  D.OWNER,
  D.TABLE_NAME,
  DECODE(D.BASIS_TABLE, NULL, ' ', 'X') B,
  TO_CHAR(ROWNUM, 990) POS,
  TO_CHAR(TOTAL_BYTES / 1024 / 1024 / 1024, 99990.99) TOTAL_GB,
  TO_CHAR(TOTAL_BYTES / DB_NET_SIZE_BYTE * 100, 990.99) "TOTAL_%", 
  TO_CHAR(SUM(TOTAL_BYTES / DB_NET_SIZE_BYTE * 100) OVER (ORDER BY TOTAL_BYTES DESC
    RANGE UNBOUNDED PRECEDING), 990.99) "CUM_%",
  TO_CHAR("PART.", 9990) "PART.",
  TO_CHAR(TAB_BYTES / 1024 / 1024 / 1024, 99990.99) TABLE_GB,
  TAB_TABSPACE,
  TO_CHAR("INDEXES", 990) "IND.",
  TO_CHAR(IND_BYTES / 1024 / 1024 / 1024, 9990.99) INDEX_GB,
  IND_TABSPACE,
  TO_CHAR(LOBS, 990) LOBS,
  TO_CHAR(LOB_BYTES / 1024 / 1024 / 1024, 9990.99) LOB_GB
FROM
( SELECT
    OWNER,
    TABLE_NAME,
    MAX(BASIS_TABLE) BASIS_TABLE,
    SUM(DECODE(COMPONENT, 'TOTAL', BYTES, 0)) TOTAL_BYTES,
    SUM(DECODE(COMPONENT, 'TABLE', COUNTER, 0)) "PART.",
    SUM(DECODE(COMPONENT, 'TABLE', BYTES, 0)) TAB_BYTES,
    MAX(DECODE(COMPONENT, 'TABLE', TABLESPACE_NAME)) TAB_TABSPACE,
    SUM(DECODE(COMPONENT, 'INDEX', COUNTER, 0)) "INDEXES",
    SUM(DECODE(COMPONENT, 'INDEX', BYTES, 0)) IND_BYTES,
    MAX(DECODE(COMPONENT, 'INDEX', TABLESPACE_NAME)) IND_TABSPACE,
    SUM(DECODE(COMPONENT, 'LOB',   COUNTER, 0)) LOBS,
    SUM(DECODE(COMPONENT, 'LOB',   BYTES, 0)) LOB_BYTES
  FROM
  ( SELECT
      TSM.OWNER OWNER,
      TSM.TABLE_NAME TABLE_NAME,
      BT.TABLE_NAME BASIS_TABLE,
      L.DESCRIPTION COMPONENT,
     DECODE(L.DESCRIPTION, 
        'TOTAL', MAX(DECODE(TSM.SEGMENT_TYPE, 'TABLE', TSM.TABLESPACE_NAME)), 
        'TABLE', MAX(DECODE(TSM.SEGMENT_TYPE, 'TABLE', TSM.TABLESPACE_NAME)),
        'INDEX', MAX(DECODE(TSM.SEGMENT_TYPE, 'INDEX', TSM.TABLESPACE_NAME)),
        'LOB',   MAX(DECODE(TSM.SEGMENT_TYPE, 'LOB',   TSM.TABLESPACE_NAME))) TABLESPACE_NAME,
      DECODE(L.DESCRIPTION, 
        'TOTAL', SUM(TSM.BYTES), 
        'TABLE', SUM(DECODE(TSM.SEGMENT_TYPE, 'TABLE', TSM.BYTES)),
        'INDEX', SUM(DECODE(TSM.SEGMENT_TYPE, 'INDEX', TSM.BYTES)),
        'LOB',   SUM(DECODE(TSM.SEGMENT_TYPE, 'LOB',   TSM.BYTES))) BYTES,
      DECODE(L.DESCRIPTION,
        'TOTAL', 0,
        'TABLE', SUM(DECODE(TSM.SEGMENT_TYPE, 'TABLE', TSM.PARTITIONS)),
        'INDEX', SUM(DECODE(TSM.SEGMENT_TYPE, 'INDEX', TSM.SEGMENTS)),
        'LOB',   SUM(DECODE(TSM.SEGMENT_TYPE, 'LOB',   TSM.SEGMENTS))) COUNTER
    FROM
      BASIS_INFO BI,
      TABLE_SEGMENT_MAPPING TSM,
      LINES L,
      BASIS_TABLES BT
    WHERE
      TSM.TABLE_NAME LIKE BI.TABLE_NAME AND
      TSM.TABLE_NAME = BT.TABLE_NAME (+)
    GROUP BY
      L.LINENR,
      L.DESCRIPTION,
      TSM.OWNER,
      TSM.TABLE_NAME,
      BT.TABLE_NAME
    ORDER BY
      SUM(TSM.BYTES),
      TSM.TABLE_NAME,
      L.LINENR 
  )
  GROUP BY
    OWNER,
    TABLE_NAME
  ORDER BY
    4 DESC
) D,
TOTAL_SEGMENT_SIZE TSS,
BASIS_INFO BI
WHERE
  ( BI.ONLY_BASIS_TABLES = ' ' OR D.BASIS_TABLE IS NOT NULL ) AND
  ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS ) AND
  ( BI.MIN_TOTAL_SIZE_MB = -1 OR TOTAL_BYTES / 1024 / 1024 >= BI.MIN_TOTAL_SIZE_MB )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d04f581-014d-1000-803c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_PotentiallyUnnecessaryIndexes]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT
  TO_CHAR(SYSDATE, 'dd.mm.yyyy') OWNER,
  TO_CHAR(SYSDATE, 'hh24:mi:ss') TABLE_NAME,
  NULL INDEX_NAME,
  NULL SIZE_MB,
  NULL PREFIX,
  NULL OBJECT_USAGE,
  NULL SQL_PLANS,
  NULL BUFFER_POOL
FROM 
  DUAL
UNION ALL
( SELECT
    NULL OWNER,
    NULL TABLE_NAME,
    NULL INDEX_NAME,
    NULL SIZE_MB,
    NULL PREFIX,
    NULL OBJECT_USAGE,
    NULL SQL_PLANS,
    NULL BUFFER_POOL
  FROM 
    DUAL
)
UNION ALL
( SELECT
    OWNER,
    TABLE_NAME,
    INDEX_NAME,
    SIZE_MB,
    PREFIX,
    OBJECT_USAGE,
    SQL_PLANS,
    BUFFER_POOL
  FROM
  ( SELECT
      OWNER,
      TABLE_NAME,
      INDEX_NAME,
      SIZE_MB,
      DECODE(BITAND(FINDING_CATEGORY, 1), 1, 'X', ' ') PREFIX,
      DECODE(BITAND(FINDING_CATEGORY, 2), 2, 'X', ' ') OBJECT_USAGE,
      DECODE(BITAND(FINDING_CATEGORY, 4), 4, 'X', ' ') SQL_PLANS,
      DECODE(BITAND(FINDING_CATEGORY, 8), 8, 'X', ' ') BUFFER_POOL
    FROM
    ( SELECT
        OWNER,
        TABLE_NAME,
        INDEX_NAME,
        TO_CHAR(SIZE_MB, '9999990.99') SIZE_MB,
        SUM(FINDING_CATEGORY) FINDING_CATEGORY
      FROM
      ( WITH INDEXLIST AS
        ( SELECT /*+ MATERIALIZE */
            OWNER,
            TABLE_NAME,
            INDEX_NAME,
            ROUND(BYTES / 1024 / 1024, 2) SIZE_MB,
            UNIQUENESS,
            USED,
            COLUMN_1,
            COLUMN_2,
            COLUMN_3,
            COLUMN_4,
            COLUMN_5,
            COLUMN_6,
            COLUMN_7,
            COLUMN_8,
            COLUMN_9,
            COLUMN_10,
            COLUMN_11,
            COLUMN_12,
            COLUMN_13,
            COLUMN_14,
            COLUMN_15
          FROM
          ( SELECT
              IC.INDEX_OWNER OWNER,
              IC.TABLE_NAME,
              IC.INDEX_NAME,
              IC.COLUMN_POSITION,
              S.BYTES,
              I.UNIQUENESS,
              OU.USED,
              COLUMN_NAME COLUMN_1,
              LEAD(COLUMN_NAME, 1) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_2,
              LEAD(COLUMN_NAME, 2) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_3,
              LEAD(COLUMN_NAME, 3) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_4,
              LEAD(COLUMN_NAME, 4) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_5,
              LEAD(COLUMN_NAME, 5) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_6,
              LEAD(COLUMN_NAME, 6) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_7,
              LEAD(COLUMN_NAME, 7) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_8,
              LEAD(COLUMN_NAME, 8) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_9,
              LEAD(COLUMN_NAME, 9) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_10,
              LEAD(COLUMN_NAME, 10) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_11,
              LEAD(COLUMN_NAME, 11) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_12,
              LEAD(COLUMN_NAME, 12) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_13,
              LEAD(COLUMN_NAME, 13) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_14,
              LEAD(COLUMN_NAME, 14) OVER (PARTITION BY IC.INDEX_OWNER, 
                IC.INDEX_NAME ORDER BY COLUMN_POSITION) COLUMN_15
            FROM
              DBA_IND_COLUMNS IC,
              DBA_INDEXES I,
              DBA_SEGMENTS S,
              V$OBJECT_USAGE OU
            WHERE 
              IC.INDEX_OWNER = S.OWNER AND
              IC.INDEX_NAME = S.SEGMENT_NAME AND
              S.PARTITION_NAME IS NULL AND
              IC.INDEX_OWNER = I.OWNER AND
              IC.INDEX_NAME = I.INDEX_NAME AND
              IC.TABLE_NAME = I.TABLE_NAME AND
              IC.INDEX_NAME = OU.INDEX_NAME (+) AND
              IC.TABLE_NAME = OU.TABLE_NAME (+) AND
              IC.INDEX_OWNER LIKE 'SAP%' AND
              S.BYTES > 10000000
          )
          WHERE 
            COLUMN_POSITION = 1   
        )
        SELECT DISTINCT
          I1.OWNER,
          I1.TABLE_NAME,
          I1.INDEX_NAME,
          I1.SIZE_MB,
          'Prefix of other index' FINDING,
          1 FINDING_CATEGORY
        FROM
          INDEXLIST I1,
          INDEXLIST I2
        WHERE
          I1.OWNER = I2.OWNER AND
          I1.TABLE_NAME = I2.TABLE_NAME AND
          I1.INDEX_NAME != I2.INDEX_NAME AND
          I1.UNIQUENESS = 'NONUNIQUE' AND
          (I1.COLUMN_1 IS NULL OR I1.COLUMN_1 = I2.COLUMN_1) AND
          (I1.COLUMN_2 IS NULL OR I1.COLUMN_2 = I2.COLUMN_2) AND
          (I1.COLUMN_3 IS NULL OR I1.COLUMN_3 = I2.COLUMN_3) AND
          (I1.COLUMN_4 IS NULL OR I1.COLUMN_4 = I2.COLUMN_4) AND
          (I1.COLUMN_5 IS NULL OR I1.COLUMN_5 = I2.COLUMN_5) AND
          (I1.COLUMN_6 IS NULL OR I1.COLUMN_6 = I2.COLUMN_6) AND
          (I1.COLUMN_7 IS NULL OR I1.COLUMN_7 = I2.COLUMN_7) AND
          (I1.COLUMN_8 IS NULL OR I1.COLUMN_8 = I2.COLUMN_8) AND
          (I1.COLUMN_9 IS NULL OR I1.COLUMN_9 = I2.COLUMN_9) AND
          (I1.COLUMN_10 IS NULL OR I1.COLUMN_10 = I2.COLUMN_10) AND
          (I1.COLUMN_11 IS NULL OR I1.COLUMN_11 = I2.COLUMN_11) AND
          (I1.COLUMN_12 IS NULL OR I1.COLUMN_12 = I2.COLUMN_12) AND
          (I1.COLUMN_13 IS NULL OR I1.COLUMN_13 = I2.COLUMN_13) AND
          (I1.COLUMN_14 IS NULL OR I1.COLUMN_14 = I2.COLUMN_14) AND
          (I1.COLUMN_15 IS NULL OR I1.COLUMN_15 = I2.COLUMN_15)
        UNION ALL
        ( SELECT
            USER,
            TABLE_NAME,
            INDEX_NAME,
            SIZE_MB,
            'Not used according to V$OBJECT_USAGE' FINDING,
            2 FINDING_CATEGORY
          FROM
            INDEXLIST
          WHERE
            OWNER = USER AND
            USED = 'NO' AND
            UNIQUENESS = 'NONUNIQUE'
        )
        UNION ALL
        ( SELECT
            I.OWNER,
            I.TABLE_NAME,
            I.INDEX_NAME,
            I.SIZE_MB,
            'Not used according to V$SQL_PLAN / DBA_HIST_SQL_PLAN' FINDING,
            4 FINDING_CATEGORY
          FROM
            INDEXLIST I
          WHERE
            UNIQUENESS = 'NONUNIQUE' AND
            NOT EXISTS
            ( SELECT 
                1
              FROM
                V$SQL_PLAN SP
              WHERE
                SP.OBJECT_OWNER = I.OWNER AND
                SP.OBJECT_NAME = I.INDEX_NAME 
            ) AND
            NOT EXISTS
            ( SELECT 
                1
              FROM
                DBA_HIST_SQL_PLAN SP
              WHERE
                SP.OBJECT_OWNER = I.OWNER AND
                SP.OBJECT_NAME = I.INDEX_NAME 
            )
        )
        UNION ALL
        ( SELECT
            I.OWNER,
            I.TABLE_NAME,
            I.INDEX_NAME,
            I.SIZE_MB,
            'Not used according to V$BH' FINDING,
            8 FINDING_CATEGORY
          FROM
            INDEXLIST I
          WHERE
            UNIQUENESS = 'NONUNIQUE' AND
            NOT EXISTS
            ( SELECT 
                1
              FROM
                V$BH B,
                DBA_OBJECTS O
              WHERE
                B.OBJD = O.DATA_OBJECT_ID AND
                O.OWNER = I.OWNER AND
                O.OBJECT_NAME = I.INDEX_NAME 
            )
        )
      )
      GROUP BY
        OWNER,
        TABLE_NAME,
        INDEX_NAME,
        SIZE_MB
    )
    WHERE
      FINDING_CATEGORY != 8 AND
      ( SIZE_MB >= 100 OR
        BITAND(FINDING_CATEGORY, 1) = 1
      )
    ORDER BY
      SIZE_MB DESC,
      INDEX_NAME
  )
)]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d055b50-014d-1000-803d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_PSAPTEMPSmallerThanLargestIndex]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TEMP_TABLESPACE, NULL TEMP_SIZE_GB, NULL INDEX_NAME, 
  NULL INDEX_SIZE_GB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TEMP_TABLESPACE, NULL TEMP_SIZE_GB, NULL INDEX_NAME, 
  NULL INDEX_SIZE_GB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
SELECT
  TEMP_DMTS_TABLESPACE || TEMP_LMTS_TABLESPACE TEMP_TABLESPACE,
  TO_CHAR(GREATEST(TEMP_DMTS_BYTES, TEMP_LMTS_BYTES) / 
    1024 / 1024 / 1024, 99999990.99) TEMP_SIZE_GB,
  INDEX_NAME,
  TO_CHAR(INDEX_BYTES / 1024 / 1024 / 1024, 999999990.99) INDEX_SIZE_GB
FROM
  ( SELECT DISTINCT
      FIRST_VALUE(BYTES) OVER (ORDER BY BYTES DESC) INDEX_BYTES,
      FIRST_VALUE(SEGMENT_NAME) OVER (ORDER BY BYTES DESC) INDEX_NAME
    FROM 
      DBA_SEGMENTS 
    WHERE 
      SEGMENT_TYPE LIKE 'INDEX%' ),
  ( SELECT 
      MIN(U.TEMPORARY_TABLESPACE) TEMP_DMTS_TABLESPACE,
      NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_DMTS_BYTES
    FROM
      DBA_USERS U,
      DBA_DATA_FILES DF
    WHERE
      U.USERNAME = USER AND
      U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
  ),
  ( SELECT 
      MIN(U.TEMPORARY_TABLESPACE) TEMP_LMTS_TABLESPACE,
      NVL(SUM(GREATEST(DF.BYTES, DF.MAXBYTES)), 0) TEMP_LMTS_BYTES
    FROM
      DBA_USERS U,
      DBA_TEMP_FILES DF
    WHERE
      U.USERNAME = USER AND
      U.TEMPORARY_TABLESPACE = DF.TABLESPACE_NAME
  )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d06b610-014d-1000-803e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_RawSegmentAdvisorInformationForSegment]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL ANALYSIS_TIME, NULL OWNER, NULL SEGMENT_NAME, NULL PARTITION_NAME,
  NULL SEGMENT_TYPE, NULL MESSAGE, NULL MORE_INFO FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL ANALYSIS_TIME, NULL OWNER, NULL SEGMENT_NAME, NULL PARTITION_NAME,
  NULL SEGMENT_TYPE, NULL MESSAGE, NULL MORE_INFO FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    NVL(:SEGMENT_NAME,'%') SEGMENT_NAME
  FROM
    DUAL
)
SELECT
  TO_CHAR(DAT.EXECUTION_START, 'dd.mm.yyyy hh24:mi:ss') ANALYSIS_TIME,
  DAO.ATTR1 OWNER,
  DAO.ATTR2 SEGMENT_NAME,
  DAO.ATTR3 PARTITION_NAME,
  DAO.TYPE SEGMENT_TYPE,
  DAF.MESSAGE MESSAGE,
  DAF.MORE_INFO
FROM
  BASIS_INFO BI,
  DBA_ADVISOR_TASKS DAT,
  DBA_ADVISOR_FINDINGS DAF,
  DBA_ADVISOR_OBJECTS DAO
WHERE
  DAO.ATTR1 LIKE BI.OWNER AND
  DAO.ATTR2 LIKE BI.SEGMENT_NAME AND
  DAT.OWNER = DAF.OWNER AND
  DAT.TASK_ID = DAF.TASK_ID AND
  DAF.TASK_ID = DAO.TASK_ID AND
  DAF.OBJECT_ID = DAO.OBJECT_ID AND
  DAT.ADVISOR_NAME = 'Segment Advisor' 
ORDER BY
  DAT.EXECUTION_START DESC
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SEGMENT_NAME">
						<prompt><![CDATA[SEGMENT_NAME]]></prompt>
						<tooltip><![CDATA[SEGMENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d088007-014d-1000-803f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_SegmentFragmentation_CBOStatistics]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SEGMENT_NAME, NULL PART_NAME, NULL SIZE_POS, NULL IO_POS, NULL UNUSED_MB, NULL "QUALITY_%", 
  NULL SEG_GROSS_MB, NULL SEG_NET_MB, NULL DATA_GROSS_MB, NULL DATA_NET_MB
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SEGMENT_NAME, NULL PART_NAME, NULL SIZE_POS, NULL IO_POS, NULL UNUSED_MB, NULL "QUALITY_%", 
  NULL SEG_GROSS_MB, NULL SEG_NET_MB, NULL DATA_GROSS_MB, NULL DATA_NET_MB
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT 
  /*+ OPT_PARAM('_PUSH_JOIN_UNION_VIEW', 'FALSE') OPT_PARAM('_COMPLEX_VIEW_MERGING', 'FALSE')
      OPT_PARAM('_OPTIMIZER_NEW_JOIN_CARD_COMPUTATION', 'FALSE') */  
  * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    NVL(:TABLE_OWNER,'%') TABLE_OWNER,
    NVL(:TABLE_NAME,'%') TABLE_NAME,
    NVL(:TABLESPACE_NAME,'%') TABLESPACE_NAME,
    'ALL' SEGMENT_TYPE,             /* TABLE, INDEX or ALL */
    -1 MIN_SIZE_MB,
    -1 NUM_RECORDS,
    50 QUALITY_THRESHOLD,
    100 UNUSED_MB_THRESHOLD,
    -1 QUALITY_THRESHOLD_2,
    -1 UNUSED_MB_THRESHOLD_2,
    -1 NUM_LARGEST_SEGMENTS,
    -1 NUM_IO_READ_SEGMENTS,
    'UNUSED' SORT_BY,            /* QUALITY, UNUSED or SEGMENT */
    'X' INCLUDE_TAB_MODIFICATIONS,
    'X' INCLUDE_PARTITIONS,
    'X' EXCLUDE_LONG_TABLES,
    'X' EXCLUDE_LOB_TABLES,
    'X' EXCLUDE_MODIFIED_STATS,
    'X' EXCLUDE_LOCKED_STATS,
    ' ' RESTRICTION_INFO
  FROM
    DUAL
),
SEGMENT_SELECTION AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    SEGMENT_NAME,
    SUM(SIZE_POS) SIZE_POS,
    SUM(IO_POS) IO_POS
  FROM
  ( SELECT
      OWNER,
      SEGMENT_NAME,
      SIZE_POS,
      0 IO_POS
    FROM
    ( SELECT
        S.OWNER,
        S.SEGMENT_NAME,
        ROW_NUMBER () OVER (ORDER BY SUM(S.BYTES) DESC) SIZE_POS,
        BI.NUM_LARGEST_SEGMENTS,
        BI.NUM_IO_READ_SEGMENTS
      FROM
        DBA_SEGMENTS S,
        BASIS_INFO BI
      WHERE
        S.SEGMENT_TYPE IN ('INDEX', 'INDEX PARTITION', 
          'TABLE', 'TABLE PARTITION')
      GROUP BY
        S.OWNER,
        S.SEGMENT_NAME,
        BI.NUM_LARGEST_SEGMENTS,
        BI.NUM_IO_READ_SEGMENTS
      ORDER BY
        SUM(S.BYTES) DESC
    )
    WHERE
      NUM_LARGEST_SEGMENTS = -1 OR 
      NUM_IO_READ_SEGMENTS = -1 OR 
      SIZE_POS <= NUM_LARGEST_SEGMENTS
    UNION ALL
    ( SELECT
        OWNER,
        SEGMENT_NAME,
        0 SIZE_POS,
        IO_POS
      FROM
      ( SELECT
          DECODE(NVL(O.OWNER, SSO.OWNER), 
            '** UNAVAILABLE **', NVL(O2.OWNER, 'not available'),
            NVL(O.OWNER, SSO.OWNER)) OWNER,
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, SSO.OBJECT_NAME)) SEGMENT_NAME,
          ROW_NUMBER () OVER (ORDER BY SUM(S.PHYSICAL_READS_DELTA) DESC) IO_POS,
          BI.NUM_LARGEST_SEGMENTS,
          BI.NUM_IO_READ_SEGMENTS
        FROM
          BASIS_INFO BI,
          DBA_HIST_SEG_STAT S,
          DBA_OBJECTS O,
          DBA_HIST_SEG_STAT_OBJ SSO,
          DBA_OBJECTS O2
        WHERE
          S.OBJ# = O.OBJECT_ID (+) AND
          S.DATAOBJ# = O.DATA_OBJECT_ID (+) AND
          S.OBJ# = SSO.OBJ# (+) AND
          S.DATAOBJ# = SSO.DATAOBJ# (+) AND
          S.OBJ# = O2.OBJECT_ID (+) AND
          SSO.OBJECT_TYPE IN ('INDEX', 'INDEX PARTITION',
            'TABLE', 'TABLE PARTITION')
        GROUP BY
          DECODE(NVL(O.OWNER, SSO.OWNER), 
            '** UNAVAILABLE **', NVL(O2.OWNER, 'not available'),
            NVL(O.OWNER, SSO.OWNER)),
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, SSO.OBJECT_NAME)),
          BI.NUM_LARGEST_SEGMENTS,
          BI.NUM_IO_READ_SEGMENTS
      )
      WHERE
        NUM_IO_READ_SEGMENTS = -1 OR IO_POS <= NUM_IO_READ_SEGMENTS
    )
  )
  GROUP BY
    OWNER,
    SEGMENT_NAME
),
TABLE_INFO AS
( SELECT /*+ MATERIALIZE */
    T.OWNER TABLE_OWNER,
    T.TABLE_NAME,
    S.SIZE_POS,
    S.IO_POS
  FROM
    BASIS_INFO TI,
    SEGMENT_SELECTION S,
    DBA_TABLES T
  WHERE
    T.OWNER LIKE TI.TABLE_OWNER AND
    T.TABLE_NAME LIKE TI.TABLE_NAME AND
    T.OWNER = S.OWNER AND
    T.TABLE_NAME = S.SEGMENT_NAME AND
    ( T.TABLESPACE_NAME IS NULL OR
      T.TABLESPACE_NAME LIKE TI.TABLESPACE_NAME )
  UNION 
  ( SELECT /*+ MATERIALIZE */
      T.OWNER TABLE_OWNER,
      T.TABLE_NAME TABLE_NAME,
      S.SIZE_POS,
      S.IO_POS
    FROM
      BASIS_INFO TI,
      SEGMENT_SELECTION S,
      DBA_PART_TABLES T
    WHERE
      T.OWNER LIKE TI.TABLE_OWNER AND
      T.TABLE_NAME LIKE TI.TABLE_NAME AND
      T.OWNER = S.OWNER AND
      T.TABLE_NAME = S.SEGMENT_NAME AND
      T.DEF_TABLESPACE_NAME LIKE TI.TABLESPACE_NAME
  )
),
TABLE_STORAGE AS
( SELECT /*+ MATERIALIZE */
    DT.OWNER TABLE_OWNER, 
    DT.TABLE_NAME, 
    DT.TABLESPACE_NAME,
    NULL PARTITION_NAME, 
    TI.SIZE_POS,
    TI.IO_POS,
    DT.IOT_TYPE,
    NVL(DT.PCT_FREE, 10) PCT_FREE, 
    NVL(DT.INI_TRANS, 1) INI_TRANS,
    DECODE(DT.CLUSTER_NAME, NULL, 'NO', 'YES') CLUSTER_TABLE,
    0 PARTITION_POSITION
  FROM 
    DBA_TABLES DT, 
    TABLE_INFO TI
  WHERE 
    DT.OWNER = TI.TABLE_OWNER AND 
    DT.TABLE_NAME = TI.TABLE_NAME
  UNION ALL
  ( SELECT /*+ MATERIALIZE */
      DTP.TABLE_OWNER, 
      DTP.TABLE_NAME, 
      DTP.TABLESPACE_NAME,
      DTP.PARTITION_NAME, 
      TI.SIZE_POS,
      TI.IO_POS,
      NULL,
      DTP.PCT_FREE, 
      DTP.INI_TRANS,
      DECODE(DT.CLUSTER_NAME, NULL, 'NO', 'YES') CLUSTER_TABLE,
      DTP.PARTITION_POSITION
    FROM
      DBA_TABLES DT,
      DBA_TAB_PARTITIONS DTP, 
      TABLE_INFO TI
    WHERE 
      DT.OWNER = TI.TABLE_OWNER AND  
      DT.TABLE_NAME = TI.TABLE_NAME AND
      DTP.TABLE_OWNER = TI.TABLE_OWNER AND  
      DTP.TABLE_NAME = TI.TABLE_NAME
  )
),
TABLE_MODIFICATIONS AS
( SELECT /*+ MATERIALIZE */
    TI.TABLE_OWNER,
    TI.TABLE_NAME,
    TI.PARTITION_NAME,
    NVL(TM.INSERTS, 0) INSERTS,
    NVL(TM.UPDATES, 0) UPDATES,
    NVL(TM.DELETES, 0) DELETES
  FROM
    TABLE_STORAGE TI,
    ALL_TAB_MODIFICATIONS TM
  WHERE
    TI.TABLE_OWNER = TM.TABLE_OWNER (+) AND
    TI.TABLE_NAME = TM.TABLE_NAME (+) AND
    NVL(TI.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME (+), ' ')
),
TABLE_COLUMNS AS
( SELECT /*+ MATERIALIZE */
    TI.TABLE_OWNER,
    TI.TABLE_NAME,
    NVL(DTC.LONG_RAW, 'NO') LONG_RAW,
    NVL(DTC.LOB, 'NO') LOB
  FROM
  ( SELECT
      OWNER, 
      TABLE_NAME, 
      DECODE(SUM(DECODE(SUBSTR(DATA_TYPE, 1, 4), 'LONG', 1, 0)), 0, 'NO', 'YES') LONG_RAW,
      DECODE(SUM(DECODE(SUBSTR(DATA_TYPE, 1, 4), 'LONG', 0, 1)), 0, 'NO', 'YES') LOB
    FROM
      DBA_TAB_COLS
    WHERE
      DATA_TYPE IN ( 'LONG', 'LONG RAW', 'CLOB', 'BLOB', 'NCLOB' )
    GROUP BY
      OWNER,
      TABLE_NAME
  ) DTC,
    TABLE_INFO TI
  WHERE
    TI.TABLE_OWNER = DTC.OWNER (+) AND
    TI.TABLE_NAME = DTC.TABLE_NAME (+)    
),
INDEX_INFO AS
( SELECT /*+ MATERIALIZE */ DISTINCT 
    T.TABLE_OWNER TABLE_OWNER,
    T.TABLE_NAME TABLE_NAME,
    I.OWNER INDEX_OWNER, 
    I.INDEX_NAME, 
    I.INDEX_TYPE,
    I.UNIQUENESS,
    S.SIZE_POS,
    S.IO_POS,
    DECODE(I.COMPRESSION, 'ENABLED', 'YES', 'NO') COMPRESSION,
    NVL(I.PREFIX_LENGTH, 0) PREFIX_LENGTH,
    DECODE(T.IOT_TYPE, NULL, 'NO', 'YES') INDEX_OF_IOT
  FROM 
    DBA_INDEXES I, 
    TABLE_STORAGE T,
    SEGMENT_SELECTION S,
    BASIS_INFO BI
  WHERE 
    BI.SEGMENT_TYPE IN ('INDEX', 'ALL') AND
    I.TABLE_OWNER = T.TABLE_OWNER AND
    I.TABLE_NAME = T.TABLE_NAME AND 
    I.OWNER = S.OWNER AND
    I.INDEX_NAME = S.SEGMENT_NAME AND
    I.INDEX_TYPE != 'LOB'
),
INDEX_STORAGE AS
( SELECT /*+ MATERIALIZE */
    TI.INDEX_OWNER, 
    TI.INDEX_NAME, 
    NULL PARTITION_NAME,
    DT.INDEX_TYPE, 
    NVL(DT.PCT_FREE, 10) PCT_FREE,
    NVL(DT.INI_TRANS, 2) INI_TRANS,
    0 PARTITION_POSITION,
    TI.COMPRESSION,
    TI.PREFIX_LENGTH,
    TI.INDEX_OF_IOT,
    TI.SIZE_POS,
    TI.IO_POS
  FROM 
    DBA_INDEXES DT, 
    INDEX_INFO TI, 
    BASIS_INFO BI
  WHERE 
    BI.SEGMENT_TYPE IN ('INDEX', 'ALL') AND
    TI.INDEX_OWNER = DT.OWNER AND 
    TI.INDEX_NAME = DT.INDEX_NAME
  UNION ALL
  ( SELECT /*+ MATERIALIZE */
      TI.INDEX_OWNER, 
      TI.INDEX_NAME, 
      DTP.PARTITION_NAME,
      TI.INDEX_TYPE, 
      DTP.PCT_FREE, 
      DTP.INI_TRANS,
      DTP.PARTITION_POSITION,
      TI.COMPRESSION,
      TI.PREFIX_LENGTH,
      TI.INDEX_OF_IOT,
      TI.SIZE_POS,
      TI.IO_POS
    FROM 
      DBA_IND_PARTITIONS DTP, 
      INDEX_INFO TI,
      BASIS_INFO BI
    WHERE 
      BI.SEGMENT_TYPE IN ('INDEX', 'ALL') AND
      TI.INDEX_OWNER = DTP.INDEX_OWNER AND 
      TI.INDEX_NAME = DTP.INDEX_NAME
  )
),
INDEX_ROWS_HELPER AS
( SELECT /*+ MATERIALIZE */ 
    IC.TABLE_NAME TABLE_NAME,
    IC.INDEX_NAME INDEX_NAME,
    IC.INDEX_OWNER INDEX_OWNER,
    IC.COLUMN_NAME COLUMN_NAME,
    II.UNIQUENESS,
    II.COMPRESSION,
    II.PREFIX_LENGTH,
    IC.COLUMN_POSITION
  FROM
    INDEX_INFO II,
    DBA_IND_COLUMNS IC
  WHERE
    II.INDEX_OWNER = IC.INDEX_OWNER AND
    II.INDEX_NAME = IC.INDEX_NAME
),
INDEX_ROWS AS
( SELECT /*+ MATERIALIZE */ 
    IR.INDEX_NAME INDEX_NAME,
    IR.INDEX_OWNER INDEX_OWNER,
    SUM(NVL(TC.AVG_COL_LEN, 0) +               /* Length of all indexed columns */
      DECODE(TC.GLOBAL_STATS, 'YES', 0, 1)) +  /* Additional length byte in case of ANALYZE */
      6 +                                      /* ROWID bytes */
      DECODE(IR.UNIQUENESS, 'UNIQUE', 0, 1) +  /* Additional ROWID length byte for NONUNIQUE indexes */
      1 +                                      /* Lock byte */
      1 +                                      /* Flag byte */
      2                                        /* Row directory entry */
      IND_ROW_LEN,
    SUM(DECODE(SIGN(IR.COLUMN_POSITION - IR.PREFIX_LENGTH), 1, 0, 
      NVL(TC.AVG_COL_LEN, 0) + DECODE(TC.GLOBAL_STATS, 
      'YES', 0, 1))) COMP_ROW_LEN,
    SUM(DECODE(TC.AVG_COL_LEN, NULL, 1, 0)) COL_LEN_NULL,
    SUM(DECODE(IR.COLUMN_POSITION, 1, 
      NVL(TC.NUM_DISTINCT, 0))) FIRST_NUM_DIST
  FROM
    INDEX_ROWS_HELPER IR,
    DBA_TAB_COLS TC
  WHERE
    TC.TABLE_NAME = IR.TABLE_NAME AND
    TC.OWNER = IR.INDEX_OWNER AND
    TC.COLUMN_NAME = IR.COLUMN_NAME
  GROUP BY
    IR.INDEX_OWNER,
    IR.INDEX_NAME,
    IR.UNIQUENESS
),
INDEX_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    DIS.OWNER,
    DIS.INDEX_NAME,
    DIS.PARTITION_NAME,
    DIS.TABLE_OWNER,
    DIS.TABLE_NAME,
    DIS.LEAF_BLOCKS,
    DIS.NUM_ROWS,
    DIS.DISTINCT_KEYS,
    DIS.USER_STATS,
    DIS.STATTYPE_LOCKED,
    DIS.STALE_STATS,
    DIS.LAST_ANALYZED,
    DIS.AVG_LEAF_BLOCKS_PER_KEY
  FROM
    INDEX_INFO II,
    DBA_IND_STATISTICS DIS
  WHERE
    DIS.OWNER = II.INDEX_OWNER AND
    DIS.INDEX_NAME = II.INDEX_NAME 
),
SEGMENTS_HELPER AS
( SELECT /*+ MATERIALIZE */
    S.OWNER,
    S.SEGMENT_NAME,
    S.PARTITION_NAME,
    S.BYTES,
    O.CREATED
  FROM
    DBA_SEGMENTS S,
    DBA_OBJECTS O,
    ( SELECT TABLE_OWNER OWNER, TABLE_NAME SEGMENT_NAME FROM TABLE_INFO UNION 
      SELECT INDEX_OWNER OWNER, INDEX_NAME SEGMENT_NAME FROM INDEX_INFO) S2
  WHERE
    S.OWNER = S2.OWNER AND
    S.SEGMENT_NAME = S2.SEGMENT_NAME AND
    S.OWNER = O.OWNER AND
    S.SEGMENT_NAME = O.OBJECT_NAME AND
    NVL(S.PARTITION_NAME, ' ') = NVL(O.SUBOBJECT_NAME, ' ')
),
SEGMENTS AS
( SELECT /*+ MATERIALIZE */ 
    OWNER,
    SEGMENT_NAME,
    NULL PARTITION_NAME,
    SUM(BYTES) BYTES,
    MIN(CREATED) CREATED
  FROM
    SEGMENTS_HELPER 
  WHERE
    PARTITION_NAME IS NOT NULL
  GROUP BY
    OWNER,
    SEGMENT_NAME
  UNION ALL
  ( SELECT /*+ MATERIALIZE */
      OWNER,
      SEGMENT_NAME,
      PARTITION_NAME,
      BYTES,
      CREATED
    FROM
      SEGMENTS_HELPER
  )
)
SELECT
  DECODE(SORT_BY, 'SEGMENT',
    DECODE(SEGMENT_NAME, LAG(SEGMENT_NAME, 1) OVER 
    (ORDER BY 1), NULL, SEGMENT_NAME),
    SEGMENT_NAME) SEGMENT_NAME,
  PARTITION_NAME PART_NAME, 
  DECODE(SIZE_POS, 0, ' ', TO_CHAR(SIZE_POS, 9999990)) SIZE_POS,
  DECODE(IO_POS, 0, ' ', TO_CHAR(IO_POS, 99990)) IO_POS,
  TO_CHAR(UNUSED_MB, 999990.99) UNUSED_MB,
  TO_CHAR(QUALITY, 99990.99) "QUALITY_%",
  TO_CHAR(SEG_GROSS_MB, 99999990.99) SEG_GROSS_MB,
  TO_CHAR(SEG_NET_MB, 9999990.99) SEG_NET_MB,
  TO_CHAR(DATA_GROSS_MB, 999999990.99) DATA_GROSS_MB,
  TO_CHAR(DATA_NET_MB, 9999990.99) ||
    DECODE(RESTRICTION_INFO, 'X', ' ' || RESTRICTIONS) DATA_NET_MB
FROM
( SELECT
    SEGMENT_NAME,
    PARTITION_NAME,
    SEG_GROSS_MB,
    SEG_NET_MB,
    DATA_GROSS_MB,
    DATA_NET_MB,
    UNUSED_MB,
    DECODE(UNUSED_MB + DATA_NET_MB, 0, 0, DATA_NET_MB / 
      (UNUSED_MB + DATA_NET_MB) * 100) QUALITY,
    RESTRICTIONS,
    SIZE_POS,
    IO_POS,
    NUM_RECORDS,
    SORT_BY,
    QUALITY_THRESHOLD,
    UNUSED_MB_THRESHOLD,
    QUALITY_THRESHOLD_2,
    UNUSED_MB_THRESHOLD_2,
    RESTRICTION_INFO,
    PARTITION_POSITION
  FROM
  ( SELECT 
      SEGMENT_NAME,
      PARTITION_NAME,
      DECODE(CLUSTER_TABLE, 'YES', DATA_GROSS_MB * 1.1, 
        SEG_GROSS_MB) SEG_GROSS_MB,
      DECODE(CLUSTER_TABLE, 'YES', DATA_GROSS_MB, 
        SEG_NET_MB) SEG_NET_MB,
      DATA_GROSS_MB + GREATEST(0, CHANGE_MB) DATA_GROSS_MB,
      GREATEST(0, DATA_NET_MB + CHANGE_MB) DATA_NET_MB,
      LEAST(SEG_GROSS_MB, GREATEST(DATA_GROSS_MB + 
        GREATEST(0, CHANGE_MB), SEG_NET_MB)) - 
        DATA_NET_MB - CHANGE_MB UNUSED_MB,
      DECODE(USER_STATS,        'YES', 
        'STATISTICS MODIFIED   ') ||
        DECODE(LONG_RAW,        'YES', 
        'LONG (RAW)   ') ||
        DECODE(LOB,             'YES', 
        'LOB   ') ||
        DECODE(STATTYPE_LOCKED, 'ALL', 
        'STATISTICS LOCKED   ') ||
        DECODE(STALE_STATS,     'YES', 
        'STATISTICS STALE   ') ||
        DECODE(RECREATED,       'YES', 
        'STATISTICS OLDER THAN SEGMENT   ') ||
        DECODE(AVG_ROW_LEN,     0,     
        'ROW LENGTH = 0   ') ||
        DECODE(SIGN(SEG_GROSS_MB - 5),    -1, 
        'SMALL TABLE   ') ||
        DECODE(CLUSTER_TABLE,   'YES', 
        'CLUSTER TABLE   ')
        RESTRICTIONS,
      NUM_RECORDS,
      SORT_BY,
      TABLE_NAME,
      BYTES,
      MIN_SIZE_MB,
      QUALITY_THRESHOLD,
      UNUSED_MB_THRESHOLD,
      QUALITY_THRESHOLD_2,
      UNUSED_MB_THRESHOLD_2,
      RESTRICTION_INFO,
      PARTITION_POSITION,
      INDEX_NAME,
      SIZE_POS,
      IO_POS
    FROM
    ( SELECT
        TS.TABLE_OWNER,
        TS.TABLE_NAME SEGMENT_NAME,
        NVL(TS.PARTITION_NAME, ' ') PARTITION_NAME,
        DECODE(CLUSTER_TABLE, 'YES', DTS.BLOCKS * (8000 - 
          23 * TS.INI_TRANS) * 
          (1 - TS.PCT_FREE / 100) / 1024 / 1024 * 1.1, S.BYTES / 
          1024 / 1024) SEG_GROSS_MB,
        DECODE(CLUSTER_TABLE, 'YES', DTS.BLOCKS * (8000 - 23 * TS.INI_TRANS) * 
          (1 - TS.PCT_FREE / 100) / 1024 / 1024, (S.BYTES / 
          1024 / 1024) * (8000 - 23 * 
          TS.INI_TRANS) * (1 - TS.PCT_FREE / 100) / 8192) SEG_NET_MB,
        DTS.BLOCKS * (8000 - 23 * TS.INI_TRANS) * (1 - TS.PCT_FREE / 100) / 
          1024 / 1024 DATA_GROSS_MB,
        (DTS.AVG_ROW_LEN + 2) * DTS.NUM_ROWS / 1024 / 1024 DATA_NET_MB,
        DTS.NUM_ROWS,
        DTS.AVG_ROW_LEN,
        DTS.BLOCKS,
        DTS.USER_STATS,
        DTC.LONG_RAW,
        DTC.LOB,
        DECODE(SIGN(NVL(DTS.LAST_ANALYZED, SYSDATE) - S.CREATED), -1, 
          'YES', 'NO') RECREATED,
        DTS.STATTYPE_LOCKED,
        DTS.STALE_STATS,
        DECODE(BI.INCLUDE_TAB_MODIFICATIONS, 'X', DTS.AVG_ROW_LEN * 
          (TM.INSERTS - TM.DELETES) / 1024 / 1024,
          0) CHANGE_MB,
        BI.NUM_RECORDS,
        BI.SORT_BY,
        TS.TABLE_NAME,
        TS.SIZE_POS,
        TS.IO_POS,
        S.BYTES,
        BI.MIN_SIZE_MB,
        BI.QUALITY_THRESHOLD,
        BI.UNUSED_MB_THRESHOLD,
        BI.QUALITY_THRESHOLD_2,
        BI.UNUSED_MB_THRESHOLD_2,
        BI.RESTRICTION_INFO,
        TS.CLUSTER_TABLE,
        TS.PARTITION_POSITION,
        ' ' INDEX_NAME
      FROM 
        TABLE_STORAGE TS,
        TABLE_MODIFICATIONS TM,
        DBA_TAB_STATISTICS DTS,
        TABLE_COLUMNS DTC,
        SEGMENTS S,
        BASIS_INFO BI
      WHERE
        TS.TABLESPACE_NAME IS NOT NULL AND
        TS.TABLE_OWNER = DTS.OWNER AND
        TS.TABLE_NAME = DTS.TABLE_NAME AND
        NVL(TS.PARTITION_NAME, ' ') = NVL(DTS.PARTITION_NAME, ' ') AND
        DTS.OWNER = S.OWNER (+) AND
        DTS.TABLE_NAME = S.SEGMENT_NAME (+) AND 
        NVL(DTS.PARTITION_NAME, ' ') = NVL(S.PARTITION_NAME (+), ' ') AND
        DTS.OWNER = TM.TABLE_OWNER AND
        DTS.TABLE_NAME = TM.TABLE_NAME AND
        NVL(DTS.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME, ' ') AND
        DTS.OWNER = DTC.TABLE_OWNER AND
        DTS.TABLE_NAME = DTC.TABLE_NAME AND
        DTS.NUM_ROWS IS NOT NULL AND
        (TS.IOT_TYPE != 'IOT' OR TS.IOT_TYPE IS NULL) AND
        (BI.MIN_SIZE_MB = -1 OR S.BYTES IS NULL OR S.BYTES / 
          1024 / 1024 >= BI.MIN_SIZE_MB ) AND
        BI.SEGMENT_TYPE IN ('ALL', 'TABLE') AND
        ( BI.INCLUDE_PARTITIONS = 'X' OR TS.PARTITION_NAME IS NULL ) AND
        ( BI.EXCLUDE_LONG_TABLES != 'X' OR DTC.LONG_RAW = 'NO' ) AND
        ( BI.EXCLUDE_LOB_TABLES != 'X' OR DTC.LOB = 'NO' ) AND
        ( BI.EXCLUDE_MODIFIED_STATS != 'X' OR DTS.USER_STATS != 'YES' ) AND
        ( BI.EXCLUDE_LOCKED_STATS != 'X' OR DTS.STATTYPE_LOCKED IS NULL )
    )
    UNION ALL
    ( SELECT
        SEGMENT_NAME,
        PARTITION_NAME,
        SEG_GROSS_MB,
        SEG_NET_MB,
        DATA_GROSS_MB + GREATEST(0, CHANGE_MB) DATA_GROSS_MB,
        GREATEST(0, DATA_NET_MB + CHANGE_MB) DATA_NET_MB,
        LEAST(SEG_GROSS_MB, GREATEST(DATA_GROSS_MB + 
          GREATEST(0, CHANGE_MB), SEG_NET_MB)) - 
          DATA_NET_MB - CHANGE_MB UNUSED_MB,
        DECODE(  USER_STATS,             'YES',    
            'STATISTICS MODIFIED   ') ||
          DECODE(STATTYPE_LOCKED,        'ALL',    
            'STATISTICS LOCKED   ') ||
          DECODE(STALE_STATS,            'YES',    
            'STATISTICS STALE   ') ||
          DECODE(SIGN(SEG_GROSS_MB - 5), -1,       
            'SMALL INDEX   ') ||
          DECODE(SIGN(COL_LEN_NULL),     1,        
            'MISSING COLUMN STATISTICS   ') ||
          DECODE(RECREATED,              'YES',    
            'STATISTICS OLDER THAN SEGMENT   ') ||
          DECODE(INDEX_TYPE,             'BITMAP', 
            'BITMAP INDEX   ') ||
          DECODE(INDEX_TYPE,             'IOT - TOP', 
            'IOT   ') ||
          DECODE(IND_ROW_LEN,            0,        
            'ROW LENGTH = 0   ') ||
          DECODE(LEAF_BLOCKS,            0,        
            'WRONG VALUE LEAF_BLOCKS = 0   ') ||
          DECODE(INDEX_OF_IOT,           'YES',
            DECODE(INDEX_TYPE, 'IOT - TOP', NULL,
            'INDEX OF IOT   ')) ||
          DECODE(COMPRESSION,            'YES',    
            'COMPRESSED INDEX   ') RESTRICTIONS,
        NUM_RECORDS,
        SORT_BY,
        TABLE_NAME,
        BYTES,
        MIN_SIZE_MB,
        QUALITY_THRESHOLD,
        UNUSED_MB_THRESHOLD,
        QUALITY_THRESHOLD_2,
        UNUSED_MB_THRESHOLD_2,
        RESTRICTION_INFO,
        PARTITION_POSITION,
        INDEX_NAME,
        SIZE_POS,
        IO_POS
      FROM
      ( SELECT
          DIS.OWNER,
          DIS.INDEX_NAME SEGMENT_NAME,
          NVL(DIS.PARTITION_NAME, ' ') PARTITION_NAME,
          S.BYTES / 1024 / 1024 SEG_GROSS_MB,
          (S.BYTES / 1024 / 1024) * (8079 - 23 * IST.INI_TRANS) * 
            (1 - IST.PCT_FREE / 100) / 8192 SEG_NET_MB,
          DIS.LEAF_BLOCKS * (8079 - 23 * IST.INI_TRANS) * 
            (1 - IST.PCT_FREE / 100) / 1024 / 1024 * 1.05 DATA_GROSS_MB,
          DECODE (IST.INDEX_TYPE,
            'BITMAP', (NUM_ROWS * (DECODE(DISTINCT_KEYS, 1, 0.18, 1) + 
              DECODE(DISTINCT_KEYS, 
              0, 0, LOG(35, DISTINCT_KEYS))) + DISTINCT_KEYS * 50) / 
              1024 / 1024,
            (IR.IND_ROW_LEN * DIS.NUM_ROWS - 
              DECODE(IST.COMPRESSION, 'NO', 0, IR.COMP_ROW_LEN * 
              GREATEST(0, NUM_ROWS - DECODE(IST.PREFIX_LENGTH, 1, 
              FIRST_NUM_DIST, DISTINCT_KEYS)))) / 1024 / 1024
            ) * 1.05 DATA_NET_MB,
          DIS.NUM_ROWS,
          DIS.LEAF_BLOCKS LEAF_BLOCKS,
          DIS.USER_STATS,
          DIS.STATTYPE_LOCKED,
          DIS.STALE_STATS,
          DECODE(SIGN(NVL(DIS.LAST_ANALYZED, SYSDATE) - S.CREATED), 
            -1, 'YES', 'NO') RECREATED,
          IR.COL_LEN_NULL,
          IR.IND_ROW_LEN,
          DECODE(BI.INCLUDE_TAB_MODIFICATIONS, 'X', IR.IND_ROW_LEN * 
            (TM.INSERTS - TM.DELETES) / 1024 / 1024, 0) CHANGE_MB,
          BI.NUM_RECORDS,
          BI.SORT_BY,
          DIS.TABLE_NAME,
          S.BYTES,
          BI.MIN_SIZE_MB,
          BI.QUALITY_THRESHOLD,
          BI.UNUSED_MB_THRESHOLD,
          BI.QUALITY_THRESHOLD_2,
          BI.UNUSED_MB_THRESHOLD_2,
          BI.RESTRICTION_INFO,
          IST.PARTITION_POSITION,
          DIS.INDEX_NAME,
          IST.INDEX_TYPE,
          IST.COMPRESSION,
          IST.INDEX_OF_IOT,
          IST.SIZE_POS,
          IST.IO_POS
        FROM 
          INDEX_STORAGE IST,
          TABLE_MODIFICATIONS TM,
          INDEX_STATISTICS DIS,
          INDEX_ROWS IR,
          SEGMENTS S,
          BASIS_INFO BI
        WHERE 
          DIS.OWNER = IST.INDEX_OWNER AND
          DIS.INDEX_NAME = IST.INDEX_NAME AND
          NVL(DIS.PARTITION_NAME, ' ') = NVL(IST.PARTITION_NAME, ' ') AND
          DIS.OWNER = S.OWNER (+) AND
          DIS.INDEX_NAME = S.SEGMENT_NAME (+) AND
          NVL(DIS.PARTITION_NAME, ' ') = NVL(S.PARTITION_NAME (+), ' ') AND
          DIS.OWNER = TM.TABLE_OWNER AND
          DIS.TABLE_OWNER = TM.TABLE_OWNER AND
          DIS.TABLE_NAME = TM.TABLE_NAME AND
          NVL(DIS.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME, ' ') AND
          IST.INDEX_NAME = IR.INDEX_NAME AND
          IST.INDEX_OWNER = IR.INDEX_OWNER AND
          IST.INDEX_TYPE IN ( 'NORMAL', 'NORMAL/REV', 'BITMAP', 'IOT - TOP' ) AND
          (BI.MIN_SIZE_MB = -1 OR S.BYTES IS NULL OR S.BYTES / 
            1024 / 1024 >= BI.MIN_SIZE_MB ) AND
          BI.SEGMENT_TYPE IN ('ALL', 'INDEX') AND
          ( BI.INCLUDE_PARTITIONS = 'X' OR DIS.PARTITION_NAME IS NULL ) AND
          ( BI.EXCLUDE_MODIFIED_STATS != 'X' OR DIS.USER_STATS != 'YES' ) AND
          ( BI.EXCLUDE_LOCKED_STATS != 'X' OR DIS.STATTYPE_LOCKED IS NULL )
      )
    ) 
  ) 
  ORDER BY 
    DECODE(SORT_BY, 'QUALITY', QUALITY, 'UNUSED', UNUSED_MB, 1) DESC,
    DECODE(SORT_BY, 'SEGMENT', SEGMENT_NAME || PARTITION_NAME, ' ' )
) 
WHERE
  ( QUALITY_THRESHOLD = -1 AND UNUSED_MB_THRESHOLD = -1 OR
    ( ( QUALITY_THRESHOLD = -1 OR QUALITY <= QUALITY_THRESHOLD ) AND
      ( UNUSED_MB_THRESHOLD = -1 OR UNUSED_MB >= UNUSED_MB_THRESHOLD )
    ) OR
    ( ( QUALITY_THRESHOLD_2 != -1 OR UNUSED_MB_THRESHOLD_2 != -1 ) AND
      ( QUALITY_THRESHOLD_2 = -1 OR QUALITY <= QUALITY_THRESHOLD_2 ) AND
      ( UNUSED_MB_THRESHOLD_2 = -1 OR UNUSED_MB >= UNUSED_MB_THRESHOLD_2 )
    )
  ) AND
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
ORDER BY 
  DECODE(SORT_BY, 'QUALITY', QUALITY, 'UNUSED', UNUSED_MB, 1) DESC,
  DECODE(SORT_BY, 'SEGMENT', SEGMENT_NAME || PARTITION_NAME, ' ' )
)
)]]></sql>
				<binds>
					<bind id="TABLE_OWNER">
						<prompt><![CDATA[TABLE_OWNER]]></prompt>
						<tooltip><![CDATA[TABLE_OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLESPACE_NAME">
						<prompt><![CDATA[TABLESPACE_NAME]]></prompt>
						<tooltip><![CDATA[TABLESPACE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d09f3ce-014d-1000-8040-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_SegmentFragmentation_SegmentAdvisor]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_PUSH_JOIN_UNION_VIEW', 'FALSE') OPT_PARAM('_COMPLEX_VIEW_MERGING', 'FALSE') */
  NULL ANALYSIS_TIME, NULL SEGMENT_NAME, NULL PART_NAME, NULL SIZE_POS, NULL IO_POS,
  NULL UNUSED_MB, NULL "QUALITY_%", NULL GROSS_MB, NULL NET_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL ANALYSIS_TIME, NULL SEGMENT_NAME, NULL PART_NAME, NULL SIZE_POS, NULL IO_POS,
  NULL UNUSED_MB, NULL "QUALITY_%", NULL GROSS_MB, NULL NET_MB FROM DUAL WHERE 1 = 0
) UNION ALL (SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    TO_DATE('01.01.1000 14:27:44', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
    TO_DATE('31.12.9999 14:37:26', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
    NVL(:SEGMENT_NAME,'%') SEGMENT_NAME,
    'ALL' SEGMENT_TYPE,      /* TABLE, INDEX or ALL */
    -1 MIN_SIZE_MB,
    -1 NUM_RECORDS,
    -1 NUM_LARGEST_SEGMENTS,
    -1 NUM_IO_READ_SEGMENTS,
    50 QUALITY_THRESHOLD,
    100 UNUSED_MB_THRESHOLD,
    'UNUSED' SORT_BY
  FROM
    DUAL
),
SEGMENT_SELECTION AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    SEGMENT_NAME,
    SUM(SIZE_POS) SIZE_POS,
    SUM(IO_POS) IO_POS
  FROM
  ( SELECT
      OWNER,
      SEGMENT_NAME,
      SIZE_POS,
      0 IO_POS
    FROM
    ( SELECT
        S.OWNER,
        S.SEGMENT_NAME,
        ROW_NUMBER () OVER (ORDER BY SUM(S.BYTES) DESC) SIZE_POS,
        BI.NUM_LARGEST_SEGMENTS,
        BI.NUM_IO_READ_SEGMENTS
      FROM
        DBA_SEGMENTS S,
        BASIS_INFO BI
      WHERE
        S.SEGMENT_TYPE IN ('INDEX', 'INDEX PARTITION', 
          'TABLE', 'TABLE PARTITION')
      GROUP BY
        S.OWNER,
        S.SEGMENT_NAME,
        BI.NUM_LARGEST_SEGMENTS,
        BI.NUM_IO_READ_SEGMENTS
      ORDER BY
        SUM(S.BYTES) DESC
    )
    WHERE
      NUM_LARGEST_SEGMENTS = -1 OR 
      NUM_IO_READ_SEGMENTS = -1 OR 
      SIZE_POS <= NUM_LARGEST_SEGMENTS
    UNION ALL
    ( SELECT
        OWNER,
        SEGMENT_NAME,
        0 SIZE_POS,
        IO_POS
      FROM
      ( SELECT
          DECODE(NVL(O.OWNER, SSO.OWNER), 
            '** UNAVAILABLE **', NVL(O2.OWNER, 'not available'),
            NVL(O.OWNER, SSO.OWNER)) OWNER,
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, SSO.OBJECT_NAME)) SEGMENT_NAME,
          ROW_NUMBER () OVER (ORDER BY SUM(S.PHYSICAL_READS_DELTA) DESC) IO_POS,
          BI.NUM_LARGEST_SEGMENTS,
          BI.NUM_IO_READ_SEGMENTS
        FROM
          BASIS_INFO BI,
          DBA_HIST_SEG_STAT S,
          DBA_OBJECTS O,
          DBA_HIST_SEG_STAT_OBJ SSO,
          DBA_OBJECTS O2
        WHERE
          S.OBJ# = O.OBJECT_ID (+) AND
          S.DATAOBJ# = O.DATA_OBJECT_ID (+) AND
          S.OBJ# = SSO.OBJ# (+) AND
          S.DATAOBJ# = SSO.DATAOBJ# (+) AND
          S.OBJ# = O2.OBJECT_ID (+) AND
          SSO.OBJECT_TYPE IN ('INDEX', 'INDEX PARTITION',
            'TABLE', 'TABLE PARTITION')
        GROUP BY
          DECODE(NVL(O.OWNER, SSO.OWNER), 
            '** UNAVAILABLE **', NVL(O2.OWNER, 'not available'),
            NVL(O.OWNER, SSO.OWNER)),
          DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
            '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
            NVL(O.OBJECT_NAME, SSO.OBJECT_NAME)),
          BI.NUM_LARGEST_SEGMENTS,
          BI.NUM_IO_READ_SEGMENTS
      )
      WHERE
        NUM_IO_READ_SEGMENTS = -1 OR IO_POS <= NUM_IO_READ_SEGMENTS
    )
  )
  GROUP BY
    OWNER,
    SEGMENT_NAME
)
SELECT
  'SEGMENT TYPE:' ANALYSIS_TIME,
  SEGMENT_TYPE SEGMENT_NAME,
  NULL PART_NAME,
  NULL SIZE_POS,
  NULL IO_POS,
  NULL UNUSED_MB,
  NULL "QUALITY_%",
  NULL GROSS_MB,
  NULL NET_MB
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL ANALYSIS_TIME,
    NULL SEGMENT_NAME,
    NULL PART_NAME,
    NULL SIZE_POS,
    NULL IO_POS,
    NULL UNUSED_MB,
    NULL "QUALITY_%",
    NULL GROSS_MB,
    NULL NET_MB
  FROM
    DUAL
)
UNION ALL
( SELECT
    TO_CHAR(ANALYSIS_TIME, 'dd.mm.yyyy hh24:mi:ss') ANALYSIS_TIME,
    SEGMENT_NAME,
    PARTITION_NAME PART_NAME,
    DECODE(SIZE_POS, 0, ' ', TO_CHAR(SIZE_POS, 9999990)) SIZE_POS,
    DECODE(IO_POS, 0, ' ', TO_CHAR(IO_POS, 9999990)) IO_POS,
    TO_CHAR(UNUSED_MB, 999999990.99) UNUSED_MB,
    TO_CHAR("QUALITY_%", 99990.99) "QUALITY_%",
    TO_CHAR(DATA_GROSS_MB, 99999990.99) GROSS_MB,
    TO_CHAR(DATA_NET_MB, 99999990.99) NET_MB
  FROM
  ( SELECT
      ANALYSIS_TIME,
      SEGMENT_NAME,
      PARTITION_NAME,
      UNUSED_MB,
      DATA_NET_MB / DATA_GROSS_MB * 100 "QUALITY_%",
      DATA_GROSS_MB,
      DATA_NET_MB,
      MIN_SIZE_MB,
      NUM_RECORDS,
      QUALITY_THRESHOLD,
      UNUSED_MB_THRESHOLD,
      SORT_BY,
      SIZE_POS,
      IO_POS
    FROM
    ( SELECT
        ANALYSIS_TIME,
        OWNER,
        SEGMENT_NAME,
        PARTITION_NAME,
        SEGMENT_TYPE,
        MESSAGE,
        MORE_INFO,
        DECODE(SIGN(INSTR(MORE_INFO, 'Allocated Space')), 1,
          REGEXP_REPLACE(MORE_INFO,'.*Allocated Space:([0-9]+):.*', 
          '\1', 1, 1, 'i') / 1024 / 1024, 0) DATA_GROSS_MB,
        DECODE(SIGN(INSTR(MORE_INFO, 'Used Space')), 1,
          REGEXP_REPLACE(MORE_INFO,'.*Used Space:([0-9]+):.*', 
          '\1', 1, 1, 'i') / 1024 / 1024, 0) DATA_NET_MB,
        DECODE(SIGN(INSTR(MORE_INFO, 'Reclaimable Space')), 1,
          REGEXP_REPLACE(MORE_INFO,
          '.*Reclaimable Space[ ]*:([0-9]+):.*', 
          '\1', 1, 1, 'i') / 1024 / 1024, 0) UNUSED_MB,
        MIN_SIZE_MB,
        NUM_RECORDS,
        QUALITY_THRESHOLD,
        UNUSED_MB_THRESHOLD,
        SORT_BY,
        SIZE_POS,
        IO_POS
      FROM
      ( SELECT
          DAT.EXECUTION_START ANALYSIS_TIME,
          DAO.ATTR1 OWNER,
          DAO.ATTR2 SEGMENT_NAME,
          DAO.ATTR3 PARTITION_NAME,
          DAO.TYPE SEGMENT_TYPE,
          DAF.MESSAGE MESSAGE,
          DAF.MORE_INFO,
          ROW_NUMBER () OVER (PARTITION BY DAO.ATTR1, DAO.ATTR2, 
            NVL(DAO.ATTR3, ' ') ORDER BY DAT.EXECUTION_START DESC) ROW_NUMBER,
          BI.MIN_SIZE_MB,
          BI.NUM_RECORDS,
          BI.QUALITY_THRESHOLD,
          BI.UNUSED_MB_THRESHOLD,
          BI.SORT_BY,
          S.SIZE_POS,
          S.IO_POS
        FROM
          BASIS_INFO BI,
          SEGMENT_SELECTION S,
          DBA_ADVISOR_TASKS DAT,
          DBA_ADVISOR_FINDINGS DAF,
          DBA_ADVISOR_OBJECTS DAO
        WHERE
          DAO.ATTR1 LIKE BI.OWNER AND
          DAO.ATTR2 LIKE BI.SEGMENT_NAME AND
          DAO.ATTR1 = S.OWNER AND
          DAO.ATTR2 = S.SEGMENT_NAME AND
          DAT.OWNER = DAF.OWNER AND
          DAT.TASK_ID = DAF.TASK_ID AND
          DAF.TASK_ID = DAO.TASK_ID AND
          DAF.OBJECT_ID = DAO.OBJECT_ID AND
          DAT.ADVISOR_NAME = 'Segment Advisor' AND
          DAF.MORE_INFO LIKE 'Alloc%' AND
          ( BI.SEGMENT_TYPE = 'ALL' OR DAO.TYPE LIKE BI.SEGMENT_TYPE || '%' ) AND
          ( DAT.EXECUTION_START BETWEEN BI.BEGIN_DATE AND BI.END_DATE )
      ) 
      WHERE
        ROW_NUMBER = 1
    )
    WHERE
      DATA_GROSS_MB > 0
    ORDER BY
      DECODE ( SORT_BY, 'UNUSED', 100000000 - UNUSED_MB, 
        'QUALITY', "QUALITY_%" ) 
  )
  WHERE
    ( MIN_SIZE_MB = -1 OR DATA_GROSS_MB >= MIN_SIZE_MB ) AND
    ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS ) AND
    ( QUALITY_THRESHOLD = -1 OR "QUALITY_%" <= QUALITY_THRESHOLD ) AND
    ( UNUSED_MB_THRESHOLD = -1 OR UNUSED_MB >= UNUSED_MB_THRESHOLD )
)
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SEGMENT_NAME">
						<prompt><![CDATA[SEGMENT_NAME]]></prompt>
						<tooltip><![CDATA[SEGMENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d0b1505-014d-1000-8041-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_SegmentFragmentationAndChainedRows_DBMS_SPACE_CommandGenerator]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL LINE FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL LINE FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    NVL(:OWNER,'%') OWNER,
    NVL(:SEGMENT_NAME,'%') SEGMENT_NAME,
    '%' SEGMENT_TYPE,                /* TABLE, TABLE PARTITION, INDEX, INDEX PARTITION, LOBSEGMENT */
    -1 MIN_SIZE_MB,
    'UNUSED' SORT_BY            /* UNUSED, QUALITY, SEGMENT, CHAINED_ROWS */
  FROM
    DUAL
),
SEGMENTS AS
( SELECT
    S.OWNER,
    S.SEGMENT_NAME,
    S.PARTITION_NAME,
    DECODE(S.SEGMENT_TYPE, 'LOBSEGMENT', 'LOB', S.SEGMENT_TYPE) SEGMENT_TYPE,
    S.BYTES / 1024 / 1024 SEG_SIZE_MB,
    ROWNUM SEG_POS
  FROM
    BASIS_INFO BI,
    DBA_SEGMENTS S
  WHERE
    S.OWNER LIKE BI.OWNER AND
    S.SEGMENT_NAME LIKE BI.SEGMENT_NAME AND
    S.SEGMENT_TYPE LIKE BI.SEGMENT_TYPE AND
    S.BYTES >= BI.MIN_SIZE_MB * 1024 * 1024
)
SELECT 'SELECT NULL OWNER, NULL SEGMENT_NAME, NULL PART_NAME,' FROM DUAL
UNION ALL
( SELECT '  NULL SEGMENT_TYPE, NULL UNUSED_MB,' FROM DUAL )
UNION ALL
( SELECT '  NULL "QUALITY_%", NULL GROSS_MB, NULL NET_MB,' FROM DUAL )
UNION ALL
( SELECT '  NULL "CHAIN_%" FROM DUAL WHERE 1 = 0' FROM DUAL )
UNION ALL
( SELECT 'UNION ALL (' FROM DUAL )
UNION ALL
( SELECT 'SELECT NULL OWNER, NULL SEGMENT_NAME, NULL PART_NAME,' FROM DUAL )
UNION ALL
( SELECT '  NULL SEGMENT_TYPE, NULL UNUSED_MB,' FROM DUAL )
UNION ALL
( SELECT '  NULL "QUALITY_%", NULL GROSS_MB, NULL NET_MB,' FROM DUAL )
UNION ALL
( SELECT '  NULL "CHAIN_%" FROM DUAL WHERE 1 = 0' FROM DUAL )
UNION ALL
( SELECT ') UNION ALL ( SELECT * FROM (' FROM DUAL )
UNION ALL
( SELECT 'SELECT' FROM DUAL )
UNION ALL
( SELECT '  OWNER, SEGMENT_NAME, PART_NAME, SEGMENT_TYPE, UNUSED_MB,' FROM DUAL )
UNION ALL
( SELECT '  "QUALITY_%", GROSS_MB, NET_MB, "CHAIN_%"' FROM DUAL )
UNION ALL
( SELECT 'FROM (' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT 
      LINE_TEXT LINE 
    FROM
    ( SELECT SEG_POS, 1 LINE_POS, '( SELECT' LINE_TEXT FROM SEGMENTS
      UNION ALL
      ( SELECT SEG_POS,  2, '    ''' || OWNER || ''' OWNER,'  FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS,  3, '    ''' || SEGMENT_NAME || ''' SEGMENT_NAME,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS,  4, '    ''' || PARTITION_NAME || ''' PART_NAME,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS,  5, '    ''' || SEGMENT_TYPE || ''' SEGMENT_TYPE,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 10, '    TO_CHAR((SPACE_ALLOCATED - SPACE_USED) / 1024 / 1024, 999990.99) UNUSED_MB,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 11, '    TO_CHAR(SPACE_USED / SPACE_ALLOCATED * 100, 99990.99) "QUALITY_%",' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 12, '    TO_CHAR(SPACE_ALLOCATED / 1024 / 1024, 9999990.99) GROSS_MB,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 13, '    TO_CHAR(SPACE_USED / 1024 / 1024, 9999990.99) NET_MB,' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 14, '    TO_CHAR(CHAIN_PCENT, 999990) "CHAIN_%"' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 20, '  FROM' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 22, '    TABLE(DBMS_SPACE.OBJECT_SPACE_USAGE_TBF(''' || OWNER || ''', ''' || SEGMENT_NAME || ''',' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 23, '      ''' || SEGMENT_TYPE || ''', NULL' || DECODE(PARTITION_NAME, NULL, NULL, ', ''' || PARTITION_NAME || '''') || '))' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 26, ')' FROM SEGMENTS )
      UNION ALL
      ( SELECT SEG_POS, 27, 'UNION ALL' FROM SEGMENTS )
    )
    ORDER BY
      SEG_POS,
      LINE_POS
  )
)
UNION ALL
( SELECT '( SELECT NULL, NULL, NULL, NULL, NULL, NULL,' FROM DUAL )
UNION ALL
( SELECT '    NULL, NULL, NULL FROM DUAL WHERE 1 = 0 )' FROM DUAL )
UNION ALL
( SELECT ')' FROM DUAL )
UNION ALL
( SELECT 'ORDER BY' FROM DUAL )
UNION ALL
( SELECT '  ' || DECODE(SORT_BY, 'SEGMENT', 'OWNER || SEGMENT_NAME', 'QUALITY', '"QUALITY_%"', 'UNUSED',
    'UNUSED_MB DESC', 'CHAINED ROWS', '"CHAIN_%" DESC') FROM BASIS_INFO )
UNION ALL
( SELECT '));' FROM DUAL )
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SEGMENT_NAME">
						<prompt><![CDATA[SEGMENT_NAME]]></prompt>
						<tooltip><![CDATA[SEGMENT_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d14ed3b-014d-1000-8042-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[DBMS_SPACE_Usage]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT
  OWNER, SEGMENT_NAME, PART_NAME, SEGMENT_TYPE, UNUSED_MB,
  "QUALITY_%", GROSS_MB, NET_MB, "CHAIN_%"
FROM (
( SELECT
    :OWNER OWNER,
    :SEGMENT_NAME SEGMENT_NAME,
    '' PART_NAME,
    :SEGMENT_TYPE SEGMENT_TYPE,
    TO_CHAR((SPACE_ALLOCATED - SPACE_USED) / 1024 / 1024, 999990.99) UNUSED_MB,
    TO_CHAR(SPACE_USED / SPACE_ALLOCATED * 100, 99990.99) "QUALITY_%",
    TO_CHAR(SPACE_ALLOCATED / 1024 / 1024, 9999990.99) GROSS_MB,
    TO_CHAR(SPACE_USED / 1024 / 1024, 9999990.99) NET_MB,
    TO_CHAR(CHAIN_PCENT, 999990) "CHAIN_%"
  FROM
    TABLE(DBMS_SPACE.OBJECT_SPACE_USAGE_TBF(:OWNER, :SEGMENT_NAME,
      :SEGMENT_TYPE, NULL))
)
ORDER BY
  UNUSED_MB DESC
)]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[SIEBEL]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SEGMENT_NAME">
						<prompt><![CDATA[SEGMENT_NAME]]></prompt>
						<tooltip><![CDATA[SEGMENT_NAME]]></tooltip>
						<value><![CDATA[S_CONTACT]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="SEGMENT_TYPE">
						<prompt><![CDATA[SEGMENT_TYPE]]></prompt>
						<tooltip><![CDATA[SEGMENT_TYPE]]></tooltip>
						<value><![CDATA[TABLE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d1930ef-014d-1000-8043-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_SegmentSizes_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  NULL POS, NULL SEGMENT_NAME, NULL SEGMENT_TYPE, NULL TABLESPACE_NAME, 
  NULL PARTITIONS, NULL SIZE_MB, NULL EXTENTS, NULL COMPRESSION FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL POS, NULL SEGMENT_NAME, NULL SEGMENT_TYPE, NULL TABLESPACE_NAME, 
  NULL PARTITIONS, NULL SIZE_MB, NULL EXTENTS, NULL COMPRESSION FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /* 11g: Table compression, SecureFile compression */ 
    NVL(:OWNER,'%') OWNER,
    NVL(:TABLE_NAME,'%') TABLE_NAME,
    NVL(:TABLESPACE_NAME,'%') TABLESPACE_NAME,
    '%' SEGMENT_TYPE,  /* TABLE, INDEX, TABLE PARTITION, INDEX PARTITION, LOB%, LOBSEGMENT, LOBINDEX, TEMPORARY, CLUSTER */
    'PARTITION' AGGREGATE_BY,    /* PARTITION, GLOBAL */
    'SIZE' ORDER_BY,       /* SIZE, SEGMENT */
    100 NUM_RECORDS
  FROM 
    DUAL
),
SEGMENT_NAMES AS
( SELECT
    DT.OWNER OWNER,
    DT.TABLE_NAME SEGMENT_NAME,
    NULL PARTITION_NAME,
    DT.COMPRESS_FOR COMPRESSION,
    NULL ADDITIONAL_INFO
  FROM
    BASIS_INFO BI,
    DBA_TABLES DT
  WHERE
    DT.OWNER LIKE BI.OWNER AND
    DT.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
    DT.TABLE_NAME LIKE BI.TABLE_NAME
  UNION ALL
  ( SELECT
      DT.OWNER OWNER,
      DTP.TABLE_NAME SEGMENT_NAME,
      DTP.PARTITION_NAME,
      DTP.COMPRESS_FOR COMPRESSION,
      NULL ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_TABLES DT,
      DBA_TAB_PARTITIONS DTP
    WHERE
      DT.OWNER LIKE BI.OWNER AND
      DTP.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      DT.TABLE_NAME LIKE BI.TABLE_NAME AND
      DTP.TABLE_OWNER = DT.OWNER AND
      DTP.TABLE_NAME = DT.TABLE_NAME
  )
  UNION ALL
  ( SELECT
      DI.OWNER OWNER,
      DI.INDEX_NAME SEGMENT_NAME,
      NULL PARTITION_NAME,
      DECODE(DI.COMPRESSION, 'ENABLED', 'Yes (' || DI.PREFIX_LENGTH || ')') COMPRESSION,
      NULL ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_INDEXES DI
    WHERE
      DI.TABLE_OWNER LIKE BI.OWNER AND
      DI.TABLE_NAME LIKE BI.TABLE_NAME AND
      DI.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      DI.INDEX_TYPE != 'LOB'
  )
  UNION ALL
  ( SELECT
      DI.OWNER OWNER,
      DIP.INDEX_NAME SEGMENT_NAME,
      DIP.PARTITION_NAME,
      DECODE(DIP.COMPRESSION, 'ENABLED', 'Yes (' || DI.PREFIX_LENGTH || ')') COMPRESSION,
      NULL ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_INDEXES DI,
      DBA_IND_PARTITIONS DIP
    WHERE
      DI.TABLE_OWNER LIKE BI.OWNER AND
      DI.TABLE_NAME LIKE BI.TABLE_NAME AND
      DIP.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      DIP.INDEX_OWNER = DI.OWNER AND
      DIP.INDEX_NAME = DI.INDEX_NAME AND
      DI.INDEX_TYPE != 'LOB'
  )
  UNION ALL
  ( SELECT
      L.OWNER,
      L.SEGMENT_NAME,
      NULL PARTITION_NAME,
      DECODE(L.COMPRESSION, 'NO', NULL, 'NONE', NULL, L.COMPRESSION) COMPRESSION,
      L.TABLE_NAME || '.' || L.COLUMN_NAME ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_LOBS L
    WHERE
      L.OWNER LIKE BI.OWNER AND
      L.TABLE_NAME LIKE BI.TABLE_NAME AND
      L.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME
  )
  UNION ALL
  ( SELECT
      L.OWNER,
      L.INDEX_NAME SEGMENT_NAME,
      NULL PARTITION_NAME,
      NULL COMPRESSION,
      L.TABLE_NAME || '.' || L.COLUMN_NAME ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_LOBS L
    WHERE
      L.OWNER LIKE BI.OWNER AND
      L.TABLE_NAME LIKE BI.TABLE_NAME AND
      L.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME
  )
  UNION ALL
  ( SELECT
      S.OWNER,
      S.SEGMENT_NAME,
      S.PARTITION_NAME,
      NULL COMPRESSION,
      NULL ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_SEGMENTS S
    WHERE
      S.OWNER LIKE BI.OWNER AND
      S.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      BI.SEGMENT_TYPE = 'TEMPORARY' AND
      S.SEGMENT_TYPE = 'TEMPORARY'
  )
  UNION ALL
  ( SELECT
      C.OWNER,
      C.CLUSTER_NAME SEGMENT_NAME,
      NULL PARTITION_NAME,
      NULL COMPRESSION,
      NULL ADDITIONAL_INFO
    FROM
      BASIS_INFO BI,
      DBA_CLUSTERS C
    WHERE
      C.OWNER LIKE BI.OWNER AND
      C.CLUSTER_NAME LIKE BI.TABLE_NAME AND
      C.TABLESPACE_NAME LIKE BI.TABLESPACE_NAME AND
      'CLUSTER' LIKE BI.SEGMENT_TYPE 
  )
)
SELECT
  TO_CHAR(ROWNUM, 990) POS,
  SEGMENT_NAME,
  SEGMENT_TYPE,
  TABLESPACE_NAME,
  PARTITIONS,
  SIZE_MB,
  EXTENTS,
  COMPRESSION
FROM
( SELECT
    SEGMENT_NAME,
    SEGMENT_TYPE,
    TABLESPACE_NAME,
    TO_CHAR(PARTITIONS, 999999990) PARTITIONS,
    TO_CHAR(BYTES / 1024 / 1024, 9999990.99) SIZE_MB,
    TO_CHAR(EXTENTS, 999990) EXTENTS,
    COMPRESSION,
    NUM_RECORDS
 FROM
  (  SELECT
      DECODE(SUBSTR(DS.SEGMENT_TYPE, 1, 3), 
        'LOB', SN.ADDITIONAL_INFO || ' (' || DS.SEGMENT_NAME || ')',
        DS.SEGMENT_NAME) || 
        DECODE(BI.AGGREGATE_BY, 'PARTITION', 
          DECODE(SN.PARTITION_NAME, NULL, NULL, '.' || SN.PARTITION_NAME)) SEGMENT_NAME,
      DS.SEGMENT_TYPE SEGMENT_TYPE,
      DS.TABLESPACE_NAME TABLESPACE_NAME,
      SUM(DECODE(DS.PARTITION_NAME, NULL, 0, 1)) PARTITIONS,
      SUM(DS.BYTES) BYTES,
      SUM(DS.EXTENTS) EXTENTS,
      SN.COMPRESSION,
      BI.ORDER_BY,
      BI.NUM_RECORDS
    FROM
      BASIS_INFO BI,
      DBA_SEGMENTS DS,
      SEGMENT_NAMES SN
    WHERE
      DS.OWNER = SN.OWNER AND
      DS.SEGMENT_NAME = SN.SEGMENT_NAME AND
      (SN.PARTITION_NAME IS NULL OR DS.PARTITION_NAME = SN.PARTITION_NAME ) AND
      DS.SEGMENT_TYPE LIKE BI.SEGMENT_TYPE
    GROUP BY
      DS.SEGMENT_TYPE,
      SN.COMPRESSION,
      SN.ADDITIONAL_INFO,
      DECODE(BI.AGGREGATE_BY, 'PARTITION', 
          DECODE(SN.PARTITION_NAME, NULL, NULL, '.' || SN.PARTITION_NAME)),
      DS.SEGMENT_NAME,
      DS.TABLESPACE_NAME,
      BI.ORDER_BY,
      BI.NUM_RECORDS
  )
  ORDER BY
    DECODE(ORDER_BY, 'SIZE', BYTES) DESC,
    DECODE(ORDER_BY, 'SEGMENT', SEGMENT_NAME)
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLESPACE_NAME">
						<prompt><![CDATA[TABLESPACE_NAME]]></prompt>
						<tooltip><![CDATA[TABLESPACE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d1b1c87-014d-1000-8044-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Space_Tablespaces]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TSP_NAME, NULL TABLESPACE_TYPE, NULL ALLOC_GB, NULL "DB_%", 
  NULL AUTOEXT_GB, NULL USED_GB, NULL "USED_%", NULL FREE_GB, NULL FILES, 
  NULL SEGMENTS, NULL EXTENTS
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TSP_NAME, NULL TABLESPACE_TYPE, NULL ALLOC_GB, NULL "ALLOC_%", 
  NULL AUTOEXT_GB, NULL USED_GB, NULL "USED_%", NULL FREE_GB, NULL FILES, 
  NULL SEGMENTS, NULL EXTENTS
FROM DUAL WHERE 1 = 0
) UNION ALL (SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    ' ' INCLUDE_USAGE_METRICS,
    'TABLESPACE' AGGREGATE_BY,
    'SIZE' ORDER_BY,
    '%' TABLESPACE_PATTERN_1,
    '%' TABLESPACE_PATTERN_2,
    TO_DATE('01.01.1000 01:00:00', 'dd.mm.yyyy hh24:mi:ss') CREATED_MIN_TIME,
    TO_DATE('01.01.1000 01:00:00', 'dd.mm.yyyy hh24:mi:ss') LAST_DDL_MIN_TIME
  FROM
    DUAL
),
TABLESPACES AS
( SELECT
    TS.TABLESPACE_NAME,
    TS.CONTENTS,
    COUNT(*) DATAFILES,
    SUM(DF.BYTES) BYTES,
    MAX(TUM.TABLESPACE_SIZE) * MAX(TS.BLOCK_SIZE) ALLOC_BYTES_USAGE_METRIC,
    MAX(TUM.USED_SPACE) * MAX(TS.BLOCK_SIZE) USED_BYTES_USAGE_METRIC,
    DECODE(TS.EXTENT_MANAGEMENT, 'DICTIONARY', 'DMTS', 'LMTS') || '/' ||
      SUBSTR(TS.CONTENTS, 1, 1) || 
      DECODE(TS.ALLOCATION_TYPE, 'SYSTEM', ' (SYS)', 'UNIFORM', 
      ' (UNI ' || ROUND(TS.MIN_EXTLEN / 1024 / 1024) || 'M)') ||
      DECODE(TS.SEGMENT_SPACE_MANAGEMENT, 'AUTO', ', ASSM') TABLESPACE_TYPE,
    SUM(DECODE(DF.AUTOEXTENSIBLE, 'NO', DF.BYTES, DF.MAXBYTES)) MAX_BYTES
  FROM
    BASIS_INFO BI,
    DBA_DATA_FILES DF,
    DBA_TABLESPACES TS,
    DBA_TABLESPACE_USAGE_METRICS TUM
  WHERE
    ( BI.TABLESPACE_PATTERN_1 = '%' AND BI.TABLESPACE_PATTERN_2 = '%' OR
      BI.TABLESPACE_PATTERN_1 != '%' AND DF.TABLESPACE_NAME LIKE BI.TABLESPACE_PATTERN_1 OR
      BI.TABLESPACE_PATTERN_2 != '%' AND DF.TABLESPACE_NAME LIKE BI.TABLESPACE_PATTERN_2 ) AND
    DF.TABLESPACE_NAME = TS.TABLESPACE_NAME AND
    DF.TABLESPACE_NAME = TUM.TABLESPACE_NAME (+)
  GROUP BY
    TS.TABLESPACE_NAME,
    TS.CONTENTS,
    TS.EXTENT_MANAGEMENT,
    TS.CONTENTS,
    TS.ALLOCATION_TYPE,
    TS.MIN_EXTLEN,
    TS.SEGMENT_SPACE_MANAGEMENT,
    BI.TABLESPACE_PATTERN_1,
    BI.TABLESPACE_PATTERN_2
  UNION ALL
  ( SELECT
      TS.TABLESPACE_NAME,
      TS.CONTENTS,
      COUNT(*) DATAFILES,
      SUM(TF.BYTES) BYTES,
      MAX(TUM.TABLESPACE_SIZE) * MAX(TS.BLOCK_SIZE) ALLOC_BYTES_USAGE_METRIC,
      MAX(TUM.USED_SPACE) * MAX(TS.BLOCK_SIZE) USED_BYTES_USAGE_METRIC,
      DECODE(TS.EXTENT_MANAGEMENT, 'DICTIONARY', 'DMTS', 'LMTS') || '/' ||
        SUBSTR(TS.CONTENTS, 1, 1) || 
        DECODE(TS.ALLOCATION_TYPE, 'SYSTEM', ' (SYS)', 'UNIFORM', 
        ' (UNI ' || ROUND(TS.MIN_EXTLEN / 1024 / 1024) || 'M)') ||
        DECODE(TS.SEGMENT_SPACE_MANAGEMENT, 'AUTO', ', ASSM') TABLESPACE_TYPE,
      SUM(DECODE(AUTOEXTENSIBLE, 'NO', TF.BYTES, TF.MAXBYTES)) MAX_BYTES
    FROM
      BASIS_INFO BI,
      DBA_TEMP_FILES TF,
      DBA_TABLESPACES TS,
      DBA_TABLESPACE_USAGE_METRICS TUM
    WHERE
    ( BI.TABLESPACE_PATTERN_1 = '%' AND BI.TABLESPACE_PATTERN_2 = '%' OR
      BI.TABLESPACE_PATTERN_1 != '%' AND TF.TABLESPACE_NAME LIKE BI.TABLESPACE_PATTERN_1 OR
      BI.TABLESPACE_PATTERN_2 != '%' AND TF.TABLESPACE_NAME LIKE BI.TABLESPACE_PATTERN_2 ) AND
      TF.TABLESPACE_NAME = TS.TABLESPACE_NAME AND
      TF.TABLESPACE_NAME = TUM.TABLESPACE_NAME (+)
    GROUP BY
      TS.TABLESPACE_NAME,
      TS.CONTENTS,
      TS.EXTENT_MANAGEMENT,
      TS.CONTENTS,
      TS.ALLOCATION_TYPE,
      TS.MIN_EXTLEN,
      TS.SEGMENT_SPACE_MANAGEMENT,
      BI.TABLESPACE_PATTERN_1,
      BI.TABLESPACE_PATTERN_2
  )
),
SEGMENTS AS
( SELECT
    S.TABLESPACE_NAME,
    COUNT(*) SEGMENTS,
    SUM(S.BYTES) BYTES,
    SUM(S.EXTENTS) EXTENTS
  FROM
    BASIS_INFO BI,
    DBA_OBJECTS O,
    DBA_SEGMENTS S
  WHERE
    O.OWNER = S.OWNER AND
    O.OBJECT_NAME = S.SEGMENT_NAME AND
    NVL(O.SUBOBJECT_NAME, ' ') = NVL(S.PARTITION_NAME, ' ') AND
    O.CREATED >= BI.CREATED_MIN_TIME AND
    O.LAST_DDL_TIME >= BI.LAST_DDL_MIN_TIME
  GROUP BY
    TABLESPACE_NAME
  UNION ALL
  ( SELECT
      TABLESPACE_NAME,
      0 SEGMENTS,
      SUM(BYTES_USED) BYTES,
      SUM(EXTENTS_USED) EXTENTS
    FROM
      GV$TEMP_EXTENT_POOL  
    GROUP BY
      TABLESPACE_NAME
  )
)
SELECT
  DECODE(BI.AGGREGATE_BY, 'TABLESPACE', T.TABLESPACE_NAME, 'CONTENT', T.CONTENTS) AREA,
  DECODE(BI.AGGREGATE_BY, 'TABLESPACE', T.TABLESPACE_TYPE, 'CONTENT', 'n/a') TABLESPACE_TYPE,
  TO_CHAR(SUM(T.BYTES) / 1024 / 1024 / 1024, 99990.99) ALLOC_GB,
  TO_CHAR(RATIO_TO_REPORT(SUM(T.BYTES)) OVER () * 100, 990.99) "DB_%",
  TO_CHAR(SUM(T.MAX_BYTES) / 1024 / 1024 / 1024, 9999990.99) || DECODE(BI.INCLUDE_USAGE_METRICS, 'X', ' (' || 
    DECODE(SUM(T.ALLOC_BYTES_USAGE_METRIC), NULL, '     n/a', 
    TO_CHAR(SUM(T.ALLOC_BYTES_USAGE_METRIC) / 1024 / 1024 / 1024, 9990.99)) || ')') AUTOEXT_GB,
  TO_CHAR(SUM(NVL(S.BYTES, 0)) / 1024 / 1024 / 1024, 99990.99)  || DECODE(BI.INCLUDE_USAGE_METRICS, 'X', ' (' || 
    DECODE(SUM(T.USED_BYTES_USAGE_METRIC), NULL, '     n/a', 
    TO_CHAR(SUM(T.USED_BYTES_USAGE_METRIC) / 1024 / 1024 / 1024, 9990.99)) || ')') USED_GB,
  TO_CHAR(SUM(NVL(S.BYTES, 0)) / SUM(T.BYTES) * 100, 990.99) "USED_%",
  TO_CHAR((SUM(T.BYTES) - SUM(NVL(S.BYTES, 0))) / 1024 / 1024 / 1024, 9990.99) FREE_GB,
  TO_CHAR(SUM(T.DATAFILES), 9990) FILES,
  TO_CHAR(SUM(NVL(S.SEGMENTS, 0)), 9999990) SEGMENTS,
  TO_CHAR(SUM(NVL(S.EXTENTS, 0)), 9999990) EXTENTS
FROM
  TABLESPACES T,
  SEGMENTS S,
  BASIS_INFO BI
WHERE
  T.TABLESPACE_NAME = S.TABLESPACE_NAME (+)
GROUP BY
  DECODE(BI.AGGREGATE_BY, 'TABLESPACE', T.TABLESPACE_NAME, 'CONTENT', T.CONTENTS),
  DECODE(BI.AGGREGATE_BY, 'TABLESPACE', T.TABLESPACE_TYPE, 'CONTENT', 'n/a'),
  BI.INCLUDE_USAGE_METRICS,
  BI.ORDER_BY
ORDER BY
  DECODE(BI.ORDER_BY, 
    'SIZE', SUM(T.BYTES),
    'AUTOEXT_SIZE', SUM(T.MAX_BYTES), 
    'FREESPACE', SUM(T.BYTES) - SUM(NVL(S.BYTES, 0)), 1) DESC,
  DECODE(BI.ORDER_BY,
    'NAME', DECODE(BI.AGGREGATE_BY, 'TABLESPACE', T.TABLESPACE_NAME, 'CONTENT', T.CONTENTS))
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[SQL]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2d1e8894-014d-1000-8045-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_DataCollector_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT   
  /*+ OPT_PARAM('_COMPLEX_VIEW_MERGING', 'FALSE') 
      OPT_PARAM('_CONNECT_BY_USE_UNION_ALL', 'FALSE')
      OPT_PARAM('_OPTIMIZER_CARTESIAN_ENABLED', 'FALSE') 
      OPT_PARAM('_OPTIMIZER_COST_BASED_TRANSFORMATION', 'FALSE') 
      OPT_PARAM('_OPTIMIZER_DISTINCT_AGG_TRANSFORM', 'FALSE') 
      OPT_PARAM('_OPTIMIZER_GROUP_BY_PLACEMENT', 'FALSE') 
      OPT_PARAM('_OPTIMIZER_JOIN_SEL_SANITY_CHECK', 'FALSE') 
      OPT_PARAM('_OPTIMIZER_MJC_ENABLED', FALSE) 
      OPT_PARAM('_OPTIMIZER_NEW_JOIN_CARD_COMPUTATION', 'FALSE') 
      OPT_PARAM('_PUSH_JOIN_UNION_VIEW', 'FALSE') 
      OPT_PARAM('_PUSH_JOIN_UNION_VIEW2', 'FALSE') 
      OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE')
      OPT_PARAM('QUERY_REWRITE_ENABLED', 'FALSE')
  */
/*
  SQL_ID DATA COLLECTOR for Oracle >= 11.2.0.1
  Description:  Collection of comprehensive information for a SQL statement with a given SQL_ID
  Version:      1.92 (June, 28th 2012)
  Author:       Martin Frauendorfer (SAP Active Global Support)
  Feedback:     martin.frauendorfer@sap.com
  Performance:  Runtime up to 10 minutes is acceptable, in case of longer runtime check the following:
                - Proper Oracle parameters (SAP Note 1431798)
                - Current Oracle patches 
                - Existence of DDIC and fixed objects statistics (SAP Note 838725)
                - DBA_SEGMENTS optimizations (SAP Note 871455)
                - Exclude output components based on the AREA_ACTIVATION section below
  Restrictions: - Oracle Diagnostics Pack must be licensed
                - In RAC environments only the current instance is taken into account.
  Changes:      Compared to the Oracle 10g variant the following changes are introduced:
                - Various parameters set to FALSE via hint in order to avoid problems
                - PLAN_ID aggregation of ASH samples
                - Removal of STALE information for fragmentation in order to avoid ORA-20001
                - Usage of SQL_OPNAME in ASH rather than joining with AUDIT_ACTIONS
                - SQL statement text based on VARCHAR2 columns instead of LOB columns in order to
                  avoid terminations
                - V$SQLSTATS partially replaced with V$SQLSTATS_PLAN_HASH
                - V$SQLTEXT.PIECE fragments are concatenated using LISTAGG
                - TOP_LEVEL_SQL_ID from ASH
                - Table compression information
                - ASH: SQL activity (SQL_EXEC, SOFT_PARSE, HARD_PARSE, BIND, CONN_MGMT, PLSQL_EXEC, PLSQL_RPC, PLSQL_COMP, JAVA_EXEC, CUR_CLOSE, SEQ_LOAD)
                - ASH: PGA and TEMP information
                - SQL monitoring (GV$SQL_MONITOR, GV$SQL_PLAN_MONITOR)
                - SECUREFILE LOBs including COMPRESSION and DEDUPLICATION
                - SQL profiles, patches and plan baselines
  Usage:
    DBACOCKPIT (SQL Command Editor):
      Replace &&sql_id at all locations with the SQL_ID you want to analyze
      Execute
      Choose monospaced output (e.g. "List" -> "Print Preview" or "List Output") for better readability
    SQLPLUS:
      Make sure that client terminal has configured width of >= 250 characters
      sqlplus / as sysdba
      COLUMN PART1 FORMAT A80
      COLUMN PART2 FORMAT A80
      COLUMN PART3 FORMAT A80
      SET LINESIZE 250
      SET PAGESIZE 0
      SET VERIFY OFF
      SPOOL sql.out
      @SQL_SQL_ID_DataCollector_11g+.txt
      <sql_id>
      SPOOL OFF
      EXIT
      Display generated text file sql.out
*/
  SUBSTR(LINE, 1, 80) PART1,
  SUBSTR(LINE, 81, 80) PART2,
  SUBSTR(LINE, 161, 80) PART3
FROM (
( SELECT
NULL LINE FROM DUAL WHERE 1 = 0 )
UNION ALL
( SELECT NULL LINE FROM DUAL WHERE 1 = 0 )
UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    SQL_ID,
    SEGMENT_INFO,
    COMPLEX_INDEX_STATS,
    ASH_INFO,
    FRAGMENTATION_INFO,
    VIEW_INFO,
    INDEX_COLUMNS,
    COMPLEX_SQL_TEXT,
    AWR_BEGIN_DATE, 
    AWR_END_DATE,
    INCLUDE_PREDICATES
  FROM
  ( SELECT
      -1 DBID,
      '&&sql_id' SQL_ID,
      'X' SEGMENT_INFO,
      ' ' COMPLEX_INDEX_STATS,
      'X' ASH_INFO,
      'X' FRAGMENTATION_INFO,
      'X' VIEW_INFO,
      'X' INDEX_COLUMNS,
      'X' COMPLEX_SQL_TEXT,
      'X' INCLUDE_PREDICATES,
      SYSDATE - 43 AWR_BEGIN_DATE,
      SYSDATE AWR_END_DATE
    FROM
      DUAL 
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */
    MIN(SS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(SS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(SS.SNAP_ID) END_SNAP_ID,
    MAX(SS.END_INTERVAL_TIME) END_TIME,
    SUM(TO_CHAR(SS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(SS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(SS.BEGIN_INTERVAL_TIME, 'J')))
      SECONDS
  FROM 
    DBA_HIST_SNAPSHOT SS,
    BASIS_INFO BI
  WHERE
    SS.DBID = BI.DBID AND
    SS.BEGIN_INTERVAL_TIME >= BI.AWR_BEGIN_DATE AND
    SS.END_INTERVAL_TIME <= BI.AWR_END_DATE
),
OBJECTS AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    OBJECT_NAME,
    SUBOBJECT_NAME,
    OBJECT_TYPE,
    OBJECT_ID,
    DATA_OBJECT_ID,
    CREATED,
    LAST_DDL_TIME
  FROM
    DBA_OBJECTS
),
SQL_TEXT AS 
( SELECT /*+ MATERIALIZE */
    SQL_TEXT,
    LENGTH(SQL_TEXT) LENGTH,
    LENGTH(REGEXP_REPLACE(SQL_TEXT, '[^ ]', '')) NUM_BLANKS,
    LENGTH(REGEXP_REPLACE(SQL_TEXT, '[^,]', '')) NUM_COMMA
  FROM
  ( SELECT
      REPLACE(REPLACE(REPLACE(SQL_TEXT, CHR(10), NULL), CHR(9), NULL), CHR(0), NULL) SQL_TEXT 
    FROM
    ( SELECT DISTINCT
        LISTAGG(SQL_TEXT) WITHIN GROUP (ORDER BY PIECE) OVER () SQL_TEXT
      FROM
      ( SELECT
          ST.SQL_TEXT,
          ST.PIECE
        FROM
          BASIS_INFO BI,
          V$SQLTEXT ST
        WHERE
          ST.SQL_ID = '&&sql_id'
        UNION ALL 
        ( SELECT 
            TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 3264)) SQL_TEXT,
            1 PIECE
          FROM
            BASIS_INFO BI,
            DBA_HIST_SQLTEXT HST
          WHERE
            HST.DBID = BI.DBID AND
            HST.SQL_ID = '&&sql_id' AND
            NOT EXISTS 
            ( SELECT 
                1 
              FROM 
                BASIS_INFO BI,
                V$SQLSTATS SS
              WHERE 
                SS.SQL_ID = '&&sql_id' 
            )
        )
      )
      WHERE
        PIECE <= 50
    )
    WHERE
      SQL_TEXT IS NOT NULL
  )
),
START_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    DECODE(ROWNUM, 
      1, 1, 
      NUM_BLANKS + 2, LENGTH + 1, 
      INSTR(STL.SQL_TEXT, ' ', 1, ROWNUM - 1) + 1) POS
  FROM
    BASIS_INFO BI,
    SQL_TEXT STL,
    ( SELECT 1 FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 
      ( SELECT NUM_BLANKS + 2 FROM SQL_TEXT)
    )
  WHERE
    BI.COMPLEX_SQL_TEXT = 'X'
  UNION
  ( SELECT /*+ MATERIALIZE */
      DECODE(ROWNUM, 
        1, 1, 
        NUM_COMMA + 2, LENGTH + 1, 
        INSTR(STL.SQL_TEXT, ',', 1, ROWNUM - 1) + 1) POS
    FROM
      BASIS_INFO BI,
      SQL_TEXT STL,
      ( SELECT 1 FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 
        ( SELECT NUM_COMMA + 2 FROM SQL_TEXT)
      )
    WHERE
      BI.COMPLEX_SQL_TEXT = 'X' 
  )
),
START_END_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    POS1,
    NVL(POS2, POS_OVERFLOW) POS2
  FROM
  ( SELECT
      SP1.POS POS1,
      MAX(SP2.POS) POS2,
      MIN(SP3.POS) POS_OVERFLOW
    FROM
      START_POSITIONS SP1,
      START_POSITIONS SP2,
      START_POSITIONS SP3
    WHERE
      SP2.POS (+) BETWEEN SP1.POS + 1 AND SP1.POS + 80 AND
      SP3.POS > SP1.POS
    GROUP BY
      SP1.POS
  )
),
START_END_LINE_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    POS1,
    POS2
  FROM
    START_END_POSITIONS
  START WITH
    POS1 = 1
  CONNECT BY PRIOR 
    POS2 = POS1
  UNION ALL
  ( SELECT
      (R.ROWNUMBER - 1) * 80 + 1 POS1,
      R.ROWNUMBER * 80 + 1 POS2
    FROM
      BASIS_INFO BI,
      SQL_TEXT STL,
      ( SELECT ROWNUM ROWNUMBER FROM V$SESSTAT WHERE ROWNUM <= 1000 ) R
    WHERE
      BI.COMPLEX_SQL_TEXT = ' ' AND
      R.ROWNUMBER * 80 <= LENGTH(STL.SQL_TEXT) + 80
  )
),
ASH_DISTRIBUTION AS
( SELECT /*+ MATERIALIZE */
    SAMPLE_TIME,
    TO_CHAR(SAMPLE_TIME, 'YYYY-MM-DD HH24') HOUR,
    PLAN_HASH_VALUE,
    NVL(PLAN_ID, 0) PLAN_ID,
    EVENT,
    WAIT_CLASS,
    OBJECT_NAME,
    SUM(BLOCKS_ACCESSED) BLOCKS_ACCESSED,
    SQL_OPNAME,
    MODULE,
    MOD_ACTION,
    USER_NAME,
    ACTIVITY,
    TOP_LEVEL_SQL_ID,
    MAX(PGA_MB) MAX_PGA_MB,
    MAX(TEMP_MB) MAX_TEMP_MB,
    COUNT(*) OCCURRENCES
  FROM
  ( SELECT DISTINCT
      DECODE(ASH.SQL_OPCODE, 
        3, ASH.SQL_PLAN_HASH_VALUE, 
        6, ASH.SQL_PLAN_HASH_VALUE, 
        7, ASH.SQL_PLAN_HASH_VALUE, 0) PLAN_HASH_VALUE,
      ASH.SQL_PLAN_LINE_ID PLAN_ID,
      ASH.SESSION_ID SID,
      ASH.SAMPLE_TIME SAMPLE_TIME,
      DECODE(SESSION_STATE,
        'WAITING', EVENT || DECODE(SUBSTR(EVENT, 1, 5),
        'enq: ', ' (' || TO_CHAR(BITAND(P1, 65535)) || ' / ' ||
        TO_CHAR(DECODE(BITAND(P1, 65535),
          1, 'Null',
          2, 'Sub-Share',
          3, 'Sub-Exclusive',
          4, 'Share',
          5, 'Share/Sub-Exclusive',
          6, 'Exclusive', 'Other')) || ')' ), 'CPU') EVENT,
      ASH.WAIT_CLASS,
      NVL(DECODE(ASH.WAIT_CLASS,
        'Application', NVL(O.OBJECT_NAME, DECODE(ASH.CURRENT_OBJ#, -1, 
        'Header / Rollback / ANALYZE', 0, 'Undo Data', 'not available')),
        'Cluster', NVL(O.OBJECT_NAME, DECODE(ASH.CURRENT_OBJ#, -1, 
        'Header / Rollback / ANALYZE', 0, 'Undo Data', 'not available')),
        'User I/O', DECODE(EVENT, 'direct path read temp', 'not available',
        'direct path write temp', 'not available', 
        'Data file init write', 'not available',
        NVL(O.OBJECT_NAME, DECODE(ASH.CURRENT_OBJ#, -1, 
        'Header / Rollback / ANALYZE', 0, 'Undo Data', NULL))),
        'not available'), 
        DECODE(SSO.OBJECT_NAME, NULL, 'not available',
          SSO.OBJECT_NAME || ' (previous)')) OBJECT_NAME,
      DECODE(ASH.WAIT_CLASS, 'User I/O', P3, 0) BLOCKS_ACCESSED,
      SQL_OPNAME,
      MODULE,
      ACTION MOD_ACTION,
      NVL(DU.USERNAME, 'not available') USER_NAME,
      DECODE(ASH.IN_CONNECTION_MGMT,     'Y', 'CONN_MGMT ') ||
        DECODE(ASH.IN_PARSE,             'Y', 'SOFT_PARSE ') ||
        DECODE(ASH.IN_HARD_PARSE,        'Y', 'HARD_PARSE ') ||
        DECODE(ASH.IN_SQL_EXECUTION,     'Y', 'SQL_EXEC ') ||
        DECODE(ASH.IN_PLSQL_EXECUTION,   'Y', 'PLSQL_EXEC ') ||
        DECODE(ASH.IN_PLSQL_RPC,         'Y', 'PLSQL_RPC ') ||
        DECODE(ASH.IN_PLSQL_COMPILATION, 'Y', 'PLSQL_COMP ') ||
        DECODE(ASH.IN_JAVA_EXECUTION,    'Y', 'JAVA_EXEC ') ||
        DECODE(ASH.IN_BIND,              'Y', 'BIND ') ||
        DECODE(ASH.IN_CURSOR_CLOSE,      'Y', 'CUR_CLOSE ') ||
        DECODE(ASH.IN_SEQUENCE_LOAD,     'Y', 'SEQ_LOAD ') ACTIVITY,
      ASH.TOP_LEVEL_SQL_ID,
      ASH.PGA_ALLOCATED / 1024 / 1024 PGA_MB,
      ASH.TEMP_SPACE_ALLOCATED / 1024 / 1024 TEMP_MB
    FROM
      DBA_HIST_ACTIVE_SESS_HISTORY ASH,
      OBJECTS O,
      DBA_HIST_SEG_STAT_OBJ SSO,
      V$INSTANCE I, 
      DBA_USERS DU,
      BASIS_INFO BI,
      SNAPSHOTS SS
    WHERE
      I.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER AND
      ASH.CURRENT_OBJ# = O.OBJECT_ID (+) AND
      ASH.CURRENT_OBJ# = SSO.OBJ# (+) AND
      ASH.USER_ID = DU.USER_ID (+) AND
      ASH.SQL_ID = '&&sql_id' AND
      BI.ASH_INFO = 'X' AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID
  )
  GROUP BY
    SAMPLE_TIME,
    TO_CHAR(SAMPLE_TIME, 'YYYY-MM-DD HH24'),
    PLAN_HASH_VALUE,
    PLAN_ID,
    EVENT,
    WAIT_CLASS,
    OBJECT_NAME,
    SQL_OPNAME,
    MODULE,
    MOD_ACTION,
    USER_NAME,
    ACTIVITY,
    TOP_LEVEL_SQL_ID
),
TABLE_INFO AS
( SELECT /*+ MATERIALIZE */ DISTINCT 
    OBJECT_OWNER TABLE_OWNER, 
    OBJECT_NAME TABLE_NAME
  FROM
    BASIS_INFO BI,
    DBA_HIST_SQL_PLAN SP
  WHERE
    SP.SQL_ID = '&&sql_id' AND
    ( OBJECT_TYPE LIKE '%TABLE%' OR 
      OPERATION = 'DELETE' )
  UNION
  ( SELECT DISTINCT 
      OBJECT_OWNER TABLE_OWNER, 
      OBJECT_NAME TABLE_NAME
    FROM
      BASIS_INFO BI,
      V$SQL_PLAN SP
    WHERE
      SP.SQL_ID = '&&sql_id' AND
      ( OBJECT_TYPE LIKE '%TABLE%' OR 
        OPERATION = 'DELETE' )
  )
  UNION
  ( SELECT DISTINCT 
      I.TABLE_OWNER TABLE_OWNER, 
      I.TABLE_NAME TABLE_NAME
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SQL_PLAN HSP, 
      DBA_INDEXES I
    WHERE
      HSP.OBJECT_OWNER = I.OWNER AND 
      HSP.OBJECT_NAME = I.INDEX_NAME AND
      HSP.SQL_ID = '&&sql_id' AND 
      HSP.OBJECT_TYPE LIKE '%INDEX%'
  )
  UNION
  ( SELECT DISTINCT 
      I.TABLE_OWNER TABLE_OWNER, 
      I.TABLE_NAME TABLE_NAME
    FROM 
      BASIS_INFO BI,
      V$SQL_PLAN HSP, 
      DBA_INDEXES I
    WHERE
      HSP.OBJECT_OWNER = I.OWNER AND 
      HSP.OBJECT_NAME = I.INDEX_NAME AND
      HSP.SQL_ID = '&&sql_id' AND 
      HSP.OBJECT_TYPE LIKE '%INDEX%'
  )
  UNION
  ( SELECT DISTINCT 
      OD.TO_OWNER TABLE_OWNER, 
      OD.TO_NAME TABLE_NAME
    FROM 
      BASIS_INFO BI,
      V$SQL S, 
      V$OBJECT_DEPENDENCY OD
    WHERE
      S.ADDRESS = OD.FROM_ADDRESS AND 
      S.HASH_VALUE = OD.FROM_HASH AND
      S.SQL_ID = '&&sql_id' AND 
      OD.TO_TYPE = 2
  )
  UNION
  ( SELECT 
      HSS.PARSING_SCHEMA_NAME TABLE_OWNER,
      REGEXP_REPLACE(TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 200)),
        'INSERT INTO[ "]+([^ "]+)[ "]+.*', '\1', 1, 1, 'i')
        TABLE_NAME
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SQLTEXT HST, 
      DBA_HIST_SQLSTAT HSS, 
      V$INSTANCE I
    WHERE 
      I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSS.SQL_ID = HST.SQL_ID AND 
      HST.SQL_ID = '&&sql_id'
  )
  UNION
  ( SELECT 
      REGEXP_REPLACE(TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 200)),
        'BEGIN DBMS_STATS.*OWNNAME => [''"]+([^''"]+)[''"]+.*', '\1', 1, 1, 'i') TABLE_OWNER,
      REGEXP_REPLACE(TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 200)),
        'BEGIN DBMS_STATS.*TABNAME => [''"]+([^''"]+)[''"]+.*', '\1', 1, 1, 'i') TABLE_NAME
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLTEXT HST,
      DBA_HIST_SQLSTAT HSS,
      V$INSTANCE I
    WHERE 
      I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSS.SQL_ID = HST.SQL_ID AND 
      HST.SQL_ID = '&&sql_id'
  )
  UNION
  ( SELECT 
      REGEXP_REPLACE(TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 200)),
        'BEGIN DBMS_REDEFINITION.*UNAME => [''"]+([^''"]+)[''"]+.*', '\1', 1, 1, 'i') TABLE_OWNER,
      REGEXP_REPLACE(TO_CHAR(SUBSTR(HST.SQL_TEXT, 1, 200)),
        'BEGIN DBMS_REDEFINITION.*ORIG_TABLE => [''"]+([^''"]+)[''"]+.*', '\1', 1, 1, 'i') TABLE_NAME
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLTEXT HST,
      DBA_HIST_SQLSTAT HSS,
      V$INSTANCE I
    WHERE 
      I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSS.SQL_ID = HST.SQL_ID AND 
      HST.SQL_ID = '&&sql_id'
  )
),
TABLE_STORAGE AS
( SELECT /*+ MATERIALIZE */
    TI.TABLE_OWNER, 
    TI.TABLE_NAME, 
    NULL PARTITION_NAME, 
    DT.IOT_TYPE,
    NVL(DT.PCT_FREE, 10) PCT_FREE, 
    NVL(DT.INI_TRANS, 1) INI_TRANS,
    DECODE(DT.CLUSTER_NAME, NULL, 'NO', 'YES') CLUSTER_TABLE,
    0 PARTITION_POSITION,
    NVL(DT.COMPRESS_FOR, 'NO') COMPRESSION,
    LTRIM(DT.DEGREE) DEGREE
  FROM 
    DBA_TABLES DT, 
    TABLE_INFO TI
  WHERE 
    TI.TABLE_OWNER = DT.OWNER AND 
   TI.TABLE_NAME = DT.TABLE_NAME
  UNION ALL
  ( SELECT 
      TI.TABLE_OWNER, 
      TI.TABLE_NAME, 
      DTP.PARTITION_NAME, 
      NULL,
      DTP.PCT_FREE, 
      DTP.INI_TRANS,
      DECODE(DT.CLUSTER_NAME, NULL, 'NO', 'YES') CLUSTER_TABLE,
      DTP.PARTITION_POSITION,
      NVL(DT.COMPRESS_FOR, 'NO') COMPRESSION,
      LTRIM(DT.DEGREE) DEGREE
    FROM 
      DBA_TABLES DT,
      DBA_TAB_PARTITIONS DTP, 
      TABLE_INFO TI
    WHERE 
      DT.OWNER = TI.TABLE_OWNER AND  
      DT.TABLE_NAME = TI.TABLE_NAME AND
      TI.TABLE_OWNER = DTP.TABLE_OWNER AND 
      TI.TABLE_NAME = DTP.TABLE_NAME
  )
),
TABLE_MODIFICATIONS AS
( SELECT /*+ MATERIALIZE */
    TI.TABLE_OWNER,
    TI.TABLE_NAME,
    TI.PARTITION_NAME,
    NVL(TM.INSERTS, 0) INSERTS,
    NVL(TM.UPDATES, 0) UPDATES,
    NVL(TM.DELETES, 0) DELETES
  FROM
    TABLE_STORAGE TI,
    ALL_TAB_MODIFICATIONS TM
  WHERE
    TI.TABLE_OWNER = TM.TABLE_OWNER (+) AND
    TI.TABLE_NAME = TM.TABLE_NAME (+) AND
    NVL(TI.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME (+), ' ')
),
TABLE_COLUMNS AS
( SELECT /*+ MATERIALIZE */
    TI.TABLE_OWNER,
    TI.TABLE_NAME,
    NVL(DTC.LONG_RAW, 'NO') LONG_RAW,
    NVL(DTC.LOB, 'NO') LOB
  FROM
  ( SELECT
      OWNER, 
      TABLE_NAME, 
      DECODE(SUM(DECODE(DATA_TYPE, 'LONG RAW', 1, 0)), 0, 'NO', 'YES') LONG_RAW,
      DECODE(SUM(DECODE(DATA_TYPE, 'LONG RAW', 0, 1)), 0, 'NO', 'YES') LOB
    FROM
      DBA_TAB_COLS
    WHERE
      DATA_TYPE IN ( 'LONG RAW', 'CLOB', 'BLOB', 'NCLOB' )
    GROUP BY
      OWNER,
      TABLE_NAME
  ) DTC,
    TABLE_INFO TI
  WHERE
    TI.TABLE_OWNER = DTC.OWNER (+) AND
    TI.TABLE_NAME = DTC.TABLE_NAME (+)    
),
INDEX_INFO AS
( SELECT /*+ MATERIALIZE */ DISTINCT 
    T.TABLE_OWNER TABLE_OWNER,
    T.TABLE_NAME TABLE_NAME,
    I.OWNER INDEX_OWNER, 
    I.INDEX_NAME, 
    I.INDEX_TYPE,
    I.UNIQUENESS,
    DECODE(I.COMPRESSION, 'ENABLED', 'YES', 'NO') COMPRESSION,
    NVL(I.PREFIX_LENGTH, 0) PREFIX_LENGTH
  FROM
    DBA_INDEXES I, 
    TABLE_INFO T
  WHERE 
    T.TABLE_OWNER = I.TABLE_OWNER AND
    T.TABLE_NAME = I.TABLE_NAME AND 
    I.INDEX_TYPE != 'LOB'
),
INDEX_STORAGE AS
( SELECT /*+ MATERIALIZE */
    TI.INDEX_OWNER, 
    TI.INDEX_NAME, 
    NULL PARTITION_NAME,
    DT.INDEX_TYPE, 
    NVL(DT.PCT_FREE, 10) PCT_FREE,
    NVL(DT.INI_TRANS, 2) INI_TRANS,
    0 PARTITION_POSITION,
    TI.COMPRESSION,
    TI.PREFIX_LENGTH
  FROM 
    DBA_INDEXES DT, 
    INDEX_INFO TI
  WHERE 
    TI.INDEX_OWNER = DT.OWNER AND 
    TI.INDEX_NAME = DT.INDEX_NAME 
  UNION ALL
  ( SELECT 
      TI.INDEX_OWNER, 
      TI.INDEX_NAME, 
      DTP.PARTITION_NAME,
      TI.INDEX_TYPE, 
      DTP.PCT_FREE, 
      DTP.INI_TRANS,
      DTP.PARTITION_POSITION,
      TI.COMPRESSION,
      TI.PREFIX_LENGTH
    FROM 
      DBA_IND_PARTITIONS DTP, 
      INDEX_INFO TI
    WHERE 
      TI.INDEX_OWNER = DTP.INDEX_OWNER AND 
      TI.INDEX_NAME = DTP.INDEX_NAME
  )
),
INDEX_ROWS_HELPER AS
( SELECT /*+ MATERIALIZE */
    IC.TABLE_NAME TABLE_NAME,
    IC.INDEX_NAME INDEX_NAME,
    IC.INDEX_OWNER INDEX_OWNER,
    IC.COLUMN_NAME COLUMN_NAME,
    II.UNIQUENESS,
    II.COMPRESSION,
    II.PREFIX_LENGTH,
    IC.COLUMN_POSITION
  FROM
    INDEX_INFO II,
    DBA_IND_COLUMNS IC,
    BASIS_INFO BI
  WHERE
    BI.SEGMENT_INFO = 'X' AND
    II.INDEX_OWNER = IC.INDEX_OWNER AND
    II.INDEX_NAME = IC.INDEX_NAME
),
INDEX_ROWS AS
( SELECT /*+ MATERIALIZE */
    IR.INDEX_NAME INDEX_NAME,
    IR.INDEX_OWNER INDEX_OWNER,
    SUM(NVL(TC.AVG_COL_LEN, 0) +               /* Length of all indexed columns */
      DECODE(TC.GLOBAL_STATS, 'YES', 0, 1)) +  /* Additional length byte in case of ANALYZE */
      6 +                                      /* ROWID bytes */
      DECODE(IR.UNIQUENESS, 'UNIQUE', 0, 1) +  /* Additional ROWID length byte for NONUNIQUE indexes */
      1 +                                      /* Lock byte */
      1 +                                      /* Flag byte */
      2                                        /* Row directory entry */
      IND_ROW_LEN,
    SUM(DECODE(SIGN(IR.COLUMN_POSITION - IR.PREFIX_LENGTH), 1, 0, 
      NVL(TC.AVG_COL_LEN, 0) + DECODE(TC.GLOBAL_STATS, 'YES', 0, 1))) COMP_ROW_LEN,
    SUM(DECODE(TC.AVG_COL_LEN, NULL, 1, 0)) COL_LEN_NULL,
    SUM(DECODE(IR.COLUMN_POSITION, 1, NVL(TC.NUM_DISTINCT, 0))) FIRST_NUM_DIST
  FROM
    INDEX_ROWS_HELPER IR,
    DBA_TAB_COLS TC
  WHERE
    TC.TABLE_NAME = IR.TABLE_NAME AND
    TC.OWNER = IR.INDEX_OWNER AND
    TC.COLUMN_NAME = IR.COLUMN_NAME 
  GROUP BY
    IR.INDEX_OWNER,
    IR.INDEX_NAME,
    IR.UNIQUENESS
),
INDEX_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    /* Simple index statistics without partition, STATTYPE_LOCKED, STALE_STATS */
    DIS.OWNER,
    DIS.INDEX_NAME,
    NULL PARTITION_NAME,
    DIS.TABLE_OWNER,
    DIS.TABLE_NAME,
    DIS.LEAF_BLOCKS,
    DIS.NUM_ROWS,
    DIS.DISTINCT_KEYS,
    DIS.USER_STATS,
    NULL STATTYPE_LOCKED,
    NULL STALE_STATS,
    DIS.LAST_ANALYZED,
    DIS.AVG_LEAF_BLOCKS_PER_KEY
  FROM
    INDEX_INFO II,
    DBA_INDEXES DIS,
    BASIS_INFO BI
  WHERE
    BI.COMPLEX_INDEX_STATS != 'X' AND
    DIS.OWNER = II.INDEX_OWNER AND
    DIS.INDEX_NAME = II.INDEX_NAME 
  UNION ALL
  ( SELECT /*+ MATERIALIZE */
      DIS.OWNER,
      DIS.INDEX_NAME,
      DIS.PARTITION_NAME,
      DIS.TABLE_OWNER,
      DIS.TABLE_NAME,
      DIS.LEAF_BLOCKS,
      DIS.NUM_ROWS,
      DIS.DISTINCT_KEYS,
      DIS.USER_STATS,
      DIS.STATTYPE_LOCKED,
      NULL STALE_STATS,
      DIS.LAST_ANALYZED,
      DIS.AVG_LEAF_BLOCKS_PER_KEY
    FROM
      INDEX_INFO II,
      DBA_IND_STATISTICS DIS,
      BASIS_INFO BI
    WHERE
      BI.COMPLEX_INDEX_STATS = 'X' AND
      DIS.OWNER = II.INDEX_OWNER AND
      DIS.INDEX_NAME = II.INDEX_NAME 
  )
),
SEGMENT_INFO AS
( SELECT /*+ MATERIALIZE */
    TABLE_OWNER OWNER,
    TABLE_NAME SEGMENT_NAME,
    'TABLE' SEGMENT_TYPE,
    NULL LOB_TABLE_NAME,
    NULL LOB_COLUMN_NAME
  FROM
    TABLE_INFO
  UNION ALL
  ( SELECT
      INDEX_OWNER OWNER,
      INDEX_NAME SEGMENT_NAME,
      'INDEX' SEGMENT_TYPE,
      NULL LOB_TABLE_NAME,
      NULL LOB_COLUMN_NAME
    FROM
      INDEX_INFO
  )
  UNION ALL
  ( SELECT
      DL.OWNER OWNER,
      DL.SEGMENT_NAME SEGMENT_NAME,
      'LOBSEGMENT' SEGMENT_TYPE,
      DL.TABLE_NAME LOB_TABLE_NAME,
      DL.COLUMN_NAME LOB_COLUMN_NAME
    FROM
      TABLE_INFO TI,
      DBA_LOBS DL
    WHERE
      TI.TABLE_OWNER = DL.OWNER AND
      TI.TABLE_NAME = DL.TABLE_NAME 
  )
  UNION ALL
  ( SELECT
      DL.OWNER OWNER,
      DL.INDEX_NAME SEGMENT_NAME,
      'LOBINDEX' SEGMENT_TYPE,
      DL.TABLE_NAME LOB_TABLE_NAME,
      DL.COLUMN_NAME LOB_COLUMN_NAME
    FROM
      TABLE_INFO TI,
      DBA_LOBS DL
    WHERE
      TI.TABLE_OWNER = DL.OWNER AND
      TI.TABLE_NAME = DL.TABLE_NAME 
  )
),
SEGMENTS AS
( SELECT /*+ MATERIALIZE */
    S.OWNER,
    S.SEGMENT_NAME,
    S.PARTITION_NAME,
    S.SEGMENT_TYPE,
    S.TABLESPACE_NAME,
    S.BUFFER_POOL,
    S.BYTES,
    S.EXTENTS,
    S.INITIAL_EXTENT,
    S.NEXT_EXTENT,
    S.MIN_EXTENTS,
    S.MAX_EXTENTS,
    S.FREELISTS,
    S.FREELIST_GROUPS,
    TS.BLOCK_SIZE,
    DECODE(TS.EXTENT_MANAGEMENT, 'DICTIONARY', 'DMTS', 'LMTS') || '/' ||
      SUBSTR(TS.CONTENTS, 1, 1) || 
      DECODE(TS.ALLOCATION_TYPE, 'SYSTEM', ' (SYS)', 'UNIFORM', 
      ' (UNI ' || ROUND(TS.MIN_EXTLEN / 1024 / 1024) || 'M)') ||
      DECODE(TS.SEGMENT_SPACE_MANAGEMENT, 'AUTO', ', ASSM', ', MSSM') TABLESPACE_TYPE,
    TS.EXTENT_MANAGEMENT,
    TS.ALLOCATION_TYPE,
    TS.SEGMENT_SPACE_MANAGEMENT,
    SI.LOB_COLUMN_NAME,
    SI.LOB_TABLE_NAME,
    O.CREATED
  FROM
    BASIS_INFO BI,
    DBA_SEGMENTS S,
    SEGMENT_INFO SI,
    DBA_TABLESPACES TS,
    OBJECTS O
  WHERE
    BI.SEGMENT_INFO = 'X' AND
    S.SEGMENT_TYPE IN 
    ( 'TABLE', 
      'TABLE PARTITION',
      'INDEX',
      'INDEX PARTITION',
      'LOBSEGMENT',
      'LOBINDEX' 
    ) AND
    S.OWNER = SI.OWNER AND
    S.SEGMENT_NAME = SI.SEGMENT_NAME AND
    S.TABLESPACE_NAME = TS.TABLESPACE_NAME AND
    S.OWNER = O.OWNER (+) AND
    S.SEGMENT_NAME = O.OBJECT_NAME (+) AND
    NVL(S.PARTITION_NAME, ' ') = NVL(O.SUBOBJECT_NAME (+), ' ') 
),
OBJECT_INFO AS
( SELECT /*+ MATERIALIZE */ DISTINCT
    OD.TO_OWNER OWNER,
    OD.TO_NAME OBJECT_NAME
  FROM
    BASIS_INFO BI,
    V$SQL S,
    V$OBJECT_DEPENDENCY OD
  WHERE
    S.SQL_ID = '&&sql_id' AND 
    S.ADDRESS = OD.FROM_ADDRESS AND
    S.HASH_VALUE = OD.FROM_HASH 
),
VIEW_INFO AS
( SELECT /*+ MATERIALIZE */
    OI.OWNER,
    OI.OBJECT_NAME VIEW_NAME
  FROM 
    BASIS_INFO BI,
    OBJECT_INFO OI,
    OBJECTS O
  WHERE
    BI.VIEW_INFO = 'X' AND
    OI.OWNER = O.OWNER AND 
    OI.OBJECT_NAME = O.OBJECT_NAME AND 
    O.OBJECT_TYPE = 'VIEW' AND
    OI.OWNER NOT LIKE 'SYS%'   
),
CACHES AS
( SELECT /*+ MATERIALIZE */
    SDC.COMPONENT CACHE_NAME,
    SDC.CURRENT_SIZE / 1024 / 1024 POOL_SIZE_MB,
    DECODE(SDC.COMPONENT, 
      'KEEP buffer cache', 'KEEP',
      'RECYCLE buffer cache', 'RECYCLE',
      'DEFAULT') BUFFER_POOL,
    DECODE(SDC.COMPONENT,
      'DEFAULT 2K buffer cache', 2048,
      'DEFAULT 4K buffer cache', 4096,
      'DEFAULT 8K buffer cache', 8192,
      'DEFAULT 16K buffer cache', 16384,
      'DEFAULT 32K buffer cache', 32768,
      B.VALUE) BLOCK_SIZE
  FROM
    V$SGA_DYNAMIC_COMPONENTS SDC,
    V$PARAMETER B
  WHERE
    SDC.COMPONENT IN
    ( 'DEFAULT buffer cache',
      'KEEP buffer cache',
      'RECYCLE buffer cache',
      'DEFAULT 2K buffer cache',
      'DEFAULT 4K buffer cache',
      'DEFAULT 8K buffer cache',
      'DEFAULT 16K buffer cache',
      'DEFAULT 32K buffer cache'
    ) AND
    B.NAME = 'db_block_size' 
),
BIND_CONTENTS AS
( SELECT /*+ MATERIALIZE */
    CAPTURE_TIME,
    POSITION,
    NAME,
    VALUE_STRING
  FROM
  ( SELECT
      MIN(SNAP_ID) OVER (PARTITION BY LAST_CAPTURED) MIN_SNAP_ID,
      SNAP_ID,
      LAST_CAPTURED CAPTURE_TIME, 
      POSITION, 
      NAME, 
      VALUE_STRING
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SQLBIND HSB,
      SNAPSHOTS SS
    WHERE  
      HSB.SQL_ID = '&&sql_id' AND 
      HSB.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      LAST_CAPTURED IS NOT NULL
  )
  WHERE
    SNAP_ID = MIN_SNAP_ID
),
DISTINCT_LITERALS AS
( SELECT /*+ MATERIALIZE */
    POSITION, 
    NAME, 
    MIN(VALUE_STRING) EXAMPLE_VALUE,
    COUNT(DISTINCT(VALUE_STRING)) NUM_DISTINCT
  FROM 
    BIND_CONTENTS
  GROUP BY POSITION, NAME
),
SQL_PLANS AS
( SELECT /*+ MATERIALIZE */
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    SQL_ID,
    DEPTH,
    OPTIMIZER,
    OPERATION || DECODE(OPTIONS, NULL, NULL, ' ' || OPTIONS || 
      DECODE(OBJECT_NAME, NULL, NULL, ' (' || OBJECT_NAME || ')')) ACTION_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', 
      DECODE(SOURCE, 'HISTORY', 
        DECODE(SEARCH_COLUMNS, NULL, NULL, 0, NULL, 'Search columns: ' || SEARCH_COLUMNS), 
        NULL),
      DECODE(SEARCH_COLUMNS, NULL, NULL, 0, NULL, 'Search columns: ' || SEARCH_COLUMNS)) SEARCH_COLUMNS_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', DECODE(ACCESS_PREDICATES, NULL, NULL, 
      SUBSTR(ACCESS_PREDICATES, 1, 3000)), NULL) ACCESS_PREDICATE_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', DECODE(FILTER_PREDICATES, NULL, NULL, 
      SUBSTR(FILTER_PREDICATES, 1, 3000)), NULL) FILTER_PREDICATE_INFO,
    DECODE(MEMORY_USED, NULL, NULL, 'PGA space: ' || ROUND(MEMORY_USED / 1024) || ' KB' || 
      DECODE(TEMP_SPACE, NULL, NULL, ', Temp space: ' || ROUND(TEMP_SPACE / 1024) || ' KB')) SPACE_INFO,
    DECODE(PARTITION_START, NULL, NULL, 'Partitions: ' || PARTITION_START || ' - ' || PARTITION_STOP ||
      ', Partition ID: ' || PARTITION_ID) PARTITION_INFO,
    DECODE(PX_DEGREE, NULL, NULL, 1, NULL, 'PX degree: ' || PX_DEGREE) PX_INFO,
    DECODE(COST, NULL, NULL, 'Total costs: ' || TO_CHAR(COST) ) || 
      DECODE(IO_COST, NULL, NULL, ', I/O costs: ' || TO_CHAR(IO_COST) ) || 
      DECODE(COST, NULL, NULL, DECODE(IO_COST, NULL, NULL, ', CPU costs: ' || TO_CHAR(COST - IO_COST) )) || 
      DECODE(CARDINALITY, NULL, NULL, DECODE(IO_COST || COST, NULL, NULL, ', ') || 
      'E-Rows: ' || TO_CHAR(CARDINALITY) ) COST_INFO,
    DECODE(LAST_STARTS, NULL , NULL, 'Starts: ' || LAST_STARTS || ', A-Rows: ' || LAST_OUTPUT_ROWS || ', Gets: ' || LAST_BUFFER_GETS ||
      ', Reads: ' || LAST_DISK_READS || ', Time: ' || LAST_ELAPSED_TIME || ' us') PLAN_STATISTICS_INFO
  FROM 
  ( ( SELECT
        SP.PLAN_HASH_VALUE,
        TO_CHAR(SP.CHILD_NUMBER) CHILD_NUMBER,
        SP.ID,
        SP.SEARCH_COLUMNS,
        SP."DEPTH",
        SP.OPERATION,
        SP.OPTIONS,
        SP.OBJECT_NAME,
        SP.ACCESS_PREDICATES,
        SP.FILTER_PREDICATES,
        SP.TEMP_SPACE,
        SPA.LAST_MEMORY_USED MEMORY_USED,
        SPA.LAST_DEGREE PX_DEGREE,
        SP.PARTITION_START,
        SP.PARTITION_STOP,
        SP.PARTITION_ID,
        SP.COST,
        SP.IO_COST,
        SP.CARDINALITY,
        SPA.LAST_STARTS,
        SPA.LAST_OUTPUT_ROWS,
        SPA.LAST_CR_BUFFER_GETS + SPA.LAST_CU_BUFFER_GETS LAST_BUFFER_GETS,
        SPA.LAST_DISK_READS,
        SPA.LAST_ELAPSED_TIME,
        SP.OPTIMIZER,
        SP.SQL_ID,
        BI.INCLUDE_PREDICATES,
        'CURRENT' SOURCE
      FROM
        V$SQL_PLAN SP, 
        V$SQL_PLAN_STATISTICS_ALL SPA,
        BASIS_INFO BI
      WHERE
        SP.SQL_ID = SPA.SQL_ID (+) AND
        SP.CHILD_NUMBER = SPA.CHILD_NUMBER (+) AND
        SP.ID = SPA.ID (+) AND
        SP.SQL_ID = '&&sql_id'
    ) 
    UNION 
    ( SELECT
        PLAN_HASH_VALUE,
        'n/a' CHILD_NUMBER,
        ID,
        SEARCH_COLUMNS,
        DEPTH,
        OPERATION,
        OPTIONS,
        OBJECT_NAME,
        ACCESS_PREDICATES,
        FILTER_PREDICATES,
        TEMP_SPACE,
        NULL MEMORY_USED,
        NULL PX_DEGREE,
        PARTITION_START,
        PARTITION_STOP,
        PARTITION_ID,
        COST,
        IO_COST,
        CARDINALITY,
        NULL LAST_STARTS,
        NULL LAST_OUTPUT_ROWS,
        NULL LAST_BUFFER_GETS,
        NULL LAST_DISK_READS,
        NULL LAST_ELAPSED_TIME,
        OPTIMIZER,
        HSP.SQL_ID,
        BI.INCLUDE_PREDICATES,
        'HISTORY' SOURCE
      FROM
        DBA_HIST_SQL_PLAN HSP,
        BASIS_INFO BI
      WHERE
        HSP.DBID = BI.DBID AND
        HSP.SQL_ID = '&&sql_id' AND
        NOT EXISTS 
        ( SELECT 
            1 
          FROM 
            V$SQL_PLAN SP
          WHERE 
            SP.SQL_ID = HSP.SQL_ID AND 
            SP.PLAN_HASH_VALUE = HSP.PLAN_HASH_VALUE
        )
    )
  )
),
PREDICATE_INFOS AS
( SELECT /*+ MATERIALIZE */
    'ACCESS' PREDICATE_TYPE,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    DEPTH, 
    ' Access predicates: ' || ACCESS_PREDICATE_INFO || ' ' PREDICATE_INFO
  FROM
    SQL_PLANS
  WHERE
    ACCESS_PREDICATE_INFO IS NOT NULL
  UNION ALL
  ( SELECT
      'FILTER' PREDICATE_TYPE,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID,
      DEPTH,
      ' Filter predicates: ' || FILTER_PREDICATE_INFO || ' ' PREDICATE_INFO
    FROM
      SQL_PLANS
    WHERE
      FILTER_PREDICATE_INFO IS NOT NULL
  )
  UNION ALL
  ( SELECT
      'DUMMY' PREDICATE_TYPE,
      123 PLAN_HASH_VALUE,
      '345' CHILD_NUMBER,
      567 ID,
      789 DEPTH,
      ' XXX ' PREDICATE_INFO
    FROM
      DUAL
  )
),
PRED_START_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    *
  FROM
  ( SELECT 
      PREDICATE_TYPE,
      PREDICATE_INFO,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID, 
      INSTR(PREDICATE_INFO, ' ', 1, ROWN) POS
    FROM
      PREDICATE_INFOS PI,
      ( SELECT ROWNUM ROWN FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 1000 ) RN
  )
  WHERE
    POS != 0
),
PRED_START_END_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    PREDICATE_TYPE,
    PREDICATE_INFO,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    POS1,
    PREDICATE_TYPE || PLAN_HASH_VALUE || CHILD_NUMBER || ID || POS1 CONN_ID1,
    POS2,
    PREDICATE_TYPE || PLAN_HASH_VALUE || CHILD_NUMBER || ID || POS2 CONN_ID2
  FROM
  ( SELECT
      PREDICATE_TYPE,
      PREDICATE_INFO,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID,
      POS1,
      NVL(POS2, POS_OVERFLOW) POS2
    FROM
    ( SELECT
        SP1.PREDICATE_TYPE,
        SP1.PREDICATE_INFO,
        SP1.PLAN_HASH_VALUE,
        SP1.CHILD_NUMBER,
        SP1.ID,
        SP1.POS POS1,
        MAX(SP2.POS) POS2,
        MIN(SP3.POS) POS_OVERFLOW
      FROM
        BASIS_INFO BI,
        PRED_START_POSITIONS SP1,
        PRED_START_POSITIONS SP2,
        PRED_START_POSITIONS SP3
      WHERE
        SP2.PREDICATE_TYPE (+) = SP1.PREDICATE_TYPE AND
        SP2.PLAN_HASH_VALUE (+) = SP1.PLAN_HASH_VALUE AND
        SP2.CHILD_NUMBER (+) = SP1.CHILD_NUMBER AND
        SP2.ID (+) = SP1.ID AND
        SP2.POS (+) BETWEEN SP1.POS + 1 AND SP1.POS + 80 AND
        SP3.PREDICATE_TYPE = SP1.PREDICATE_TYPE AND
        SP3.PLAN_HASH_VALUE = SP1.PLAN_HASH_VALUE AND
        SP3.CHILD_NUMBER = SP1.CHILD_NUMBER AND
        SP3.ID = SP1.ID AND
        SP3.POS > SP1.POS
      GROUP BY
        SP1.PREDICATE_TYPE,
        SP1.PREDICATE_INFO,
        SP1.PLAN_HASH_VALUE,
        SP1.CHILD_NUMBER,
        SP1.ID,
        SP1.POS
    )
  )  
),
PRED_START_END_LINE_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    PREDICATE_TYPE,
    PREDICATE_INFO,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    POS1,
    POS2,
    ROW_NUMBER () OVER (ORDER BY POS1) LINE
  FROM
    PRED_START_END_POSITIONS
  START WITH
    POS1 = 1
  CONNECT BY PRIOR 
    CONN_ID2 = CONN_ID1
),
LINES AS
( SELECT 1 NUM, 'ACTION' CONTENT FROM DUAL
  UNION ALL
  SELECT 2 NUM, 'COST' CONTENT FROM DUAL 
  UNION ALL
  SELECT 3 NUM, 'SEARCH COLUMNS' CONTENT FROM DUAL
  UNION ALL
  SELECT 4 NUM, 'ACCESS PREDICATE' CONTENT FROM DUAL
  UNION ALL
  SELECT 5 NUM, 'FILTER PREDICATE' CONTENT FROM DUAL
  UNION ALL
  SELECT 6 NUM, 'SPACE' CONTENT FROM DUAL
  UNION ALL
  SELECT 7 NUM, 'PARTITION' CONTENT FROM DUAL
  UNION ALL
  SELECT 8 NUM, 'PX' CONTENT FROM DUAL
  UNION ALL
  SELECT 9 NUM, 'PLAN STATISTICS' CONTENT FROM DUAL
  UNION ALL
  SELECT 10 NUM, 'EMPTY' CONTENT FROM DUAL
),
SEGMENT_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    S.INSTANCE_NUMBER,
    DECODE(NVL(O.OWNER, SSO.OWNER), 
      '** UNAVAILABLE **', NVL(O2.OWNER, S.OBJ# || '/' || S.DATAOBJ#),
      NVL(O.OWNER, NVL(SSO.OWNER, S.OBJ# || '/' || S.DATAOBJ#))) OWNER,
    DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
      '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
      NVL(O.OBJECT_NAME, NVL(SSO.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#))) SEGMENT_NAME,
    MIN(NVL(O.OBJECT_TYPE, SSO.OBJECT_TYPE)) SEG_TYPE,
    SUM(S.LOGICAL_READS_DELTA) LOGICAL_READS,
    SUM(S.PHYSICAL_READS_DELTA) PHYSICAL_READS,
    SUM(S.DB_BLOCK_CHANGES_DELTA) DB_BLOCK_CHANGES,
    SUM(S.PHYSICAL_WRITES_DELTA) PHYSICAL_WRITES,
    SUM(S.PHYSICAL_READS_DIRECT_DELTA) PHYSICAL_READS_DIRECT,
    SUM(S.PHYSICAL_WRITES_DIRECT_DELTA) PHYSICAL_WRITES_DIRECT,
    SUM(S.BUFFER_BUSY_WAITS_DELTA) BUFFER_BUSY_WAITS,
    SUM(S.ITL_WAITS_DELTA) ITL_WAITS,
    SUM(S.ROW_LOCK_WAITS_DELTA) ROW_LOCK_WAITS,
    SUM(S.TABLE_SCANS_DELTA) SEGMENT_SCANS,
    SUM(S.SPACE_USED_DELTA) / 1024 / 1024 SPACE_USED_DELTA_MB,
    SUM(S.SPACE_ALLOCATED_DELTA) / 1024 / 1024 SPACE_ALLOC_DELTA_MB,
    SUM(S.GC_CR_BLOCKS_SERVED_DELTA) GC_CR_BLOCKS_SERVED_DELTA,
    SUM(S.GC_CU_BLOCKS_SERVED_DELTA) GC_CU_BLOCKS_SERVED_DELTA,
    SUM(S.GC_CR_BLOCKS_RECEIVED_DELTA) GC_CR_BLOCKS_RECEIVED_DELTA,
    SUM(S.GC_CU_BLOCKS_RECEIVED_DELTA) GC_CU_BLOCKS_RECEIVED_DELTA,
    SUM(S.GC_BUFFER_BUSY_DELTA) GC_BUFFER_BUSY_DELTA
  FROM
    V$INSTANCE I,
    SNAPSHOTS SS,
    DBA_HIST_SEG_STAT S,
    OBJECTS O,
    DBA_HIST_SEG_STAT_OBJ SSO,
    OBJECTS O2
  WHERE
    S.INSTANCE_NUMBER = I.INSTANCE_NUMBER AND
    S.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
    S.OBJ# = O.OBJECT_ID (+) AND
    S.DATAOBJ# = O.DATA_OBJECT_ID (+) AND
    S.OBJ# = SSO.OBJ# (+) AND
    S.DATAOBJ# = SSO.DATAOBJ# (+) AND
    S.OBJ# = O2.OBJECT_ID (+) 
  GROUP BY
    DECODE(NVL(O.OWNER, SSO.OWNER), 
      '** UNAVAILABLE **', NVL(O2.OWNER, S.OBJ# || '/' || S.DATAOBJ#),
      NVL(O.OWNER, NVL(SSO.OWNER, S.OBJ# || '/' || S.DATAOBJ#))),
    DECODE(NVL(O.OBJECT_NAME, SSO.OBJECT_NAME), 
      '** UNAVAILABLE **', NVL(O2.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#),
      NVL(O.OBJECT_NAME, NVL(SSO.OBJECT_NAME, S.OBJ# || '/' || S.DATAOBJ#))),
    S.INSTANCE_NUMBER
)
SELECT
  'DETAIL INFORMATION FOR SQL_ID: ' || SQL_ID LINE
FROM
  BASIS_INFO
UNION ALL
( SELECT
    RPAD('EVALUATION TIME:', 31) || TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') LINE
  FROM DUAL
)
UNION ALL
( SELECT
    RPAD('ANALYSIS INTERVAL:', 31) || 
      TO_CHAR(BEGIN_TIME, 'YYYY-MM-DD HH24:MI:SS') || ' - ' || 
      TO_CHAR(END_TIME, 'YYYY-MM-DD HH24:MI:SS') LINE
  FROM 
    SNAPSHOTS
)
UNION ALL
( SELECT
    RPAD(DECODE(LINE, 1, 'LAST STARTUP TIMES:', ' '), 31) ||
    TO_CHAR(STARTUP_TIME, 'YYYY-MM-DD HH24:MI:SS') LINE
  FROM
  ( SELECT
      ROW_NUMBER () OVER (ORDER BY STARTUP_TIME DESC) LINE,
      STARTUP_TIME
    FROM
     DBA_HIST_DATABASE_INSTANCE
    ORDER BY
      STARTUP_TIME DESC
  )
  WHERE
    ROWNUM <= 5
)
UNION ALL
( SELECT
    RPAD('DATABASE NAME:', 31) || NAME
  FROM
    V$DATABASE
)
UNION ALL
( SELECT
    RPAD('INSTANCE NAME:', 31) || INSTANCE_NAME
  FROM
    V$INSTANCE
)
UNION ALL
( SELECT
    RPAD('VERSION:', 31) || VERSION
  FROM
    V$INSTANCE
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'SQL STATEMENT (V$SQLSTATS, DBA_HIST_SQLTEXT, V$SQL):'
  FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LINE FROM
  ( SELECT
      SUBSTR(STL.SQL_TEXT, SEP.POS1, SEP.POS2 - SEP.POS1) LINE
    FROM
      START_END_LINE_POSITIONS SEP, 
      SQL_TEXT STL
    ORDER BY 
      SEP.POS1
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'SQL CACHE (V$SQL, V$SQLSTATS_PLAN_HASH, DBA_HIST_SQLSTAT, V$SQL_MONITOR):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('BEGIN_TIME', 19) ||
    LPAD('PLAN_HASH', 11) ||
    LPAD('EXECUTIONS', 11) ||
    LPAD('ELA_TIME_MS', 12) ||
    LPAD('ELA_TIME_MS/EXE', 16) ||
    LPAD('CPU_TIME_MS', 12) ||
    LPAD('RECORDS', 12) ||
    LPAD('REC/EXEC', 12) ||
    LPAD('DISK_READS', 11) ||
    LPAD('DISK_READS/EXE', 15) ||
    LPAD('BUFFER_GETS', 12) ||
    LPAD('BUFFER_GETS/EXE', 16) ||
    LPAD('BUFFER_GETS/REC', 16) ||
    LPAD('PARSE_MS', 12) ||
    LPAD('PARSES', 7) ||
    RPAD(' MODULE', 41) LINE
  FROM
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('V$SQL', 19) ||
    LPAD(PLAN_HASH_VALUE, 11) ||
    LPAD(EXECUTIONS, 11) ||
    LPAD(ROUND(ELAPSED_TIME / 1000), 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 999999999990.99) ||
    LPAD(ROUND(CPU_TIME / 1000), 12) ||
    LPAD(ROWS_PROCESSED, 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      99999990.99) ||
    LPAD(DISK_READS, 11) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      99999999990.99) ||
    LPAD(BUFFER_GETS, 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      999999999990.99) ||
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 999999999990.99) ||
    LPAD('not avail.', 12) ||
    LPAD(PARSE_CALLS, 7) ||
    RPAD(' ' || MODULE, 41) LINE
  FROM
    BASIS_INFO BI,
    V$SQL S
  WHERE
    S.SQL_ID = '&&sql_id'
)
UNION ALL
( SELECT
    RPAD('V$SQLSTATS', 19) ||
    LPAD(PLAN_HASH_VALUE, 11) ||
    LPAD(EXECUTIONS, 11) ||
    LPAD(ROUND(ELAPSED_TIME / 1000), 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 999999999990.99) ||
    LPAD(ROUND(CPU_TIME / 1000), 12) ||
    LPAD(ROWS_PROCESSED, 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      99999990.99) ||
    LPAD(DISK_READS, 11) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      99999999990.99) ||
    LPAD(BUFFER_GETS, 12) ||
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      999999999990.99) ||
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 999999999990.99) ||
    LPAD(ROUND(AVG_HARD_PARSE_TIME / 1000, 2), 12) ||
    LPAD(PARSE_CALLS, 7) ||
    RPAD(' not available in V$SQLSTATS', 41) LINE
  FROM
    BASIS_INFO BI,
    V$SQLSTATS_PLAN_HASH SS
  WHERE
    SS.SQL_ID = '&&sql_id'
)
UNION ALL
( SELECT
    RPAD(BEGIN_TIME, 19) || 
    LPAD(PLAN_HASH_VALUE, 11) ||
    LPAD(EXECUTIONS, 11) || 
    LPAD(ELAPSED_TIME_MS, 12) || 
    LPAD(ELAPSED_TIME_MS_PER_EXEC, 16) || 
    LPAD(CPU_TIME_MS, 12) ||
    LPAD(RECORDS, 12) ||
    LPAD(RECORDS_PER_EXEC, 12) || 
    LPAD(DISK_READS, 11) || 
    LPAD(DISK_READS_PER_EXEC, 15) ||
    LPAD(BUFFER_GETS, 12) || 
    LPAD(BUFFER_GETS_PER_EXEC, 16) || 
    LPAD(BUFFER_GETS_PER_RECORD, 16) ||
    LPAD(AVG_PARSE, 12) || 
    LPAD(PARSE_CALLS, 7) || 
    RPAD(' ' || MODULE, 41) LINE
  FROM
  ( SELECT
      'TOTAL (HISTORY)' BEGIN_TIME,
      SUM(HSQ.EXECUTIONS_DELTA) EXECUTIONS,
      SUM(HSQ.ROWS_PROCESSED_DELTA) RECORDS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ROWS_PROCESSED_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 99999990.99) RECORDS_PER_EXEC,
      SUM(HSQ.DISK_READS_DELTA) DISK_READS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.DISK_READS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 99999999990.99) DISK_READS_PER_EXEC,
      SUM(HSQ.BUFFER_GETS_DELTA) BUFFER_GETS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 999999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(SUM(HSQ.ROWS_PROCESSED_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.ROWS_PROCESSED_DELTA)), 999999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(SUM(HSQ.ELAPSED_TIME_DELTA) / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ELAPSED_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 999999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(SUM(HSQ.CPU_TIME_DELTA) / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.CPU_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,  
      HSQ.PLAN_HASH_VALUE,
      SUM(HSQ.PARSE_CALLS_DELTA) PARSE_CALLS, 
      ' ' MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ, 
      V$INSTANCE I,
      SNAPSHOTS SS
    WHERE
      HSQ.DBID = BI.DBID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND 
      I.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND 
      HSQ.SQL_ID = '&&sql_id'
    GROUP BY
      HSQ.PLAN_HASH_VALUE
    ORDER BY
      HSQ.PLAN_HASH_VALUE
  )
)
UNION ALL
( SELECT
    LPAD(BEGIN_TIME, 19) || 
    LPAD(PLAN_HASH_VALUE, 11) || 
    LPAD(EXECUTIONS, 11) || 
    LPAD(ELAPSED_TIME_MS, 12) || 
    LPAD(ELAPSED_TIME_MS_PER_EXEC, 16) ||
    LPAD(CPU_TIME_MS, 12) || 
    LPAD(RECORDS, 12) ||
    LPAD(RECORDS_PER_EXEC, 12) || 
    LPAD(DISK_READS, 11) || 
    LPAD(DISK_READS_PER_EXEC, 15) || 
    LPAD(BUFFER_GETS, 12) || 
    LPAD(BUFFER_GETS_PER_EXEC, 16) || 
    LPAD(BUFFER_GETS_PER_RECORD, 16) ||
    LPAD(AVG_PARSE, 12) ||
    LPAD(PARSE_CALLS, 7) || 
    RPAD(' ' || MODULE, 41) LINE
  FROM
  ( SELECT
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') BEGIN_TIME,
      NVL(HSQ.EXECUTIONS_DELTA, 0) EXECUTIONS,
      NVL(HSQ.ROWS_PROCESSED_DELTA, 0) RECORDS,
      TO_CHAR(DECODE(NVL(HSQ.EXECUTIONS_DELTA, 0), 0, 0, NVL(HSQ.ROWS_PROCESSED_DELTA, 0) /
        HSQ.EXECUTIONS_DELTA), 99999990.99) RECORDS_PER_EXEC,
      NVL(HSQ.DISK_READS_DELTA, 0) DISK_READS,
      TO_CHAR(DECODE(NVL(HSQ.EXECUTIONS_DELTA, 0), 0, 0, NVL(HSQ.DISK_READS_DELTA, 0) /
        HSQ.EXECUTIONS_DELTA), 99999999990.99) DISK_READS_PER_EXEC,
      NVL(HSQ.BUFFER_GETS_DELTA, 0) BUFFER_GETS,
      TO_CHAR(DECODE(NVL(HSQ.EXECUTIONS_DELTA, 0), 0, 0, NVL(HSQ.BUFFER_GETS_DELTA, 0) /
        HSQ.EXECUTIONS_DELTA), 999999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(NVL(HSQ.ROWS_PROCESSED_DELTA, 0), 0, 0, NVL(HSQ.BUFFER_GETS_DELTA, 0) /
        HSQ.ROWS_PROCESSED_DELTA), 999999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(NVL(HSQ.ELAPSED_TIME_DELTA, 0) / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(NVL(HSQ.EXECUTIONS_DELTA, 0), 0, 0, NVL(HSQ.ELAPSED_TIME_DELTA, 0) /
        HSQ.EXECUTIONS_DELTA / 1000), 999999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(NVL(HSQ.CPU_TIME_DELTA, 0) / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(NVL(HSQ.EXECUTIONS_DELTA, 0), 0, 0, NVL(HSQ.CPU_TIME_DELTA, 0) /
        HSQ.EXECUTIONS_DELTA / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,
      NVL(HSQ.PARSE_CALLS_DELTA, 0) PARSE_CALLS,
      NVL(HSQ.PLAN_HASH_VALUE, 0) PLAN_HASH_VALUE,
      HSQ.MODULE MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ,
      DBA_HIST_SNAPSHOT HSS,
      SNAPSHOTS SS,
      V$INSTANCE I
    WHERE
      HSQ.DBID = BI.DBID AND
      HSS.DBID = HSQ.DBID AND
      I.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND 
      HSQ.SNAP_ID = HSS.SNAP_ID AND
      HSQ.SQL_ID = '&&sql_id'
    ORDER BY
      HSQ.SNAP_ID DESC
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('SOURCE', 18) || 
    LPAD('PLAN_HASH', 11) || 
    LPAD('CPU_%', 6) || 
    LPAD('USER_IO_%', 10) || 
    LPAD('APPLICATION_%', 14) ||
    LPAD('CONCURRENCY_%', 14) || 
    LPAD('OTHER_%', 8) || 
    LPAD('CLUSTER_%', 10) || 
    LPAD('PLSQL_%', 8) ||
    LPAD('JAVA_%', 7) || 
    LPAD('FETCHES_PER_EXEC', 17) || 
    LPAD('END_OF_FETCH_%', 15) ||
    LPAD('BUFFER_QUALITY_%', 17) || 
    LPAD('DISK_READ_TIME_MS', 18) ||
    LPAD('SHARABLE_MEM_KB', 16) LINE
  FROM DUAL
)
UNION ALL ( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('V$SQLSTATS', 18) || 
    LPAD(PLAN_HASH_VALUE, 11) || 
    LPAD("CPU_%", 6) || 
    LPAD("USER_IO_%", 10) || 
    LPAD("APPLICATION_%", 14) ||
    LPAD("CONCURRENCY_%", 14) || 
    LPAD("OTHER_%", 8) || 
    LPAD("CLUSTER_%", 10) || 
    LPAD("PLSQL_%", 8) ||
    LPAD("JAVA_%", 7) || 
    LPAD("FETCHES_PER_EXEC", 17) || 
    LPAD("END_OF_FETCH_%", 15) ||
    LPAD("BUFFER_QUALITY_%", 17) || 
    LPAD("DISK_READ_TIME_MS", 18) ||
    LPAD(TO_CHAR(SHARABLE_MEM / 1024, 999999990.99), 16) LINE
  FROM
  ( SELECT
      ROUND(CPU_TIME / ELAPSED_TIME * 100) "CPU_%",
      ROUND(USER_IO_WAIT_TIME / ELAPSED_TIME * 100) "USER_IO_%",
      ROUND(APPLICATION_WAIT_TIME / ELAPSED_TIME * 100) "APPLICATION_%",
      ROUND(CONCURRENCY_WAIT_TIME / ELAPSED_TIME * 100) "CONCURRENCY_%",
      ROUND((ELAPSED_TIME - CPU_TIME - USER_IO_WAIT_TIME -
        APPLICATION_WAIT_TIME - CONCURRENCY_WAIT_TIME -
        CLUSTER_WAIT_TIME - PLSQL_EXEC_TIME -
        JAVA_EXEC_TIME) / ELAPSED_TIME * 100) "OTHER_%",
      ROUND(CLUSTER_WAIT_TIME / ELAPSED_TIME * 100) "CLUSTER_%",
      ROUND(PLSQL_EXEC_TIME / ELAPSED_TIME * 100) "PLSQL_%",
      ROUND(JAVA_EXEC_TIME / ELAPSED_TIME * 100) "JAVA_%",
      TO_CHAR(DECODE(EXECUTIONS, 0, 0, FETCHES / EXECUTIONS), 9999999999990.99) "FETCHES_PER_EXEC",
      TO_CHAR(DECODE(EXECUTIONS, 0, 0, END_OF_FETCH_COUNT / EXECUTIONS * 100), 9999999990.99) "END_OF_FETCH_%",
      TO_CHAR(DECODE(BUFFER_GETS, 0, 0, (BUFFER_GETS - DISK_READS) / BUFFER_GETS * 100), 
        999999999990.99) "BUFFER_QUALITY_%",
      TO_CHAR(DECODE(DISK_READS, 0, 0, USER_IO_WAIT_TIME / DISK_READS / 1000),
        9999999999990.99) "DISK_READ_TIME_MS",
      SHARABLE_MEM,
      PLAN_HASH_VALUE
    FROM
      BASIS_INFO BI,
      V$SQLSTATS_PLAN_HASH SS
    WHERE 
      SS.SQL_ID = '&&sql_id' AND 
      ELAPSED_TIME > 0
  )
)
UNION ALL
( SELECT
    RPAD('DBA_HIST_SQLSTAT', 18) || 
    LPAD(PLAN_HASH_VALUE, 11) || 
    LPAD("CPU_%", 6) || 
    LPAD("USER_IO_%", 10) || 
    LPAD("APPLICATION_%", 14) ||
    LPAD("CONCURRENCY_%", 14) || 
    LPAD("OTHER_%", 8) || 
    LPAD("CLUSTER_%", 10) || 
    LPAD("PLSQL_%", 8) ||
    LPAD("JAVA_%", 7) || 
    LPAD("FETCHES_PER_EXEC", 17) || 
    LPAD("END_OF_FETCH_%", 15) ||
    LPAD("BUFFER_QUALITY_%", 17) || 
    LPAD("DISK_READ_TIME_MS", 18) ||
    LPAD(TO_CHAR(SHARABLE_MEM / 1024, 999999990.99), 16) LINE
  FROM
  ( SELECT
      ROUND(CPU_TIME_MS / ELAPSED_TIME_MS * 100) "CPU_%",
      ROUND(USER_IO_TIME_MS / ELAPSED_TIME_MS * 100) "USER_IO_%",
      ROUND(APPLICATION_TIME_MS / ELAPSED_TIME_MS * 100) "APPLICATION_%",
      ROUND(CONCURRENCY_TIME_MS / ELAPSED_TIME_MS * 100) "CONCURRENCY_%",
      ROUND((ELAPSED_TIME_MS - CPU_TIME_MS - USER_IO_TIME_MS -
        APPLICATION_TIME_MS - CONCURRENCY_TIME_MS -
        CLUSTER_TIME_MS - PLSQL_TIME_MS - 
        JAVA_TIME_MS) / ELAPSED_TIME_MS * 100) "OTHER_%",
      ROUND(CLUSTER_TIME_MS / ELAPSED_TIME_MS * 100) "CLUSTER_%",
      ROUND(PLSQL_TIME_MS / ELAPSED_TIME_MS * 100) "PLSQL_%",
      ROUND(JAVA_TIME_MS / ELAPSED_TIME_MS * 100) "JAVA_%",
      TO_CHAR(DECODE(EXECUTIONS, 0, 0, FETCHES / EXECUTIONS), 9999999999990.99) "FETCHES_PER_EXEC",
      TO_CHAR(DECODE(EXECUTIONS, 0, 0, END_OF_FETCH_COUNT / EXECUTIONS * 100), 9999999990.99) "END_OF_FETCH_%",
      TO_CHAR(DECODE(BUFFER_GETS, 0, 0, (BUFFER_GETS - DISK_READS) / BUFFER_GETS * 100), 
        999999999990.99) "BUFFER_QUALITY_%",
      TO_CHAR(DECODE(DISK_READS, 0, 0, USER_IO_TIME_MS / DISK_READS), 
        9999999999990.99) "DISK_READ_TIME_MS",
      SHARABLE_MEM,
      PLAN_HASH_VALUE
    FROM
    ( SELECT
        ROUND(SUM(HSQ.ELAPSED_TIME_DELTA) / 1000) ELAPSED_TIME_MS,
        ROUND(SUM(HSQ.CPU_TIME_DELTA) / 1000) CPU_TIME_MS,
        ROUND(SUM(HSQ.IOWAIT_DELTA) / 1000) USER_IO_TIME_MS,
        ROUND(SUM(HSQ.APWAIT_DELTA) / 1000) APPLICATION_TIME_MS,
        ROUND(SUM(HSQ.CCWAIT_DELTA) / 1000) CONCURRENCY_TIME_MS,
        ROUND(SUM(HSQ.CLWAIT_DELTA) / 1000) CLUSTER_TIME_MS,
        ROUND(SUM(HSQ.PLSEXEC_TIME_DELTA) / 1000) PLSQL_TIME_MS,
        ROUND(SUM(JAVEXEC_TIME_DELTA) / 1000) JAVA_TIME_MS,
        SUM(BUFFER_GETS_DELTA) BUFFER_GETS,
        SUM(DISK_READS_DELTA) DISK_READS,
        SUM(FETCHES_DELTA) FETCHES,
        SUM(END_OF_FETCH_COUNT_DELTA) END_OF_FETCH_COUNT,
        SUM(EXECUTIONS_DELTA) EXECUTIONS,
        MAX(SHARABLE_MEM) SHARABLE_MEM,
        HSQ.PLAN_HASH_VALUE
      FROM
        BASIS_INFO BI,
        DBA_HIST_SQLSTAT HSQ,
        SNAPSHOTS SS,
        V$INSTANCE I
      WHERE
        HSQ.DBID = BI.DBID AND
        I.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
        HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
        HSQ.SQL_ID = '&&sql_id'
      GROUP BY
        HSQ.PLAN_HASH_VALUE
      ORDER BY
        HSQ.PLAN_HASH_VALUE
    )
    WHERE
      ELAPSED_TIME_MS > 0
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'VIEW DEFINITIONS (V$SQL, V$OBJECT_DEPENDENCY, ' ||
      'OBJECTS, DBMS_METADATA.GET_DDL), NO SYS* VIEWS, ' ||
      'truncated to 4000 characters:' FROM DUAL
)
UNION ALL
( SELECT '(only available if statement is in V$SQL)' FROM DUAL
)
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT 
      DECODE(I, 1, ' ',
                2, VIEW_NAME || ':',
                3, ' ',
                TRANSLATE(TRANSLATE(SUBSTR(VIEW_DEFINITION, 1 + (I - 4) * 80,
                  80), CHR(10), ' '), CHR(9), ' ')) LINE
    FROM
    ( SELECT DISTINCT
        VI.VIEW_NAME,
        TO_CHAR(SUBSTR(DBMS_METADATA.GET_DDL('VIEW', VI.VIEW_NAME, VI.OWNER), 1, 4000))
          VIEW_DEFINITION
      FROM
        VIEW_INFO VI ) V,
    ( SELECT ROWNUM I FROM DBA_HIST_SQLTEXT WHERE ROWNUM <= 52 ) C
    WHERE
      DBMS_LOB.GETLENGTH("VIEW_DEFINITION") > (I - 4) * 80
    ORDER BY
      VIEW_NAME,
      I
  )
) 
UNION ALL 
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'EXECUTION PLAN (V$SQL_PLAN, DBA_HIST_SQL_PLAN):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 
    DISTINCT LINE 
  FROM
  ( SELECT
      'SQL PROFILE ''' || SQL_PROFILE || ''' USED' LINE
    FROM
      V$SQL
    WHERE
      SQL_ID = '&&sql_id' AND
      SQL_PROFILE IS NOT NULL
    UNION
    ( SELECT
        'SQL PROFILE ''' || SQL_PROFILE || ''' USED' LINE
      FROM
        DBA_HIST_SQLSTAT
      WHERE
        SQL_ID = '&&sql_id' AND
        SQL_PROFILE IS NOT NULL
    )
    UNION
    ( SELECT
        'SQL PLAN BASELINE ''' || SQL_PLAN_BASELINE || ' USED' LINE
      FROM
        V$SQL
      WHERE
        SQL_ID = '&&sql_id' AND
        SQL_PLAN_BASELINE IS NOT NULL
    )
    UNION
    ( SELECT
        'SQL PATCH ''' || SQL_PATCH || '''USED' LINE
      FROM
        V$SQL
      WHERE
        SQL_ID = '&&sql_id' AND
        SQL_PATCH IS NOT NULL
    )
  )  
)  
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD(ID, 5) ||
    RPAD(' ' || SQL_PLAN_STEP, 230) LINE
  FROM
  ( SELECT
      LPAD(DECODE(L.NUM, 1, TO_CHAR(SP.ID), ' '), 4) ID,
      LPAD(' ', SP.DEPTH * 2) ||
        DECODE(L.CONTENT, 
          'ACTION',           ACTION_INFO || DECODE(SP.ID, 0, 
                              ' (Plan Hash: ' || SP.PLAN_HASH_VALUE || 
                              ', Child: ' || SP.CHILD_NUMBER || 
                              DECODE(OPTIMIZER, NULL, NULL, ', Optimizer: "' || 
                              OPTIMIZER || '"') || ')'),
          'COST',             '  ' || COST_INFO,
          'SEARCH COLUMNS',   '  ' || SEARCH_COLUMNS_INFO,
          'ACCESS PREDICATE', DECODE(PL.POS1, 1, '  ', '    ') || 
                              SUBSTR(PL.PREDICATE_INFO, PL.POS1 + 1, PL.POS2 - PL.POS1),
          'FILTER PREDICATE', DECODE(PL.POS1, 1, '  ', '    ') || 
                              SUBSTR(PL.PREDICATE_INFO, PL.POS1 + 1, PL.POS2 - PL.POS1),
          'SPACE',            '  ' || SPACE_INFO,
          'PARTITION',        '  ' || PARTITION_INFO,
          'PX',               '  ' || PX_INFO,
          'PLAN STATISTICS',  '  ' || PLAN_STATISTICS_INFO,
          'EMPTY',            ' ') SQL_PLAN_STEP
    FROM
      LINES L,
      SQL_PLANS SP,
      PRED_START_END_LINE_POSITIONS PL
    WHERE
      ( L.CONTENT = 'ACTION' AND PL.LINE = 1 OR
        L.CONTENT = 'COST' AND SP.COST_INFO IS NOT NULL AND PL.LINE = 1  OR
        L.CONTENT = 'SEARCH COLUMNS' AND SP.SEARCH_COLUMNS_INFO IS NOT NULL AND PL.LINE = 1 OR
        L.CONTENT = 'ACCESS PREDICATE' AND SP.ACCESS_PREDICATE_INFO IS NOT NULL AND 
          PL.PREDICATE_TYPE = 'ACCESS' AND PL.PLAN_HASH_VALUE = SP.PLAN_HASH_VALUE AND
          PL.CHILD_NUMBER = SP.CHILD_NUMBER AND PL.ID = SP.ID OR
        L.CONTENT = 'FILTER PREDICATE' AND SP.FILTER_PREDICATE_INFO IS NOT NULL AND 
          PL.PREDICATE_TYPE = 'FILTER' AND PL.PLAN_HASH_VALUE = SP.PLAN_HASH_VALUE AND
          PL.CHILD_NUMBER = SP.CHILD_NUMBER AND PL.ID = SP.ID OR
        L.CONTENT = 'SPACE'            AND SP.SPACE_INFO IS NOT NULL AND PL.LINE = 1 OR
        L.CONTENT = 'PARTITION'        AND SP.PARTITION_INFO IS NOT NULL AND PL.LINE = 1 OR
        L.CONTENT = 'PX'               AND SP.PX_INFO IS NOT NULL AND PL.LINE = 1 OR
        L.CONTENT = 'PLAN STATISTICS'  AND SP.PLAN_STATISTICS_INFO IS NOT NULL AND PL.LINE = 1 OR
        L.CONTENT = 'EMPTY' AND PL.LINE = 1
      )
    ORDER BY
      SP.PLAN_HASH_VALUE,
      SP.CHILD_NUMBER,
      SP.ID,
      L.NUM,
      PL.POS1
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'SQL WORKAREAS (V$SQL_WORKAREA):' LINE
  FROM 
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('OPERATION_ID ', 13) ||
    RPAD('OPERATION_TYPE', 40) ||
    LPAD('LAST_MEMORY_USED', 17) ||
    LPAD('LAST_TEMPSEG_SIZE', 18) ||
    LPAD('MAX_TEMPSEG_SIZE', 17) ||
    LPAD('OPTIMAL_EXECUTIONS', 19) ||
    LPAD('ONEPASS_EXECUTIONS', 19) ||
    LPAD('MULTIPASSES_EXECUTIONS', 23) LINE
  FROM  
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      LPAD(OPERATION_ID || ' ', 13) ||
      RPAD(OPERATION_TYPE, 40) ||
      LPAD(LAST_MEMORY_USED, 17) ||
      LPAD(NVL(TO_CHAR(LAST_TEMPSEG_SIZE), ' '), 18) ||
      LPAD(NVL(TO_CHAR(MAX_TEMPSEG_SIZE), ' '), 17) ||
      LPAD(OPTIMAL_EXECUTIONS, 19) ||
      LPAD(ONEPASS_EXECUTIONS, 19) ||
      LPAD(MULTIPASSES_EXECUTIONS, 23) LINE
    FROM
      BASIS_INFO BI,
      V$SQL_WORKAREA SWA
    WHERE
      SWA.SQL_ID = '&&sql_id' 
    ORDER BY
      OPERATION_ID
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'ACTIVE SQL WORKAREAS (V$SQL_WORKAREA_ACTIVE):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('OPERATION_ID ', 13) ||
    RPAD('OPERATION_TYPE', 40) ||
    LPAD('MAX_MEMORY_USED', 17) ||
    LPAD('TEMPSEG_SIZE', 18) ||
    LPAD('NUMBER_PASSES', 14) LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      LPAD(OPERATION_ID || ' ', 13) ||
      RPAD(OPERATION_TYPE, 40) ||
      LPAD(MAX_MEM_USED, 17) ||
      LPAD(NVL(TO_CHAR(TEMPSEG_SIZE), ' '), 18) ||
      LPAD(NUMBER_PASSES, 14) LINE
    FROM
      BASIS_INFO BI,
      V$SQL_WORKAREA_ACTIVE SWA
    WHERE
      SWA.SQL_ID = '&&sql_id' 
    ORDER BY
      OPERATION_ID
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'TEMPORARY SEGMENTS (V$TEMPSEG_USAGE):' LINE
  FROM 
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('TABLESPACE_NAME', 32) ||
    RPAD('CONTENTS', 10) ||
    RPAD('SEGTYPE', 10) ||
    LPAD('SIZE_MB', 10) LINE
  FROM  
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      RPAD(TSU.TABLESPACE, 32) ||
      RPAD(TSU.CONTENTS, 10) ||
      RPAD(TSU.SEGTYPE, 10) ||
      TO_CHAR(SUM(TSU.BLOCKS * TS.BLOCK_SIZE) / 1024 / 1024, 999990.99) LINE
    FROM
      BASIS_INFO BI,
      V$TEMPSEG_USAGE TSU,
      DBA_TABLESPACES TS
    WHERE
      TSU.SQL_ID = '&&sql_id' AND
      TSU.TABLESPACE = TS.TABLESPACE_NAME
    GROUP BY
      TSU.TABLESPACE,
      TSU.CONTENTS,
      TSU.SEGTYPE
    ORDER BY
      SUM(TSU.BLOCKS * TS.BLOCK_SIZE) DESC
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'ACTIVE SESSION HISTORY INFORMATION (DBA_HIST_ACTIVE_SESS_HISTORY):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      RPAD('USER_NAME', 30) ||
      RPAD('SQL_TYPE', 30) ||
      RPAD('MODULE', 50) ||
      RPAD('MOD_ACTION', 30) ||
      RPAD('TOP_LEVEL_SQL_ID', 17) LINE
    FROM DUAL
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD(ASH.USER_NAME, 30) ||
        RPAD(ASH.SQL_OPNAME, 30) ||
        RPAD(ASH.MODULE, 50) ||
        RPAD(NVL(ASH.MOD_ACTION, ' '), 30) ||
        RPAD(NVL(ASH.TOP_LEVEL_SQL_ID, ' '), 17) LINE
      FROM 
        ASH_DISTRIBUTION ASH
      WHERE 
        ROWNUM = 1
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LPAD('AVG_CONCURRENT_EXECUTIONS', 26) ||
        LPAD('MAX_CONCURRENT_EXECUTIONS', 26) ||
        LPAD('MAX_PGA_MB', 26) ||
        LPAD('MAX_TEMP_MB', 26) LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LPAD(TO_CHAR(AVG(SUM(OCCURRENCES)), 999999990.99), 26) ||
        LPAD(TO_CHAR(MAX(SUM(OCCURRENCES)), 999999990), 26) ||
        LPAD(TO_CHAR(MAX(MAX(NVL(MAX_PGA_MB, 0))), 999999990.99), 26) ||
        LPAD(TO_CHAR(MAX(MAX(NVL(MAX_TEMP_MB, 0))), 999999990.99), 26) LINE
      FROM
        ASH_DISTRIBUTION
      GROUP BY
        SAMPLE_TIME
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('PLAN_HASH', 11) ||
        LPAD('PLAN_ID', 8) ||
        LPAD('SAMPLES', 12) ||
        LPAD('PLAN_PCT', 9) ||
        LPAD('TOTAL_PCT', 10) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(PLAN_HASH_VALUE, 11) ||
          LPAD(PLAN_ID, 8) ||
          LPAD(SUM(OCCURRENCES), 12) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100, 99990.99) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 999990.99) LINE
        FROM
          ASH_DISTRIBUTION
        GROUP BY
          PLAN_HASH_VALUE,
          PLAN_ID
        ORDER BY
          PLAN_HASH_VALUE,
          SUM(OCCURRENCES) DESC
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('PLAN_HASH', 11) ||
        RPAD('SEGMENT_NAME', 35) ||
        LPAD('SAMPLES', 12) ||
        LPAD('PLAN_PCT', 9) ||
        LPAD('TOTAL_PCT', 10) LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(PLAN_HASH_VALUE, 11) ||
          RPAD(OBJECT_NAME, 35) ||
          LPAD(SUM(OCCURRENCES), 12) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100, 99990.99) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 999990.99) LINE
        FROM
          ASH_DISTRIBUTION
        GROUP BY
          PLAN_HASH_VALUE,
          OBJECT_NAME
        ORDER BY
          PLAN_HASH_VALUE,
          SUM(OCCURRENCES) DESC
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('PLAN_HASH', 11) ||
        RPAD('EVENT', 50) ||
        LPAD('SAMPLES', 12) ||
        LPAD('PLAN_PCT', 9) ||
        LPAD('TOTAL_PCT', 10) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(PLAN_HASH_VALUE, 11) ||
          RPAD(EVENT, 50) ||
          LPAD(SUM(OCCURRENCES), 12) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100, 99990.99) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 999990.99) LINE
        FROM
          ASH_DISTRIBUTION
        GROUP BY
          PLAN_HASH_VALUE,
          EVENT
        ORDER BY
          PLAN_HASH_VALUE,
          SUM(OCCURRENCES) DESC
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('PLAN_HASH', 11) ||
        RPAD('ACTIVITY', 30) ||
        LPAD('SAMPLES', 12) ||
        LPAD('PLAN_PCT', 9) ||
        LPAD('TOTAL_PCT', 10) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(PLAN_HASH_VALUE, 11) ||
          RPAD(NVL(ACTIVITY, ' '), 30) ||
          LPAD(SUM(OCCURRENCES), 12) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100, 99990.99) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 999990.99) LINE
        FROM
          ASH_DISTRIBUTION
        GROUP BY
          PLAN_HASH_VALUE,
          ACTIVITY
        ORDER BY
          PLAN_HASH_VALUE,
          SUM(OCCURRENCES) DESC
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL  
    ( SELECT
        RPAD('PLAN_HASH', 11) ||
        RPAD('SEGMENT_NAME', 35) ||
        RPAD('EVENT', 50) ||
        LPAD('SAMPLES', 12) ||
        LPAD('PLAN_PCT', 9) ||
        LPAD('TOTAL_PCT', 10) ||
        LPAD('BLOCKS_PER_WAIT', 16) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(PLAN_HASH_VALUE, 11) ||
          RPAD(OBJECT_NAME, 35) ||
          RPAD(EVENT, 50) ||
          LPAD(SUM(OCCURRENCES), 12) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100, 99990.99) ||
          TO_CHAR(RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100, 999990.99) ||
          DECODE(WAIT_CLASS, 'User I/O', DECODE(EVENT, 'Data file init write', ' ',
            TO_CHAR(SUM(BLOCKS_ACCESSED) / SUM(OCCURRENCES), 999999999990.99)), ' ') LINE
        FROM
          ASH_DISTRIBUTION
        GROUP BY
          PLAN_HASH_VALUE,
          EVENT,
          WAIT_CLASS,
          OBJECT_NAME
        ORDER BY
          PLAN_HASH_VALUE,
          SUM(OCCURRENCES) DESC
      )
    )
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'TOP HOURS (DBA_HIST_ACTIVE_SESS_HISTORY):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('PLAN_HASH', 11) ||
    RPAD('HOUR', 20) ||
    LPAD('PLAN_PCT', 9) ||
    LPAD('TOTAL_PCT', 10) LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      RPAD(PLAN_HASH_VALUE, 11) ||
      RPAD(HOUR || ':00:00', 20) ||
      TO_CHAR(PLAN_PCT, 99990.99) ||
      TO_CHAR(TOTAL_PCT, 999990.99) LINE
    FROM
    ( SELECT
        PLAN_HASH_VALUE,
        HOUR,
        RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER (PARTITION BY PLAN_HASH_VALUE) * 100 PLAN_PCT,
        RATIO_TO_REPORT(SUM(OCCURRENCES)) OVER () * 100 TOTAL_PCT
      FROM
        ASH_DISTRIBUTION
      GROUP BY
        PLAN_HASH_VALUE,
        HOUR
    )
    WHERE
      TOTAL_PCT >= 2
    ORDER BY 
      PLAN_HASH_VALUE,
      PLAN_PCT DESC
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( ( SELECT
        'SEGMENT STATISTICS (V$SEGMENT_STATISTICS):' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('SEGMENT_NAME', 35) || LPAD('LOG_READS', 12) || LPAD('PHYS_READS', 12) ||
        LPAD('DIR_READS', 12) || LPAD('PHYS_WRITES', 12) || LPAD('DIR_WRITES', 12) ||
        LPAD('ITL_WAITS', 12) || LPAD('ROW_LOCKS', 12) || LPAD('BUFFER_BUSY', 12) ||
        LPAD('BLK_CHANGES', 12) || LPAD('SEGMENT_SCANS', 14) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT * FROM
      ( SELECT
          RPAD(O.OBJECT_NAME, 35) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'logical reads', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'physical reads', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'physical reads direct', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'physical writes', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'physical writes direct', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'ITL waits', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'row lock waits', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'buffer busy waits', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'db block changes', VALUE, 0)), 12) ||
          LPAD(SUM(DECODE(STATISTIC_NAME, 'segment scans', VALUE, 0)), 14) LINE
        FROM V$SEGSTAT SS, OBJECTS O
        WHERE
          SS.OBJ# = O.OBJECT_ID AND
          ( O.OBJECT_TYPE IN ( 'TABLE', 'TABLE PARTITION' ) AND
            ( O.OWNER, O.OBJECT_NAME ) IN
            ( SELECT TABLE_OWNER, TABLE_NAME FROM TABLE_INFO
            ) OR
            O.OBJECT_TYPE IN ( 'INDEX', 'INDEX PARTITION' ) AND
            ( O.OWNER, O.OBJECT_NAME ) IN
            ( SELECT INDEX_OWNER, INDEX_NAME FROM INDEX_INFO
          ) )     
        GROUP BY O.OBJECT_NAME
        ORDER BY O.OBJECT_NAME
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'SEGMENT STATISTICS (DBA_HIST_SEG_STAT):' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('SEGMENT_NAME', 35) ||
        LPAD('LOG_READS', 12) ||
        LPAD('PHYS_READS', 12) ||
        LPAD('DIR_READS', 12) ||
        LPAD('PHYS_WRITES', 12) ||
        LPAD('DIR_WRITES', 12) ||
        LPAD('ITL_WAITS', 12) ||
        LPAD('ROW_LOCKS', 12) ||
        LPAD('BUFFER_BUSY', 12) ||
        LPAD('BLK_CHANGES', 12) ||
        LPAD('SEGMENT_SCANS', 14) LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(SEGMENT_NAME, 35) || LPAD(LOGICAL_READS, 12) || LPAD(PHYSICAL_READS, 12) ||
          LPAD(PHYSICAL_READS_DIRECT, 12) || LPAD(PHYSICAL_WRITES, 12) ||
          LPAD(PHYSICAL_WRITES_DIRECT, 12) || LPAD(ITL_WAITS, 12) ||
          LPAD(ROW_LOCK_WAITS, 12) || LPAD(BUFFER_BUSY_WAITS, 12) ||
          LPAD(DB_BLOCK_CHANGES, 12) || LPAD(SEGMENT_SCANS, 14) LINE
        FROM
          SEGMENT_STATISTICS SS
        WHERE
          ( SS.SEG_TYPE IN ( 'TABLE', 'TABLE PARTITION' ) AND
            ( SS.OWNER, SS.SEGMENT_NAME ) IN
            ( SELECT TABLE_OWNER, TABLE_NAME
              FROM TABLE_INFO
            ) OR
            SS.SEG_TYPE IN ( 'INDEX', 'INDEX PARTITION' ) AND
            ( SS.OWNER, SS.SEGMENT_NAME ) IN
            ( SELECT INDEX_OWNER, INDEX_NAME
              FROM INDEX_INFO
            )
          )
        ORDER BY 
          SEGMENT_NAME
      )
    )
    UNION ALL ( SELECT  ' ' FROM DUAL )
    UNION ALL ( SELECT LPAD('*', 240, '*') FROM DUAL )
    UNION ALL ( SELECT  ' ' FROM DUAL )
    UNION ALL ( SELECT 'INDEX COLUMNS (DBA_INDEXES):' FROM DUAL )
    UNION ALL ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('TABLE_NAME', 30) ||
        RPAD('INDEX_NAME', 35) ||
        RPAD('COLUMN_NAME', 30) ||
        LPAD('NUM_DISTINCT', 12) ||
        LPAD('AVG_COL_LEN', 12) ||
        LPAD('COLUMN_POSITION', 16) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD(DECODE(TABLE_NAME, LAG(TABLE_NAME, 1) OVER
          (ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION),
          ' ', TABLE_NAME), 30) ||
        RPAD(DECODE(INDEX_NAME, LAG(INDEX_NAME, 1) OVER
          (ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION),
          ' ', INDEX_NAME), 35) ||
        RPAD(COLUMN_NAME, 30) ||
        LPAD(NVL(TO_CHAR(NUM_DISTINCT), ' '), 12) ||
        LPAD(NVL(TO_CHAR(AVG_COL_LEN), ' '), 12) ||
        LPAD(COLUMN_POSITION, 16) LINE
      FROM
      ( SELECT
          *
        FROM
        ( SELECT 
            I.TABLE_NAME,
            I.INDEX_NAME,
            I.COLUMN_NAME,
            I.COLUMN_POSITION,
            T.AVG_COL_LEN,
            T.NUM_DISTINCT,
            ROWNUM ROWNUMBER
          FROM
            TABLE_INFO TI,
            DBA_IND_COLUMNS I, 
            DBA_TAB_COLUMNS T,
            BASIS_INFO BI
          WHERE 
            BI.INDEX_COLUMNS = 'X' AND
            I.TABLE_OWNER = TI.TABLE_OWNER AND
            I.TABLE_NAME = TI.TABLE_NAME AND
            I.TABLE_OWNER = T.OWNER AND
            I.TABLE_NAME = T.TABLE_NAME AND
            I.COLUMN_NAME = T.COLUMN_NAME 
          UNION ALL
          ( SELECT 
              I.TABLE_NAME,
              I.INDEX_NAME,
              'Function' COLUMN_NAME,
              I.COLUMN_POSITION,
              NULL AVG_COL_LEN,
              NULL NUM_DISTINCT,
              ROWNUM ROWNUMBER
            FROM
              TABLE_INFO TI,
              DBA_IND_COLUMNS I, 
              DBA_IND_EXPRESSIONS IE,
              BASIS_INFO BI
            WHERE 
              BI.INDEX_COLUMNS = 'X' AND
              I.TABLE_OWNER = TI.TABLE_OWNER AND
              I.TABLE_NAME = TI.TABLE_NAME AND
              I.INDEX_OWNER = IE.INDEX_OWNER AND
              I.INDEX_NAME = IE.INDEX_NAME AND
              I.COLUMN_POSITION = IE.COLUMN_POSITION     
          )
        )
        ORDER BY
          TABLE_NAME,
          INDEX_NAME,
          COLUMN_POSITION
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT LPAD('*', 240, '*') FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'CBO STATISTICS (DBA_TAB_STATISTICS, DBA_INDEXES, DBA_TAB_COLUMNS, DBA_TAB_STATS_HISTORY, DBA_OPTSTAT_OPERATIONS):' LINE
      FROM DUAL 
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'TABLE STATISTICS:' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('OWNER', 10) ||
        RPAD('TABLE_NAME', 35) ||
        RPAD('PARTITION_NAME', 30) ||
        LPAD('NUM_ROWS', 12) ||
        LPAD('BLOCKS', 10) ||
        LPAD('AVG_ROW_LEN', 12) ||
        LPAD('LAST_ANALYZED', 22) ||
        LPAD('SAMPLE_SIZE', 12) ||
        LPAD('CREATION_TIME', 22) ||
        LPAD('LAST_DDL_TIME', 22) ||
        LPAD('USER_STATS', 11) ||
        LPAD('INI_TRANS', 10) ||
        LPAD('PCT_FREE', 9) ||
        LPAD('DEGREE', 8) ||
        RPAD(' COMPRESS', 9) LINE
      FROM DUAL 
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          LINE
        FROM
        ( SELECT /*+ LEADING(TS) */
            RPAD(T.OWNER, 10) ||
            RPAD(T.TABLE_NAME, 35) ||
            RPAD(NVL(T.PARTITION_NAME, ' '), 30) ||
            LPAD(NVL(TO_CHAR(T.NUM_ROWS), ' '), 12) ||
            LPAD(NVL(TO_CHAR(T.BLOCKS), ' '), 10) ||
            LPAD(NVL(TO_CHAR(T.AVG_ROW_LEN), ' '), 12) ||
            LPAD(DECODE(T.LAST_ANALYZED, NULL, ' ', TO_CHAR(T.LAST_ANALYZED, 'YYYY-MM-DD HH24:MI:SS')), 22) ||
            LPAD(NVL(TO_CHAR(T.SAMPLE_SIZE), '0'), 12) ||
            LPAD(DECODE(O.CREATED, NULL, ' ', TO_CHAR(O.CREATED,
              'YYYY-MM-DD HH24:MI:SS')), 22) ||
            LPAD(DECODE(O.LAST_DDL_TIME, NULL, ' ', TO_CHAR(O.LAST_DDL_TIME, 'YYYY-MM-DD HH24:MI:SS')), 22) ||
            LPAD(T.USER_STATS, 11) ||
            LPAD(DECODE(T.PARTITION_NAME, NULL, TO_CHAR(TS.INI_TRANS), ' '), 10) ||
            LPAD(DECODE(T.PARTITION_NAME, NULL, TO_CHAR(TS.PCT_FREE), ' '), 9) ||
            LPAD(TS.DEGREE, 8) ||
            RPAD(' ' || TS.COMPRESSION, 9) LINE,
            T.OWNER,
            T.TABLE_NAME,
            NVL(T.PARTITION_POSITION, 0) PARTITION_POSITION
          FROM
            TABLE_STORAGE TS, 
            DBA_TAB_STATISTICS T, 
            OBJECTS O
          WHERE
            TS.TABLE_OWNER = T.OWNER AND
            TS.TABLE_NAME = T.TABLE_NAME AND
            NVL(TS.PARTITION_NAME, ' ') = NVL(T.PARTITION_NAME, ' ') AND
            T.OWNER = O.OWNER AND
            T.TABLE_NAME = O.OBJECT_NAME AND
            NVL(T.PARTITION_NAME, ' ') = NVL(O.SUBOBJECT_NAME, ' ') AND
            O.OBJECT_TYPE IN ('TABLE', 'TABLE PARTITION')
        )
        ORDER BY
          OWNER,
          TABLE_NAME,
          PARTITION_POSITION
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'INDEX STATISTICS (INDEX PARTITIONS ARE NOT CONSIDERED):' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('INDEX_NAME', 30) ||
        LPAD('NUM_ROWS', 12) ||
        LPAD('LEAF_BLOCKS', 12) ||
        LPAD('DISTINCT_KEYS', 14) ||
        LPAD('CLUST_FACTOR', 13) ||
        LPAD('BLEVEL', 7) ||
        LPAD('LAST_ANALYZED', 22) ||
        LPAD('SAMPLE_SIZE', 12) ||
        RPAD(' INDEX_TYPE', 12) ||
        RPAD('UNIQUENESS', 11) ||
        LPAD('CREATION_TIME', 22) ||
        LPAD('LAST_DDL_TIME', 22) ||
        LPAD('USER_STATS', 11) ||
        LPAD('INI_TRANS', 10) ||
        LPAD('PCT_FREE', 9) ||
        LPAD('DEGREE', 8) ||
        RPAD(' COMPRESS', 10) LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT 
          RPAD(I.INDEX_NAME, 30) ||
          LPAD(NVL(TO_CHAR(I.NUM_ROWS), ' '), 12) ||
          LPAD(NVL(TO_CHAR(I.LEAF_BLOCKS), ' '), 12) ||
          LPAD(NVL(TO_CHAR(I.DISTINCT_KEYS), ' '), 14) ||
          LPAD(NVL(TO_CHAR(I.CLUSTERING_FACTOR), ' '), 13) ||
          LPAD(NVL(TO_CHAR(I.BLEVEL), ' '), 7) ||
          LPAD(DECODE(I.LAST_ANALYZED, NULL, ' ', TO_CHAR(I.LAST_ANALYZED, 'YYYY-MM-DD HH24:MI:SS')), 22) ||
          LPAD(NVL(TO_CHAR(I.SAMPLE_SIZE), ' '), 12) ||
          RPAD(' ' || I.INDEX_TYPE, 12) ||
          RPAD(I.UNIQUENESS, 11) ||
          LPAD(TO_CHAR(O.CREATED, 'YYYY-MM-DD HH24:MI:SS'), 22) ||
          LPAD(TO_CHAR(O.LAST_DDL_TIME, 'YYYY-MM-DD HH24:MI:SS'), 22) ||
          LPAD(I.USER_STATS, 11) ||
          LPAD(I.INI_TRANS, 10) ||
          LPAD(I.PCT_FREE, 9) ||
          LPAD(I.DEGREE, 8) ||
          RPAD(' ' || DECODE(II.COMPRESSION, 'YES', II.COMPRESSION || 
            ' (' || II.PREFIX_LENGTH || ')', II.COMPRESSION), 10) LINE
        FROM
          DBA_INDEXES I, OBJECTS O, INDEX_INFO II
        WHERE
          I.INDEX_TYPE != 'LOB' AND
          I.OWNER = O.OWNER AND
          I.INDEX_NAME = O.OBJECT_NAME AND
          O.SUBOBJECT_NAME IS NULL AND
          I.OWNER = II.INDEX_OWNER AND
          I.INDEX_NAME = II.INDEX_NAME AND
          O.OBJECT_TYPE = 'INDEX'
        ORDER BY
          I.OWNER,
          I.TABLE_NAME,
          I.INDEX_NAME
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'COLUMN STATISTICS:' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('TABLE_NAME', 30) ||
        RPAD('COLUMN_NAME', 25) ||
        LPAD('NUM_DISTINCT', 13) ||
        LPAD('DENSITY', 9) ||
        LPAD('NUM_BUCKETS', 12) ||
        LPAD('AVG_COL_LEN', 12) ||
        LPAD('DATA_LENGTH', 12) ||
        LPAD('NULLABLE', 9) ||
        LPAD('NUM_NULLS', 12) ||
        RPAD(' DATA_TYPE', 20) ||
        LPAD('LAST_ANALYZED', 22) ||
        LPAD('SAMPLE_SIZE', 12) ||
        LPAD('USER_STATS', 11) LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(DECODE(TCS.TABLE_NAME, LAG(TCS.TABLE_NAME, 1) OVER 
            (ORDER BY TCS.OWNER, TCS.TABLE_NAME, TCS.COLUMN_NAME),
            ' ', TCS.TABLE_NAME), 30) ||
          RPAD(TCS.COLUMN_NAME, 25) ||
          LPAD(NVL(TO_CHAR(TCS.NUM_DISTINCT), ' '), 13) ||
          LPAD(DECODE(TCS.DENSITY, NULL, ' ', TO_CHAR(TCS.DENSITY, 90.999999)), 9) ||
          LPAD(NVL(TO_CHAR(TCS.NUM_BUCKETS), ' '), 12) ||
          LPAD(NVL(TO_CHAR(TCS.AVG_COL_LEN), ' '), 12) ||
          LPAD(NVL(TO_CHAR(TCS.DATA_LENGTH), ' '), 12) ||
          LPAD(NVL(TCS.NULLABLE, ' '), 9) ||
          LPAD(NVL(TO_CHAR(TCS.NUM_NULLS), ' '), 12) ||
          RPAD(' ' || TCS.DATA_TYPE, 20) ||
          LPAD(DECODE(TCS.LAST_ANALYZED, NULL, ' ', TO_CHAR(TCS.LAST_ANALYZED, 
            'YYYY-MM-DD HH24:MI:SS')), 22) ||
          LPAD(NVL(TO_CHAR(TCS.SAMPLE_SIZE), ' '), 12) ||
          LPAD(TCS.USER_STATS, 11) LINE
        FROM
          DBA_TAB_COLUMNS TCS, TABLE_INFO TI
        WHERE
          TCS.OWNER = TI.TABLE_OWNER AND
          TCS.TABLE_NAME = TI.TABLE_NAME
        ORDER BY
          TCS.OWNER,
          TCS.TABLE_NAME,
          TCS.COLUMN_NAME
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'TABLE STATISTICS HISTORY:'
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT 
        RPAD('OWNER', 10) ||
        RPAD('TABLE_NAME', 35) ||
        RPAD('PARTITION_NAME', 30) ||
        LPAD('STATS_UPDATE_TIME', 22) 
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD(DECODE(ROW_NUM, 1, OWNER, ' '), 10) ||
        RPAD(DECODE(ROW_NUM, 1, TABLE_NAME, ' '), 35) ||
        RPAD(DECODE(ROW_NUM, 1, NVL(PARTITION_NAME, ' '), ' '), 30) ||
        LPAD(TO_CHAR(STATS_UPDATE_TIME, 'YYYY-MM-DD HH24:MI:SS'), 22) LINE
      FROM
      ( SELECT
          TSH.OWNER,
          TSH.TABLE_NAME,
          TSH.PARTITION_NAME,
          TSH.STATS_UPDATE_TIME,
          ROW_NUMBER () OVER (PARTITION BY TSH.OWNER, TSH.TABLE_NAME, TS.PARTITION_POSITION
            ORDER BY TSH.STATS_UPDATE_TIME DESC) ROW_NUM
        FROM
          TABLE_STORAGE TS,
          DBA_TAB_STATS_HISTORY TSH
        WHERE
          TS.TABLE_OWNER = TSH.OWNER AND
          TS.TABLE_NAME = TSH.TABLE_NAME AND
          NVL(TS.PARTITION_NAME, ' ') = NVL(TSH.PARTITION_NAME, ' ')
        ORDER BY
          TSH.OWNER,
          TSH.TABLE_NAME,
          TS.PARTITION_POSITION,
          TSH.STATS_UPDATE_TIME DESC
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'COLLECTION OF SPECIAL STATISTICS:'
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('OPERATION', 30) ||
        LPAD('START_TIME', 22) ||
        LPAD('END_TIME', 22) 
      FROM DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        *
      FROM
      ( SELECT
          RPAD(OPERATION, 30) ||
          LPAD(TO_CHAR(START_TIME, 'YYYY-MM-DD HH24:MI:SS'), 22) ||
          LPAD(TO_CHAR(END_TIME, 'YYYY-MM-DD HH24:MI:SS'), 22) 
        FROM
          DBA_OPTSTAT_OPERATIONS
        WHERE 
          SUBSTR(UPPER(OPERATION), 1, 6) = 'GATHER' AND
          OPERATION != 'gather_table_stats'
        ORDER BY
          START_TIME DESC
      )
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT LPAD('*', 240, '*') FROM DUAL )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'TABLE MODIFICATIONS (DBA_TAB_MODIFICATIONS):' LINE
      FROM DUAL 
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('OWNER', 10) || 
        RPAD('TABLE_NAME', 35) || 
        RPAD('PARTITION_NAME', 30) ||
        LPAD('INSERTS', 10) || 
        LPAD('UPDATES', 10) || 
        LPAD('DELETES', 10) || 
        LPAD('TRUNCATED', 10) || 
        LPAD('DROP_SEGMENTS', 14) LINE
      FROM
        DUAL
    )
    UNION ALL ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        LINE
      FROM
      ( SELECT
          RPAD(DTM.TABLE_OWNER, 10) ||
          RPAD(DTM.TABLE_NAME, 35) ||
          RPAD(NVL(DTM.PARTITION_NAME, ' '), 30) ||
          LPAD(DTM.INSERTS, 10) ||
          LPAD(DTM.UPDATES, 10) ||
          LPAD(DTM.DELETES, 10) ||
          LPAD(DTM.TRUNCATED, 10) ||
          LPAD(DTM.DROP_SEGMENTS, 14) LINE
        FROM
          TABLE_INFO TI,
          SYS.DBA_TAB_MODIFICATIONS DTM
        WHERE
          TI.TABLE_OWNER = DTM.TABLE_OWNER AND
          TI.TABLE_NAME = DTM.TABLE_NAME
        ORDER BY
          DTM.TABLE_OWNER,
          DTM.TABLE_NAME
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT LPAD('*', 240, '*') FROM DUAL )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'FRAGMENTATION INFORMATION (BASED ON CBO STATISTICS):' LINE
      FROM DUAL 
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('SEGMENT_NAME', 30) ||
        RPAD('PARTITION_NAME', 30) ||
        LPAD('UNUSED_MB', 11) ||
        LPAD('QUALITY_%', 10) ||
        LPAD('SEG_GROSS_MB', 13) ||
        LPAD('SEG_NET_MB', 11) ||
        LPAD('DATA_GROSS_MB', 14) ||
        LPAD('DATA_NET_MB', 12) ||
        RPAD(' RESTRICTIONS', 120) LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT 
        RPAD(DECODE(SEGMENT_NAME, LAG(SEGMENT_NAME, 1) OVER (ORDER BY 1), ' ', SEGMENT_NAME), 30) ||
        RPAD(NVL(PARTITION_NAME, ' '), 30) ||
        LPAD(NVL(TO_CHAR(UNUSED_MB, 999990.99), ' '), 11) ||
        LPAD(NVL(TO_CHAR(QUALITY, 99990.99), ' '), 10) ||
        LPAD(NVL(TO_CHAR(SEG_GROSS_MB, 99999990.99), ' '), 13) ||
        LPAD(NVL(TO_CHAR(SEG_NET_MB, 9999990.99), ' '), 11) ||
        LPAD(NVL(TO_CHAR(DATA_GROSS_MB, 999999990.99), ' '), 14) ||
        LPAD(NVL(TO_CHAR(DATA_NET_MB, 9999990.99), ' '), 12) ||
        RPAD(' ' || RESTRICTIONS, 120) LINE
      FROM
      ( SELECT
          SEGMENT_NAME,
          PARTITION_NAME,
          SEG_GROSS_MB,
          SEG_NET_MB,
          DATA_GROSS_MB,
          DATA_NET_MB,
          UNUSED_MB,
          DECODE(UNUSED_MB + DATA_NET_MB, 0, 0, DATA_NET_MB / (UNUSED_MB + DATA_NET_MB) * 100) QUALITY,
          RESTRICTIONS,
          PARTITION_POSITION
        FROM
        ( SELECT 
            SEGMENT_NAME,
            PARTITION_NAME,
            DECODE(CLUSTER_TABLE, 'YES', DATA_GROSS_MB * 1.1, SEG_GROSS_MB) SEG_GROSS_MB,
            DECODE(CLUSTER_TABLE, 'YES', DATA_GROSS_MB, SEG_NET_MB) SEG_NET_MB,
            DATA_GROSS_MB + GREATEST(0, CHANGE_MB) DATA_GROSS_MB,
            GREATEST(0, DATA_NET_MB + CHANGE_MB) DATA_NET_MB,
            LEAST(SEG_GROSS_MB, GREATEST(DATA_GROSS_MB + GREATEST(0, CHANGE_MB), SEG_NET_MB)) - 
              DATA_NET_MB - CHANGE_MB UNUSED_MB,
            DECODE(USER_STATS,        'YES', 'STATISTICS MODIFIED   ') ||
              DECODE(LONG_RAW,        'YES', 'LONG RAW   ') ||
              DECODE(LOB,             'YES', 'LOB   ') ||
              DECODE(STATTYPE_LOCKED, 'ALL', 'STATISTICS LOCKED   ') ||
              DECODE(RECREATED,       'YES', 'STATISTICS OLDER THAN SEGMENT   ') ||
              DECODE(AVG_ROW_LEN,     0,     'ROW LENGTH = 0   ') ||
              DECODE(SIGN(SEG_GROSS_MB - 5),    -1, 'SMALL TABLE   ') ||
              DECODE(CLUSTER_TABLE,   'YES', 'CLUSTER TABLE   ')
              RESTRICTIONS,
            TABLE_NAME,
            BYTES,
            PARTITION_POSITION,
            INDEX_NAME
          FROM
          ( SELECT
              TS.TABLE_OWNER,
              TS.TABLE_NAME SEGMENT_NAME,
              NVL(TS.PARTITION_NAME, ' ') PARTITION_NAME,
              DECODE(CLUSTER_TABLE, 'YES', DTS.BLOCKS * (8000 - 23 * TS.INI_TRANS) * 
                (1 - TS.PCT_FREE / 100) / 1024 / 1024 * 1.1, S.BYTES / 1024 / 1024) SEG_GROSS_MB,
              DECODE(CLUSTER_TABLE, 'YES', DTS.BLOCKS * (8000 - 23 * TS.INI_TRANS) * 
                (1 - TS.PCT_FREE / 100) / 1024 / 1024, (S.BYTES / 1024 / 1024) * (8000 - 23 * 
                TS.INI_TRANS) * (1 - TS.PCT_FREE / 100) / 8192) SEG_NET_MB,
              DTS.BLOCKS * (8000 - 23 * TS.INI_TRANS) * (1 - TS.PCT_FREE / 100) / 1024 / 1024 DATA_GROSS_MB,
              (DTS.AVG_ROW_LEN + 2) * DTS.NUM_ROWS / 1024 / 1024 DATA_NET_MB,
              DTS.NUM_ROWS,
              DTS.AVG_ROW_LEN,
              DTS.BLOCKS,
              DTS.USER_STATS,
              DTC.LONG_RAW,
              DTC.LOB,
              DECODE(SIGN(NVL(DTS.LAST_ANALYZED, SYSDATE) - S.CREATED), -1, 'YES', 'NO') RECREATED,
              DTS.STATTYPE_LOCKED,
              DTS.AVG_ROW_LEN * (TM.INSERTS - TM.DELETES) / 1024 / 1024 CHANGE_MB,
              TS.TABLE_NAME,
              S.BYTES,
              TS.CLUSTER_TABLE,
              TS.PARTITION_POSITION,
              ' ' INDEX_NAME
            FROM 
              TABLE_STORAGE TS,
              TABLE_MODIFICATIONS TM,
              DBA_TAB_STATISTICS DTS,
              TABLE_COLUMNS DTC,
              SEGMENTS S,
              BASIS_INFO BI
            WHERE
              TS.TABLE_OWNER = DTS.OWNER AND
              TS.TABLE_NAME = DTS.TABLE_NAME AND
              NVL(TS.PARTITION_NAME, ' ') = NVL(DTS.PARTITION_NAME, ' ') AND
              DTS.OWNER = S.OWNER (+) AND
              DTS.TABLE_NAME = S.SEGMENT_NAME (+) AND 
              NVL(DTS.PARTITION_NAME, ' ') = NVL(S.PARTITION_NAME (+), ' ') AND
              DTS.OWNER = TM.TABLE_OWNER AND
              DTS.TABLE_NAME = TM.TABLE_NAME AND
              NVL(DTS.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME, ' ') AND
              DTS.OWNER = DTC.TABLE_OWNER AND
              DTS.TABLE_NAME = DTC.TABLE_NAME AND
              DTS.NUM_ROWS IS NOT NULL AND
              (TS.IOT_TYPE != 'IOT' OR TS.IOT_TYPE IS NULL) AND
              BI.SEGMENT_INFO = 'X'
          )
          UNION ALL
          ( SELECT
              SEGMENT_NAME,
              PARTITION_NAME,
              SEG_GROSS_MB,
              SEG_NET_MB,
              DATA_GROSS_MB + GREATEST(0, CHANGE_MB) DATA_GROSS_MB,
              GREATEST(0, DATA_NET_MB + CHANGE_MB) DATA_NET_MB,
              LEAST(SEG_GROSS_MB, GREATEST(DATA_GROSS_MB + GREATEST(0, CHANGE_MB), SEG_NET_MB)) - 
                DATA_NET_MB - CHANGE_MB UNUSED_MB,
              DECODE(  USER_STATS,             'YES',    'STATISTICS MODIFIED   ') ||
                DECODE(STATTYPE_LOCKED,        'ALL',    'STATISTICS LOCKED   ') ||
                DECODE(SIGN(SEG_GROSS_MB - 5), -1,       'SMALL INDEX   ') ||
                DECODE(SIGN(COL_LEN_NULL),     1,        'MISSING COLUMN STATISTICS   ') ||
                DECODE(RECREATED,              'YES',    'STATISTICS OLDER THAN SEGMENT   ') ||
                DECODE(INDEX_TYPE,             'BITMAP', 'BITMAP INDEX   ') ||
                DECODE(IND_ROW_LEN,            0,        'ROW LENGTH = 0   ') ||
                DECODE(LEAF_BLOCKS,            0,        'WRONG VALUE LEAF_BLOCKS = 0   ') ||
                DECODE(COMPRESSION,            'YES',    'COMPRESSED INDEX   ') RESTRICTIONS,
              TABLE_NAME,
              BYTES,
              PARTITION_POSITION,
              INDEX_NAME
            FROM
            ( SELECT 
                DIS.OWNER,
                DIS.INDEX_NAME SEGMENT_NAME,
                NVL(DIS.PARTITION_NAME, ' ') PARTITION_NAME,
                S.BYTES / 1024 / 1024 SEG_GROSS_MB,
                (S.BYTES / 1024 / 1024) * (8079 - 23 * IST.INI_TRANS) * (1 - IST.PCT_FREE / 100) / 8192 SEG_NET_MB,
                DIS.LEAF_BLOCKS * (8079 - 23 * IST.INI_TRANS) * (1 - IST.PCT_FREE / 100) / 1024 / 1024 * 1.05 DATA_GROSS_MB,
                DECODE (SUBSTR(IST.INDEX_TYPE, 1, 6),
                  'NORMAL', (IR.IND_ROW_LEN * DIS.NUM_ROWS - DECODE(IST.COMPRESSION, 'NO', 0, IR.COMP_ROW_LEN * 
                    GREATEST(0, NUM_ROWS - DECODE(IST.PREFIX_LENGTH, 1, FIRST_NUM_DIST, DISTINCT_KEYS)))) / 1024 / 1024,
                  'BITMAP', (NUM_ROWS * (DECODE(DISTINCT_KEYS, 1, 0.18, 1) + DECODE(DISTINCT_KEYS, 
                    0, 0, LOG(35, DISTINCT_KEYS))) + DISTINCT_KEYS * 50) / 1024 / 1024
                  ) * 1.05 DATA_NET_MB,
                DIS.NUM_ROWS,
                DIS.LEAF_BLOCKS LEAF_BLOCKS,
                DIS.USER_STATS,
                DIS.STATTYPE_LOCKED,
                DECODE(SIGN(NVL(DIS.LAST_ANALYZED, SYSDATE) - S.CREATED), -1, 'YES', 'NO') RECREATED,
                IR.COL_LEN_NULL,
                IR.IND_ROW_LEN,
                IR.IND_ROW_LEN * (TM.INSERTS - TM.DELETES) / 1024 / 1024 CHANGE_MB,
                DIS.TABLE_NAME,
                S.BYTES,
                IST.PARTITION_POSITION,
                DIS.INDEX_NAME,
                IST.INDEX_TYPE,
                IST.COMPRESSION
              FROM 
                INDEX_STORAGE IST,
                TABLE_MODIFICATIONS TM,
                INDEX_STATISTICS DIS,
                INDEX_ROWS IR,
                SEGMENTS S,
                BASIS_INFO BI
              WHERE 
                DIS.OWNER = IST.INDEX_OWNER AND
                DIS.INDEX_NAME = IST.INDEX_NAME AND
                NVL(DIS.PARTITION_NAME, ' ') = NVL(IST.PARTITION_NAME, ' ') AND
                DIS.OWNER = S.OWNER (+) AND
                DIS.INDEX_NAME = S.SEGMENT_NAME (+) AND
                NVL(DIS.PARTITION_NAME, ' ') = NVL(S.PARTITION_NAME (+), ' ') AND
                DIS.OWNER = TM.TABLE_OWNER AND
                DIS.TABLE_OWNER = TM.TABLE_OWNER AND
                DIS.TABLE_NAME = TM.TABLE_NAME AND
                NVL(DIS.PARTITION_NAME, ' ') = NVL(TM.PARTITION_NAME, ' ') AND
                IST.INDEX_NAME = IR.INDEX_NAME AND
                IST.INDEX_OWNER = IR.INDEX_OWNER AND
                IST.INDEX_TYPE IN ( 'NORMAL', 'NORMAL/REV', 'BITMAP' ) AND
                BI.SEGMENT_INFO = 'X'
            )
          ) 
        ) 
        ORDER BY
          RPAD(TABLE_NAME, 50) || LPAD(INDEX_NAME, 50) || LPAD(PARTITION_POSITION, 10)
      ) F,
        BASIS_INFO BI
      WHERE
        BI.FRAGMENTATION_INFO = 'X'
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT 'SEGMENT ADVISOR INFORMATION (DBA_ADVISOR_TASKS, DBA_ADVISOR_FINDINGS, DBA_ADVISOR_OBJECTS):' FROM DUAL )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('ANALYSIS_TIME', 20) || RPAD('SEGMENT_NAME', 35) ||
        RPAD('PARTITION_NAME', 30) || RPAD('MESSAGE', 300) LINE
      FROM DUAL
    )
    UNION ALL ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT * FROM
      ( SELECT
          RPAD(TO_CHAR(ANALYSIS_TIME, 'YYYY-MM-DD HH24:MI:SS'), 20) ||
          RPAD(SEGMENT_NAME, 35) ||
          RPAD(NVL(PARTITION_NAME, ' '), 30) ||
          RPAD(MESSAGE, 300)
        FROM
        ( SELECT
            DAT.EXECUTION_START ANALYSIS_TIME,
            DAO.ATTR2 SEGMENT_NAME,
            DAO.ATTR3 PARTITION_NAME,
            DAF.MESSAGE MESSAGE,
            ROW_NUMBER () OVER (PARTITION BY DAO.ATTR2 ORDER BY DAT.EXECUTION_START DESC) ROW_NUM
          FROM
            DBA_ADVISOR_TASKS DAT,
            DBA_ADVISOR_FINDINGS DAF,
            DBA_ADVISOR_OBJECTS DAO
          WHERE
            DAT.OWNER = DAF.OWNER AND
            DAT.TASK_ID = DAF.TASK_ID AND
            DAF.TASK_ID = DAO.TASK_ID AND
            DAF.OBJECT_ID = DAO.OBJECT_ID AND
            DAT.ADVISOR_NAME = 'Segment Advisor' AND
            (DAO.ATTR1, DAO.ATTR2 ) IN
            ( SELECT TABLE_OWNER, TABLE_NAME FROM TABLE_INFO UNION ALL
              SELECT INDEX_OWNER, INDEX_NAME FROM INDEX_INFO )
        )
        WHERE 
          ROW_NUM = 1
        ORDER BY
          ANALYSIS_TIME DESC,
          SEGMENT_NAME
      )
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT LPAD('*', 240, '*') FROM DUAL )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'SEGMENT INFORMATION (DBA_SEGMENTS, DBA_LOBS, DBA_TABLESPACES):' LINE
      FROM DUAL
    )
    UNION ALL
    ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('OWNER', 10) || 
        RPAD('SEGMENT_NAME', 35) || 
        RPAD('PARTITION_NAME', 30) ||
        RPAD('SEGMENT_TYPE', 18) || 
        RPAD('TABLESPACE_NAME', 18) || 
        RPAD('TABLESPACE_TYPE', 25) ||
        RPAD('BUFFER_POOL', 12) || 
        LPAD('SIZE_MB', 15) || 
        LPAD('EXTENTS', 8) ||
        LPAD('INITIAL', 11) || 
        LPAD('NEXT', 9) || 
        LPAD('MIN_EXT', 8) || 
        LPAD('MAX_EXT', 11) ||
        LPAD('FREELISTS', 10) || 
        LPAD('FL_GROUPS', 10) LINE
      FROM DUAL
    )
    UNION ALL ( SELECT  ' ' FROM DUAL )
    UNION ALL
    ( SELECT LINE
      FROM
      ( SELECT LINE
        FROM
        ( SELECT DISTINCT
            RPAD(S.OWNER, 10) ||
            RPAD(DECODE(SUBSTR(S.SEGMENT_TYPE, 1, 3), 'LOB',
              S.LOB_TABLE_NAME || '.' || S.LOB_COLUMN_NAME, S.SEGMENT_NAME), 35) ||
            RPAD(NVL(S.PARTITION_NAME, ' '), 30) ||
            RPAD(S.SEGMENT_TYPE, 18) ||
            RPAD(NVL(S.TABLESPACE_NAME, '-'), 18) ||
            RPAD(S.TABLESPACE_TYPE, 25) ||
            RPAD(S.BUFFER_POOL, 12) ||
            TO_CHAR(NVL(S.BYTES, 0) / 1024 / 1024, 99999999990.99) ||
            LPAD(NVL(S.EXTENTS, 0), 8) ||
            LPAD(NVL(S.INITIAL_EXTENT, 0), 11) ||
            LPAD(NVL(S.NEXT_EXTENT, 0), 9) ||
            LPAD(NVL(S.MIN_EXTENTS, 0), 8) ||
            LPAD(NVL(S.MAX_EXTENTS, 0), 11) ||
            LPAD(NVL(S.FREELISTS, 0), 10) ||
            LPAD(NVL(S.FREELIST_GROUPS, 0), 10) LINE,
            S.OWNER OWNER,
            DECODE(SUBSTR(S.SEGMENT_TYPE, 1, 3), 'LOB', S.LOB_TABLE_NAME,
              S.SEGMENT_NAME) SEGMENT_NAME,
            S.PARTITION_NAME PARTITION_NAME,
            S.SEGMENT_TYPE SEGMENT_TYPE
          FROM
            SEGMENTS S
          ) 
        ORDER BY
          OWNER,
          SEGMENT_NAME,
          PARTITION_NAME,
          SEGMENT_TYPE DESC
      )
    )
    UNION ALL ( SELECT  ' ' FROM DUAL )
UNION ALL 
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL 
( SELECT  ' ' FROM DUAL )
UNION ALL 
( SELECT 'LOB INFORMATION (DBA_LOBS):' FROM DUAL )
UNION ALL 
( SELECT  ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('OWNER', 10) || 
    RPAD('TABLE_NAME', 32) || 
    RPAD('COLUMN_NAME', 32) ||
    RPAD('LOB_NAME', 32) || 
    LPAD('PCTVERSION', 11) || 
    LPAD('RETENTION', 10) ||
    LPAD('CACHE', 11) ||
    LPAD('IN_ROW', 7) ||
    RPAD(' LOGGING', 9) ||
    RPAD('SECUREFILE', 11) ||
    RPAD('COMPRESSION', 12) ||
    RPAD('DEDUPLICATION', 14) LINE
  FROM DUAL
)
UNION ALL 
( SELECT  ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD(DL.OWNER, 10) ||
    RPAD(DL.TABLE_NAME, 32) ||
    RPAD(DL.COLUMN_NAME, 32) ||
    RPAD(DL.SEGMENT_NAME, 32) ||
    LPAD(NVL(TO_CHAR(DL.PCTVERSION), ' '), 11) ||
    LPAD(NVL(TO_CHAR(DL.RETENTION), ' '), 10) ||
    LPAD(DL.CACHE, 11) ||
    LPAD(DL.IN_ROW, 7) ||
    RPAD(' ' || LOGGING, 9) ||
    RPAD(DL.SECUREFILE, 11) ||
    RPAD(DL.COMPRESSION, 12) ||
    RPAD(DL.DEDUPLICATION, 14) LINE
  FROM
    TABLE_INFO TI,
    DBA_LOBS DL
  WHERE
    TI.TABLE_OWNER = DL.OWNER AND
    TI.TABLE_NAME = DL.TABLE_NAME
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL 
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL 
( SELECT  ' ' FROM DUAL )
UNION ALL 
( SELECT 'PARTITION INFORMATION (DBA_PART_KEY_COLUMNS):' FROM DUAL )
UNION ALL 
( SELECT  ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('OWNER', 10) || 
    RPAD('SEGMENT_NAME', 32) || 
    RPAD('SEGMENT_TYPE', 13) ||
    RPAD('COLUMN_NAME', 20) || 
    LPAD('COLUMN_POSITION', 15) ||
    LPAD('PARTITIONING_TYPE', 18) LINE
  FROM DUAL
)
UNION ALL ( SELECT  ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      RPAD(OWNER, 10) ||
      RPAD(SEGMENT_NAME, 32) ||
      RPAD(SEGMENT_TYPE, 13) ||
      RPAD(COLUMN_NAME, 20) ||
      LPAD(COLUMN_POSITION, 15) ||
      LPAD(PARTITIONING_TYPE, 18) LINE
    FROM
    ( SELECT /*+ LEADING(TI) */
        PKC.OWNER,
        PKC.NAME SEGMENT_NAME,
        PKC.OBJECT_TYPE SEGMENT_TYPE,
        PKC.COLUMN_NAME,
        PKC.COLUMN_POSITION,
        PT.PARTITIONING_TYPE
      FROM
        TABLE_INFO TI,
        DBA_PART_KEY_COLUMNS PKC,
        DBA_PART_TABLES PT
      WHERE
        TI.TABLE_OWNER = PKC.OWNER AND
        TI.TABLE_NAME = PKC.NAME AND
        PKC.OBJECT_TYPE = 'TABLE' AND
        PT.OWNER = PKC.OWNER AND
        PT.TABLE_NAME = PKC.NAME
      UNION ALL
      ( SELECT /*+ LEADING(TI) */
          PKC.OWNER, 
          PKC.NAME SEGMENT_NAME,
          PKC.OBJECT_TYPE SEGMENT_TYPE,
          PKC.COLUMN_NAME,
          PKC.COLUMN_POSITION,
          PI.PARTITIONING_TYPE
        FROM
          INDEX_INFO II,
          DBA_PART_KEY_COLUMNS PKC,
          DBA_PART_INDEXES PI
        WHERE
          II.INDEX_OWNER = PKC.OWNER AND
          II.INDEX_NAME = PKC.NAME AND
          PKC.OBJECT_TYPE = 'INDEX' AND
          PI.OWNER = PKC.OWNER AND
          PI.INDEX_NAME = PKC.NAME
      )
    )
    ORDER BY
      OWNER,
      SEGMENT_NAME,
      COLUMN_POSITION
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT LPAD('*', 240, '*') FROM DUAL )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        'BUFFER POOL OCCUPATION (V$BH):' LINE
      FROM
        DUAL
    )
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD('SEGMENT_NAME', 35) ||
        RPAD('PARTITION_NAME', 30) ||
        RPAD('SEGMENT_TYPE', 16) ||
        RPAD('POOL', 8) ||
        LPAD('BLKSIZE', 8) ||
        LPAD('POOL_GB', 8) ||
        LPAD('SEG_POOL_MB', 12) ||
        LPAD('POOL_%', 7) ||
        LPAD('SEG_DISK_MB', 12) ||
        LPAD('SEG_CACHED_%', 13) ||
        LPAD('DIRTY_%', 8) LINE
      FROM
        DUAL
    ) 
    UNION ALL
    ( SELECT ' ' FROM DUAL )
    UNION ALL
    ( SELECT
        RPAD(SEGMENT_NAME, 35) ||
        RPAD(PARTITION_NAME, 30) ||
        RPAD(SEGMENT_TYPE, 16) ||
        RPAD(POOL, 8) ||
        LPAD(BLKSIZE, 8) ||
        LPAD(POOL_GB, 8) ||
        LPAD(SEG_POOL_MB, 12) ||
        LPAD("POOL_%", 7) ||
        LPAD(SEG_DISK_MB, 12) ||
        LPAD("SEG_CACHED_%", 13) ||
        LPAD("DIRTY_%", 8) LINE
      FROM
      ( SELECT 
          OWNER,
          SEGMENT_NAME,
          NVL(PARTITION_NAME, ' ') PARTITION_NAME,
          SEGMENT_TYPE,
          BUFFER_POOL POOL,
          BLOCK_SIZE BLKSIZE,
          TO_CHAR(POOL_SIZE_MB / 1024, 990.99) POOL_GB,
          TO_CHAR(BLOCKS * BLOCK_SIZE / 1024 / 1024, 9999990.99) SEG_POOL_MB,
          TO_CHAR(DECODE(POOL_SIZE_MB, 0, 0, BLOCKS * BLOCK_SIZE / 1024 / 1024 / 
            POOL_SIZE_MB * 100), 990.99) "POOL_%",
          TO_CHAR(SEG_DISK_BYTE / 1024 / 1024, 9999990.99) SEG_DISK_MB,
          TO_CHAR(DECODE(SEG_DISK_BYTE, 0, 0, BLOCKS * BLOCK_SIZE / 
            SEG_DISK_BYTE * 100), 99999990.99) "SEG_CACHED_%",
          TO_CHAR(DECODE(BLOCKS, 0, 0, DIRTY_BLOCKS / BLOCKS * 100), 
            990.99) "DIRTY_%"
        FROM 
        ( SELECT 
            S.OWNER,
            S.SEGMENT_NAME,
            S.PARTITION_NAME,
            S.SEGMENT_TYPE,
            S.BYTES SEG_DISK_BYTE,
            COUNT(*) BLOCKS,
            SUM(DECODE(B.DIRTY, 'Y', 1, 0)) DIRTY_BLOCKS,
            C.POOL_SIZE_MB,
            C.BUFFER_POOL,
            C.BLOCK_SIZE,
            ROW_NUMBER() OVER (PARTITION BY O.DATA_OBJECT_ID 
              ORDER BY O.OBJECT_TYPE) CLUSTRN
          FROM 
            SEGMENTS S,
            OBJECTS O, 
            V$BH B,
            CACHES C
          WHERE 
            S.OWNER = O.OWNER AND
            S.SEGMENT_NAME = O.OBJECT_NAME AND
            NVL(S.PARTITION_NAME, ' ') = NVL(O.SUBOBJECT_NAME, ' ') AND
            O.DATA_OBJECT_ID = B.OBJD (+) AND
            C.BUFFER_POOL = S.BUFFER_POOL AND
            C.BLOCK_SIZE = S.BLOCK_SIZE AND
            C.POOL_SIZE_MB > 0
          GROUP BY
            S.OWNER,
            S.SEGMENT_NAME,
            S.PARTITION_NAME, 
            S.SEGMENT_TYPE,
            S.BYTES,
            C.POOL_SIZE_MB,
            C.BUFFER_POOL,
            C.BLOCK_SIZE,
            O.DATA_OBJECT_ID,
            O.OBJECT_TYPE
        )
        WHERE
          CLUSTRN = 1 
        ORDER BY 
          SEG_POOL_MB DESC
      )
      WHERE
        ROWNUM <= 20
    )
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'UNDO STATISTICS (V$UNDOSTAT):' LINE
  FROM
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('BEGIN_TIME', 19) ||
    LPAD('MAXQUERYLEN', 12) ||
    LPAD('TUNED_UNDORETENTION', 20)
  FROM
    DUAL
) 
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      RPAD(TO_CHAR(BEGIN_TIME, 'YYYY-MM-DD HH24:MI:SS'), 19) ||
      LPAD(MAXQUERYLEN, 12) ||
      LPAD(TUNED_UNDORETENTION, 20)
    FROM
      BASIS_INFO BI,
      V$UNDOSTAT UST
    WHERE
      UST.MAXQUERYID = '&&sql_id'
    ORDER BY
      BEGIN_TIME DESC
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    'PARAMETER SETTINGS (V$PARAMETER2):' LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    RPAD('PARAMETER_NAME', 40) ||
    RPAD('IS_DEFAULT', 11) ||
    RPAD(' VALUE', 189) LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT * FROM
  ( SELECT RPAD(NAME, 40) || RPAD(ISDEFAULT, 11) || RPAD(' ' || VALUE, 189) LINE
    FROM V$PARAMETER2
    WHERE
      NAME LIKE '\_%' ESCAPE '\' OR UPPER(NAME) LIKE 'OPTIMIZER%' OR
      UPPER(NAME) IN ('EVENT', 'DB_FILE_MULTIBLOCK_READ_COUNT',
        'PGA_AGGREGATE_TARGET', 'WORKAREA_SIZE_POLICY', 'DB_CACHE_SIZE',
        'SGA_TARGET', 'MEMORY_TARGET', 'MEMORY_MAX_TARGET', 'STAR_TRANSFORMATION_ENABLED')
    ORDER BY 
      UPPER(NAME), 
      VALUE
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 'PARAMETER CHANGES (DBA_HIST_PARAMETER):' LINE FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('BEGIN_TIME', 19) || 
    RPAD(' PARAMETER_NAME', 41) ||
    RPAD('VALUE', 60) || 
    RPAD('IS_DEFAULT', 11) ||
    RPAD('VALUE_BEFORE', 60) || 
    RPAD('WAS_DEFAULT', 12) LINE
  FROM DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD(BEGIN_TIME, 19) || 
    RPAD(' ' || PARAMETER_NAME, 41) || 
    RPAD(NVL(VALUE, ' '), 60) ||
    RPAD(IS_DEFAULT, 11) || 
    RPAD(NVL(VALUE_BEFORE, ' '), 60) || 
    RPAD(WAS_DEFAULT, 12) LINE
  FROM
  ( SELECT
      DECODE(R.ID, 1, TO_CHAR(BEGIN_INTERVAL_TIME,
        'YYYY-MM-DD HH24:MI:SS'), ' ') BEGIN_TIME,
      DECODE(R.ID, 1, PARAMETER_NAME, ' ') PARAMETER_NAME,
      SUBSTR(VALUE, 1 + 59 * (R.ID - 1), 59) VALUE,
      DECODE(R.ID, 1, IS_DEFAULT, ' ') IS_DEFAULT,
      SUBSTR(VALUE_BEFORE, 1 + 59 * (R.ID - 1), 59) VALUE_BEFORE,
      DECODE(R.ID, 1, WAS_DEFAULT, ' ') WAS_DEFAULT
    FROM
    ( SELECT ROWNUM ID FROM V$SESSTAT WHERE ROWNUM <= 20 ) R,
    ( SELECT 
        HSS.BEGIN_INTERVAL_TIME, 
        HP2.PARAMETER_NAME PARAMETER_NAME, 
        HP2.VALUE VALUE,
        NVL(HP2.ISDEFAULT, 'UNKNOWN') IS_DEFAULT, 
        HP1.VALUE VALUE_BEFORE, 
        NVL(HP1.ISDEFAULT, 'UNKNOWN') WAS_DEFAULT
      FROM
        V$INSTANCE I,
        DBA_HIST_PARAMETER HP1, 
        DBA_HIST_PARAMETER HP2, 
        DBA_HIST_SNAPSHOT HSS
      WHERE
        I.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
        I.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
        I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
        HP2.SNAP_ID = HSS.SNAP_ID AND 
        HP1.SNAP_ID = HP2.SNAP_ID - 1 AND
        HP1.PARAMETER_NAME = HP2.PARAMETER_NAME AND 
        ( HP2.VALUE != HP1.VALUE OR HP2.ISDEFAULT != HP1.ISDEFAULT )
      UNION 
      ( SELECT 
          HSS.BEGIN_INTERVAL_TIME, 
          HP2.PARAMETER_NAME, HP2.VALUE,
          NVL(HP2.ISDEFAULT, 'UNKNOWN') IS_DEFAULT, 
          NULL VALUE_BEFORE, 
          'TRUE' WAS_DEFAULT
        FROM 
          V$INSTANCE I,
          DBA_HIST_PARAMETER HP2, 
          DBA_HIST_SNAPSHOT HSS
        WHERE
          I.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
          I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
          HP2.SNAP_ID = HSS.SNAP_ID AND
          EXISTS
          ( SELECT 
              * 
            FROM 
              DBA_HIST_PARAMETER HP1
            WHERE 
              I.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
              HP1.SNAP_ID = HP2.SNAP_ID - 1 AND 
              HP1.PARAMETER_NAME = 'sessions'
          ) AND
          NOT EXISTS
          ( SELECT 
              * 
            FROM 
              DBA_HIST_PARAMETER HP1 
            WHERE 
              I.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
              HP1.SNAP_ID = HP2.SNAP_ID - 1 AND 
              HP1.PARAMETER_NAME = HP2.PARAMETER_NAME
          )
      )
      UNION 
      ( SELECT 
          HSS.BEGIN_INTERVAL_TIME, 
          HP1.PARAMETER_NAME, 
          NULL VALUE,
          'TRUE' IS_DEFAULT, 
          HP1.VALUE VALUE_BEFORE, 
          NVL(HP1.ISDEFAULT, 'UNKNOWN') WAS_DEFAULT
        FROM 
          V$INSTANCE I,
          DBA_HIST_PARAMETER HP1, 
          DBA_HIST_SNAPSHOT HSS
        WHERE
          I.INSTANCE_NUMBER = HP1.INSTANCE_NUMBER AND
          I.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
          HP1.SNAP_ID = HSS.SNAP_ID AND
          EXISTS
          ( SELECT 
              *
            FROM 
              DBA_HIST_PARAMETER HP2 
            WHERE 
              I.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
              HP1.SNAP_ID = HP2.SNAP_ID - 1 AND 
              HP2.PARAMETER_NAME = 'sessions'
          ) AND
          NOT EXISTS
          ( SELECT
              *
            FROM 
              DBA_HIST_PARAMETER HP2
            WHERE 
              I.INSTANCE_NUMBER = HP2.INSTANCE_NUMBER AND
              HP1.SNAP_ID = HP2.SNAP_ID - 1 AND 
              HP1.PARAMETER_NAME = HP2.PARAMETER_NAME
          )
      )
    ) P
    WHERE 
      R.ID <= TRUNC(LENGTH(P.VALUE) - 1) / 59 + 1 OR 
      R.ID <= TRUNC(LENGTH(P.VALUE_BEFORE) - 1) / 59 + 1 OR 
      R.ID <= 1
    ORDER BY 
      P.BEGIN_INTERVAL_TIME DESC, 
      P.PARAMETER_NAME, 
      R.ID
  )
)
UNION ALL ( SELECT ' ' FROM DUAL )
UNION ALL 
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL 
( SELECT ' ' FROM DUAL )
UNION ALL 
( SELECT 
    'BIND VALUES (V$SQL_BIND_CAPTURE, DBA_HIST_SQLBIND):' 
  FROM
    DUAL 
)
UNION ALL 
( SELECT ' ' FROM DUAL )
UNION ALL 
( SELECT
    'SAMPLES: ' || COUNT(DISTINCT(CAPTURE_TIME)) LINE
  FROM
    BIND_CONTENTS
)
UNION ALL 
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 
    LPAD('CAPTURE_TIME', 19) || 
    LPAD('NAME', 10) || 
    RPAD(' VALUE', 80) 
  FROM 
    DUAL 
)
UNION ALL 
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 
    * 
  FROM
  ( SELECT
      RPAD(CAPTURE_TIME, 19) || 
      LPAD(NAME, 10) || 
      RPAD(' ' || VALUE_STRING, 80)
    FROM
    ( SELECT 
        DECODE(ROWNUM, 1, 'CONSTANT', ' ') CAPTURE_TIME,
        NAME,
        VALUE_STRING
      FROM
      ( SELECT 
          NAME, 
          '''' || EXAMPLE_VALUE || '''' VALUE_STRING
        FROM 
          DISTINCT_LITERALS
        WHERE 
          NUM_DISTINCT = 1
        ORDER BY 
          POSITION
      )
      UNION ALL ( SELECT NULL, NULL, NULL FROM DUAL )
      UNION ALL
      ( SELECT 
          * 
        FROM
        ( SELECT
            DECODE(CAPTURE_TIME, LAG(CAPTURE_TIME, 1) OVER
              (ORDER BY CAPTURE_TIME DESC, BC.POSITION), 
              ' ', TO_CHAR(CAPTURE_TIME, 'YYYY-MM-DD HH24:MI:SS')) CAPTURE_TIME,
            BC.NAME NAME, 
            '''' || VALUE_STRING || '''' VALUE_STRING
          FROM 
            BIND_CONTENTS BC, 
            DISTINCT_LITERALS DL
          WHERE 
            BC.NAME = DL.NAME AND 
            DL.NUM_DISTINCT > 1
          ORDER BY 
            BC.CAPTURE_TIME DESC, 
            BC.POSITION
        )
      )
    )
  )
)
UNION ALL ( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT LPAD('*', 240, '*') FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 'SQL MONITORING (V$SQL_MONITOR, V$SQL_PLAN_MONITOR):' FROM DUAL )
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('SID', 6) ||
    RPAD(' SQL_EXEC_ID', 13) ||
    RPAD('STATUS', 16) ||
    RPAD('SQL_EXEC_START', 19) ||
    LPAD('ELAPSED_S', 10) ||
    LPAD('CPU_S', 8) ||
    LPAD('BUFFER_GETS', 12) ||
    LPAD('DISK_READS', 11) ||
    LPAD('PX_REQ', 7) ||
    LPAD('PX_ALLOC', 9) ||
    RPAD(' ERR_MSG', 20) LINE
  FROM
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT 
    LINE
  FROM
  ( SELECT
      LPAD(SM.SID, 6) ||
      RPAD(' ' || SM.SQL_EXEC_ID, 13) ||
      RPAD(SM.STATUS, 16) ||
      RPAD(TO_CHAR(SM.SQL_EXEC_START, 'dd.mm.yyyy hh24:mi:ss'), 19) ||
      LPAD(ROUND(SM.ELAPSED_TIME / 1000000), 10) ||
      LPAD(ROUND(SM.CPU_TIME / 1000000), 8) ||
      LPAD(SM.BUFFER_GETS, 12) ||
      LPAD(SM.DISK_READS, 11) ||
      LPAD(NVL(TO_CHAR(SM.PX_SERVERS_REQUESTED), ' '), 7) ||
      LPAD(NVL(TO_CHAR(SM.PX_SERVERS_ALLOCATED), ' '), 9) ||
      RPAD(' ' || SUBSTR(SM.ERROR_MESSAGE, 1, INSTR(SM.ERROR_MESSAGE, ':') - 1), 20) LINE
    FROM
      BASIS_INFO BI,
      V$SQL_MONITOR SM
    WHERE
      SM.SQL_ID = '&&sql_id'
    ORDER BY
      SM.SQL_EXEC_START DESC
  )
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('SID', 6) ||
    RPAD(' SQL_EXEC_ID', 13) ||
    RPAD('PLAN_ID', 8) ||
    LPAD('STARTS', 10) ||
    LPAD('OUTPUT_ROWS', 12) ||
    LPAD('IO_READ_MB', 11) ||
    LPAD('WA_TEMP_MB', 11) ||
    ' ACTION_INFO' LINE
  FROM
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE 
  FROM
  ( SELECT
      LPAD(DECODE(SPM.PLAN_LINE_ID, 0, TO_CHAR(SPM.SID), ' '), 6) ||
      RPAD(' ' || DECODE(SPM.PLAN_LINE_ID, 0, TO_CHAR(SPM.SQL_EXEC_ID), ' '), 13) ||
      RPAD(TO_CHAR(SPM.PLAN_LINE_ID), 8) || 
      LPAD(TO_CHAR(SPM.STARTS), 10) ||
      LPAD(TO_CHAR(SPM.OUTPUT_ROWS), 12) || 
      LPAD(TO_CHAR(SPM.PHYSICAL_READ_BYTES / 1024 / 1024, 999999990), 11) ||
      LPAD(NVL(TO_CHAR(SPM.WORKAREA_MAX_TEMPSEG / 1024 / 1024, 99999990), ' '), 11) ||
      LPAD(' ', SPM.PLAN_DEPTH + 1, ' ') || 
        SPM.PLAN_OPERATION || 
        DECODE(SPM.PLAN_OPTIONS, NULL, NULL, ' ' || SPM.PLAN_OPTIONS || 
        DECODE(SPM.PLAN_OBJECT_NAME, NULL, NULL, ' (' || SPM.PLAN_OBJECT_NAME || ')')) LINE
    FROM
      BASIS_INFO BI,
      V$SQL_PLAN_MONITOR SPM
    WHERE
      SPM.SQL_ID = '&&sql_id' 
    ORDER BY
      SPM.SQL_EXEC_START DESC,
      SPM.SID,
      SPM.SQL_ID,
      SPM.SQL_EXEC_ID,
      SPM.PLAN_LINE_ID
  )
)
/* Disabling because of parse loop
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LPAD('SID', 6) ||
    RPAD(' SQL_EXEC_ID', 13) ||    
    RPAD('SQL_EXEC_START', 20) ||
    RPAD('NAME', 10) ||
    'VALUE_STRING' LINE
  FROM
    DUAL
)
UNION ALL
( SELECT ' ' FROM DUAL )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      LPAD(DECODE(BV.POS, 1, TO_CHAR(SMX.SID), ' '), 6) ||
      RPAD(' ' || DECODE(BV.POS, 1, TO_CHAR(SMX.SQL_EXEC_ID), ' '), 13) ||
      RPAD(DECODE(BV.POS, 1, TO_CHAR(SMX.SQL_EXEC_START, 'dd.mm.yyyy hh24:mi:ss'), ' '), 20) ||
      RPAD(BV.NAME, 10) ||
      '''' || BV.VALUE || '''' LINE
    FROM
      V$SQL_MONITOR SMX,
      XMLTABLE
      ( '/binds/bind'
        PASSING XMLTYPE(SMX.BINDS_XML)
        COLUMNS NAME VARCHAR2(30) PATH '@name',
                VALUE VARCHAR2(4000) PATH '.',
                TYPE VARCHAR2(15) PATH '@dtystr',
                POS NUMBER PATH '@pos'
      ) BV
    WHERE
      SMX.BINDS_XML IS NOT NULL AND
      SMX.SQL_ID = '&&sql_id'
    ORDER BY
      SMX.SQL_EXEC_START DESC,
      SMX.SID,
      SMX.SQL_EXEC_ID,
      BV.POS
  )
)
*/
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d20dd35-014d-1000-8046-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_ExecutionPlan]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL ID, NULL P1, NULL P2, NULL P3 FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL ID, NULL P1, NULL P2, NULL P3 FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SQL_ID,
    PLAN_HASH,
    SQL_PLAN_SOURCE,
    COLUMN_LINE_LEN,
    PREDICATE_LINE_LEN,
    INCLUDE_PREDICATES
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      :SQL_ID SQL_ID,
      -1 PLAN_HASH,
      'ALL' SQL_PLAN_SOURCE,    /* CURRENT -> GV$ views, HISTORY -> DBA view, ALL -> both */
      200 COLUMN_LINE_LEN,
      60 PREDICATE_LINE_LEN,
      'X' INCLUDE_PREDICATES
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SQL_PLANS AS
( SELECT 
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    SQL_ID,
    DEPTH,
    OPTIMIZER,
    INST_ID,
    OPERATION || DECODE(OPTIONS, NULL, NULL, ' ' || OPTIONS ) ||
      DECODE(OBJECT_NAME, NULL, NULL, ' (' || OBJECT_NAME || ')') ACTION_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', 
      DECODE(SOURCE, 'HISTORY', 
        DECODE(SEARCH_COLUMNS, NULL, NULL, 0, NULL, 'Search columns: ' || SEARCH_COLUMNS), 
        NULL),
      DECODE(SEARCH_COLUMNS, NULL, NULL, 0, NULL, 'Search columns: ' || SEARCH_COLUMNS)) SEARCH_COLUMNS_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', DECODE(ACCESS_PREDICATES, NULL, NULL, 
      SUBSTR(ACCESS_PREDICATES, 1, 3000)), NULL) ACCESS_PREDICATE_INFO,
    DECODE(INCLUDE_PREDICATES, 'X', DECODE(FILTER_PREDICATES, NULL, NULL, 
      SUBSTR(FILTER_PREDICATES, 1, 3000)), NULL) FILTER_PREDICATE_INFO,
    DECODE(MEMORY_USED, NULL, NULL, 'PGA space: ' || ROUND(MEMORY_USED / 1024) || ' KB' || 
      DECODE(TEMP_SPACE, NULL, NULL, ', Temp space: ' || ROUND(TEMP_SPACE / 1024) || ' KB')) SPACE_INFO,
    DECODE(PARTITION_START, NULL, NULL, 'Partitions: ' || PARTITION_START || ' - ' || PARTITION_STOP ||
      ', Partition ID: ' || PARTITION_ID) PARTITION_INFO,
    DECODE(PX_DEGREE, NULL, NULL, 1, NULL, 'PX degree: ' || PX_DEGREE) PX_INFO,
    DECODE(COST, NULL, NULL, 'Total costs: ' || TO_CHAR(COST) ) || 
      DECODE(IO_COST, NULL, NULL, ', I/O costs: ' || TO_CHAR(IO_COST) ) || 
      DECODE(IO_COST, NULL, NULL, DECODE(IO_COST, NULL, NULL, ', CPU costs: ' || TO_CHAR(COST - IO_COST) ) ) || 
      DECODE(CARDINALITY, NULL, NULL, DECODE(IO_COST || COST, NULL, NULL, ', ') || 
      'E-Rows: ' || TO_CHAR(CARDINALITY) ) COST_INFO,
    DECODE(LAST_STARTS, NULL , NULL, 'Starts: ' || LAST_STARTS || ', A-Rows: ' || LAST_OUTPUT_ROWS || ', Gets: ' || LAST_BUFFER_GETS ||
      ', Reads: ' || LAST_DISK_READS || ', Time: ' || LAST_ELAPSED_TIME || ' us') PLAN_STATISTICS_INFO
  FROM 
  ( ( SELECT
        SP.PLAN_HASH_VALUE,
        TO_CHAR(SP.CHILD_NUMBER) CHILD_NUMBER,
        SP.ID,
        SP.SEARCH_COLUMNS,
        SP."DEPTH",
        SP.OPERATION,
        SP.OPTIONS,
        SP.OBJECT_NAME,
        SP.ACCESS_PREDICATES,
        SP.FILTER_PREDICATES,
        SP.TEMP_SPACE,
        SPA.LAST_MEMORY_USED MEMORY_USED,
        SPA.LAST_DEGREE PX_DEGREE,
        SP.PARTITION_START,
        SP.PARTITION_STOP,
        SP.PARTITION_ID,
        SP.COST,
        SP.IO_COST,
        SP.CARDINALITY,
        SPA.LAST_STARTS,
        SPA.LAST_OUTPUT_ROWS,
        SPA.LAST_CR_BUFFER_GETS + SPA.LAST_CU_BUFFER_GETS LAST_BUFFER_GETS,
        SPA.LAST_DISK_READS,
        SPA.LAST_ELAPSED_TIME,
        SP.OPTIMIZER,
        TO_CHAR(SP.INST_ID) INST_ID,
        BI.SQL_ID,
        BI.INCLUDE_PREDICATES,
        'CURRENT' SOURCE
      FROM
        GV$SQL_PLAN SP, 
        GV$SQL_PLAN_STATISTICS_ALL SPA,
        BASIS_INFO BI
      WHERE
        SP.INST_ID = SPA.INST_ID (+) AND
        SP.SQL_ID = SPA.SQL_ID (+) AND
        SP.CHILD_NUMBER = SPA.CHILD_NUMBER (+) AND
        SP.ID = SPA.ID (+) AND
        SP.SQL_ID = BI.SQL_ID AND
        ( BI.PLAN_HASH = -1 OR SP.PLAN_HASH_VALUE = BI.PLAN_HASH ) AND
        ( BI.INSTANCE_NUMBER = -2 OR SP.INST_ID = BI.INSTANCE_NUMBER ) AND
        BI.SQL_PLAN_SOURCE IN ('ALL', 'CURRENT')
    ) 
    UNION 
    ( SELECT
        PLAN_HASH_VALUE,
        'n/a' CHILD_NUMBER,
        ID,
        SEARCH_COLUMNS,
        DEPTH,
        OPERATION,
        OPTIONS,
        OBJECT_NAME,
        ACCESS_PREDICATES,
        FILTER_PREDICATES,
        TEMP_SPACE,
        NULL MEMORY_USED,
        NULL PX_DEGREE,
        PARTITION_START,
        PARTITION_STOP,
        PARTITION_ID,
        COST,
        IO_COST,
        CARDINALITY,
        NULL LAST_STARTS,
        NULL LAST_OUTPUT_ROWS,
        NULL LAST_BUFFER_GETS,
        NULL LAST_DISK_READS,
        NULL LAST_ELAPSED_TIME,
        OPTIMIZER,
        'n/a' INST_ID,
        BI.SQL_ID,
        BI.INCLUDE_PREDICATES,
        'HISTORY' SOURCE
      FROM
        DBA_HIST_SQL_PLAN HSP,
        BASIS_INFO BI
      WHERE
        HSP.SQL_ID = BI.SQL_ID AND
        ( BI.PLAN_HASH = -1 OR HSP.PLAN_HASH_VALUE = BI.PLAN_HASH ) AND
        ( BI.SQL_PLAN_SOURCE = 'HISTORY' OR
          BI.SQL_PLAN_SOURCE = 'ALL' AND
          NOT EXISTS 
          ( SELECT 
              1 
            FROM 
              GV$SQL_PLAN SP
            WHERE 
              SP.SQL_ID = HSP.SQL_ID AND 
              SP.PLAN_HASH_VALUE = HSP.PLAN_HASH_VALUE AND
              ( BI.INSTANCE_NUMBER = -2 OR SP.INST_ID = BI.INSTANCE_NUMBER )
          )
        )
    )
  )
),
PREDICATE_INFOS AS
( SELECT
    'ACCESS' PREDICATE_TYPE,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    DEPTH, 
    ' Access predicates: ' || ACCESS_PREDICATE_INFO || ' ' PREDICATE_INFO
  FROM
    SQL_PLANS
  WHERE
    ACCESS_PREDICATE_INFO IS NOT NULL
  UNION ALL
  ( SELECT
      'FILTER' PREDICATE_TYPE,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID,
      DEPTH,
      ' Filter predicates: ' || FILTER_PREDICATE_INFO || ' ' PREDICATE_INFO
    FROM
      SQL_PLANS
    WHERE
      FILTER_PREDICATE_INFO IS NOT NULL
  )
  UNION ALL
  ( SELECT
      'DUMMY' PREDICATE_TYPE,
      123 PLAN_HASH_VALUE,
      '345' CHILD_NUMBER,
      567 ID,
      789 DEPTH,
      ' XXX ' PREDICATE_INFO
    FROM
      DUAL
  )
),
PRED_START_POSITIONS AS
( SELECT
    *
  FROM
  ( SELECT 
      PREDICATE_TYPE,
      PREDICATE_INFO,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID, 
      INSTR(PREDICATE_INFO, ' ', 1, ROWN) POS,
      BI.PREDICATE_LINE_LEN
    FROM
      BASIS_INFO BI,
      PREDICATE_INFOS PI,
      ( SELECT ROWNUM ROWN FROM V$SESSTAT, V$SESSTAT WHERE ROWNUM <= 1000 ) RN
  )
  WHERE
    POS != 0
),
PRED_START_END_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    PREDICATE_TYPE,
    PREDICATE_INFO,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    POS1,
    PREDICATE_TYPE || PLAN_HASH_VALUE || CHILD_NUMBER || ID || POS1 CONN_ID1,
    POS2,
    PREDICATE_TYPE || PLAN_HASH_VALUE || CHILD_NUMBER || ID || POS2 CONN_ID2
  FROM
  ( SELECT
      PREDICATE_TYPE,
      PREDICATE_INFO,
      PLAN_HASH_VALUE,
      CHILD_NUMBER,
      ID,
      POS1,
      NVL(POS2, POS_OVERFLOW) POS2
    FROM
    ( SELECT
        SP1.PREDICATE_TYPE,
        SP1.PREDICATE_INFO,
        SP1.PLAN_HASH_VALUE,
        SP1.CHILD_NUMBER,
        SP1.ID,
        SP1.POS POS1,
        MAX(SP2.POS) POS2,
        MIN(SP3.POS) POS_OVERFLOW
      FROM
        BASIS_INFO BI,
        PRED_START_POSITIONS SP1,
        PRED_START_POSITIONS SP2,
        PRED_START_POSITIONS SP3
      WHERE
        SP2.PREDICATE_TYPE (+) = SP1.PREDICATE_TYPE AND
        SP2.PLAN_HASH_VALUE (+) = SP1.PLAN_HASH_VALUE AND
        SP2.CHILD_NUMBER (+) = SP1.CHILD_NUMBER AND
        SP2.ID (+) = SP1.ID AND
        SP2.POS (+) BETWEEN SP1.POS + 1 AND SP1.POS + SP1.PREDICATE_LINE_LEN AND
        SP3.PREDICATE_TYPE = SP1.PREDICATE_TYPE AND
        SP3.PLAN_HASH_VALUE = SP1.PLAN_HASH_VALUE AND
        SP3.CHILD_NUMBER = SP1.CHILD_NUMBER AND
        SP3.ID = SP1.ID AND
        SP3.POS > SP1.POS
      GROUP BY
        SP1.PREDICATE_TYPE,
        SP1.PREDICATE_INFO,
        SP1.PLAN_HASH_VALUE,
        SP1.CHILD_NUMBER,
        SP1.ID,
        SP1.POS
    )
  )  
),
PRED_START_END_LINE_POSITIONS AS
( SELECT /*+ MATERIALIZE */
    PREDICATE_TYPE,
    PREDICATE_INFO,
    PLAN_HASH_VALUE,
    CHILD_NUMBER,
    ID,
    POS1,
    POS2,
    ROW_NUMBER () OVER (ORDER BY POS1) LINE
  FROM
    PRED_START_END_POSITIONS
  START WITH
    POS1 = 1
  CONNECT BY PRIOR 
    CONN_ID2 = CONN_ID1
),
LINES AS
( SELECT 1 NUM, 'ACTION' CONTENT FROM DUAL
  UNION ALL
  SELECT 2 NUM, 'COST' CONTENT FROM DUAL 
  UNION ALL
  SELECT 3 NUM, 'SEARCH COLUMNS' CONTENT FROM DUAL
  UNION ALL
  SELECT 4 NUM, 'ACCESS PREDICATE' CONTENT FROM DUAL
  UNION ALL
  SELECT 5 NUM, 'FILTER PREDICATE' CONTENT FROM DUAL
  UNION ALL
  SELECT 6 NUM, 'SPACE' CONTENT FROM DUAL
  UNION ALL
  SELECT 7 NUM, 'PARTITION' CONTENT FROM DUAL
  UNION ALL
  SELECT 8 NUM, 'PX' CONTENT FROM DUAL
  UNION ALL
  SELECT 9 NUM, 'PLAN STATISTICS' CONTENT FROM DUAL
  UNION ALL
  SELECT 10 NUM, 'EMPTY' CONTENT FROM DUAL
)
SELECT
  ID,
  SUBSTR(SQL_PLAN_STEP, 1, COLUMN_LINE_LEN) SQL_PLAN_STEP1,
  SUBSTR(SQL_PLAN_STEP, COLUMN_LINE_LEN + 1, COLUMN_LINE_LEN) SQL_PLAN_STEP2,
  SUBSTR(SQL_PLAN_STEP, COLUMN_LINE_LEN * 2 + 1, COLUMN_LINE_LEN) SQL_PLAN_STEP3
FROM
( SELECT
    LPAD(DECODE(L.NUM, 1, TO_CHAR(SP.ID), ' '), 4) ID,
    LPAD(' ', SP.DEPTH * 2) ||
      DECODE(L.CONTENT, 
        'ACTION',           ACTION_INFO || DECODE(SP.ID, 0, 
                            ' (SQL_ID: ' || SP.SQL_ID || 
                            ', Plan Hash: ' || SP.PLAN_HASH_VALUE || 
                            ', Child: ' || SP.CHILD_NUMBER || 
                            /* ', Instance: ' || SP.INST_ID || */ ')'),
        'COST',             '  ' || COST_INFO,
        'SEARCH COLUMNS',   '  ' || SEARCH_COLUMNS_INFO,
        'ACCESS PREDICATE', DECODE(PL.POS1, 1, '  ', '    ') || 
                            SUBSTR(PL.PREDICATE_INFO, PL.POS1 + 1, PL.POS2 - PL.POS1),
        'FILTER PREDICATE', DECODE(PL.POS1, 1, '  ', '    ') || 
                            SUBSTR(PL.PREDICATE_INFO, PL.POS1 + 1, PL.POS2 - PL.POS1),
        'SPACE',            '  ' || SPACE_INFO,
        'PARTITION',        '  ' || PARTITION_INFO,
        'PX',               '  ' || PX_INFO,
        'PLAN STATISTICS',  '  ' || PLAN_STATISTICS_INFO,
        'EMPTY',            ' ') SQL_PLAN_STEP,
    BI.COLUMN_LINE_LEN,
    SP.INST_ID
  FROM
    BASIS_INFO BI,
    LINES L,
    SQL_PLANS SP,
    PRED_START_END_LINE_POSITIONS PL
  WHERE
    ( L.CONTENT = 'ACTION' AND PL.LINE = 1 OR
      L.CONTENT = 'COST' AND SP.COST_INFO IS NOT NULL AND PL.LINE = 1  OR
      L.CONTENT = 'SEARCH COLUMNS' AND SP.SEARCH_COLUMNS_INFO IS NOT NULL AND PL.LINE = 1 OR
      L.CONTENT = 'ACCESS PREDICATE' AND SP.ACCESS_PREDICATE_INFO IS NOT NULL AND 
        PL.PREDICATE_TYPE = 'ACCESS' AND PL.PLAN_HASH_VALUE = SP.PLAN_HASH_VALUE AND
        PL.CHILD_NUMBER = SP.CHILD_NUMBER AND PL.ID = SP.ID OR
      L.CONTENT = 'FILTER PREDICATE' AND SP.FILTER_PREDICATE_INFO IS NOT NULL AND 
        PL.PREDICATE_TYPE = 'FILTER' AND PL.PLAN_HASH_VALUE = SP.PLAN_HASH_VALUE AND
        PL.CHILD_NUMBER = SP.CHILD_NUMBER AND PL.ID = SP.ID OR
      L.CONTENT = 'SPACE'            AND SP.SPACE_INFO IS NOT NULL AND PL.LINE = 1 OR
      L.CONTENT = 'PARTITION'        AND SP.PARTITION_INFO IS NOT NULL AND PL.LINE = 1 OR
      L.CONTENT = 'PX'               AND SP.PX_INFO IS NOT NULL AND PL.LINE = 1 OR
      L.CONTENT = 'PLAN STATISTICS'  AND SP.PLAN_STATISTICS_INFO IS NOT NULL AND PL.LINE = 1 OR
      L.CONTENT = 'EMPTY' AND PL.LINE = 1
    )
  ORDER BY
    SP.INST_ID,
    SP.PLAN_HASH_VALUE,
    SP.CHILD_NUMBER,
    SP.ID,
    L.NUM,
    PL.POS1
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d226a53-014d-1000-8047-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_CursorCache_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL EXECUTIONS, NULL ELA_TIME_MS, NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, NULL RECORDS, NULL "REC/EXE", NULL DISK_READS, NULL "DISK_READS/EXE", NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", NULL "BUFFER_GETS/ROW", NULL PARSE_MS, NULL PARSES, NULL MODULE
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL EXECUTIONS, NULL ELA_TIME_MS, NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, NULL RECORDS, NULL "REC/EXE", NULL DISK_READS, NULL "DISK_READS/EXE", NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", NULL "BUFFER_GETS/ROW", NULL PARSE_MS, NULL PARSES, NULL MODULE
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM ( 
WITH BASIS_INFO AS /* 11g: V$SQLSTATS_PLAN_HASH */ 
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 22:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 09:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      :SQL_ID SQL_ID
    FROM
      DUAL
  )
),
SNAPSHOTS AS
( SELECT 
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.INSTANCE_NUMBER
)
SELECT
  'SQL_ID: ' || SQL_ID BEGIN_TIME,
  NULL PLAN_HASH,
  NULL INST,
  NULL EXECUTIONS, 
  NULL ELA_TIME_MS, 
  NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, 
  NULL RECORDS, 
  NULL "REC/EXE", 
  NULL DISK_READS, 
  NULL "DISK_READS/EXE", 
  NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", 
  NULL "BUFFER_GETS/ROW", 
  NULL PARSE_MS, 
  NULL PARSES, 
  NULL MODULE
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL PLAN_HASH,
    NULL INST,
    NULL EXECUTIONS, 
    NULL ELA_TIME_MS, 
    NULL "ELA_TIME_MS/EXE",
    NULL CPU_TIME_MS, 
    NULL RECORDS, 
    NULL "REC/EXE", 
    NULL DISK_READS, 
    NULL "DISK_READS/EXE", 
    NULL BUFFER_GETS,
    NULL "BUFFER_GETS/EXE", 
    NULL "BUFFER_GETS/ROW", 
    NULL PARSE_MS, 
    NULL PARSES, 
    NULL MODULE
  FROM
  BASIS_INFO
)
UNION ALL
( SELECT
    'V$SQL' BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(S.INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ROUND(ELAPSED_TIME / 1000), 11) ELA_TIME_MS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 99999999990.99) "ELA_TIME_MS/EXE",
    LPAD(ROUND(CPU_TIME / 1000), 11) CPU_TIME_MS,
    LPAD(ROWS_PROCESSED, 12) RECORDS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      9999999990.99) "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      9999999990.99) "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      99999999990.99) "BUFFER_GETS/EXE",
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 99999999990.99) "BUFFER_GETS/ROW",
    LPAD('not avail.', 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
    BASIS_INFO BI,
    GV$SQL S
  WHERE
    S.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      S.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    RPAD('V$SQLSTATS', 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(SS.INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ROUND(ELAPSED_TIME / 1000), 11) ELA_TIME_MS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 99999999990.99) "ELA_TIME_MS/EXE",
    LPAD(ROUND(CPU_TIME / 1000), 11) CPU_TIME_MS,
    LPAD(ROWS_PROCESSED, 12) RECORDS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      9999999990.99) "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      9999999990.99) "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      99999999990.99) "BUFFER_GETS/EXE",
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 99999999990.99) "BUFFER_GETS/ROW",
    LPAD(ROUND(AVG_HARD_PARSE_TIME / 1000, 2), 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    'not available in V$SQLSTATS' MODULE 
  FROM
    BASIS_INFO BI,
    GV$SQLSTATS_PLAN_HASH SS
  WHERE
    SS.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      SS.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    RPAD(BEGIN_TIME, 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ELAPSED_TIME_MS, 11) ELA_TIME_MS,
    ELAPSED_TIME_MS_PER_EXEC "ELA_TIME_MS/EXE",
    LPAD(CPU_TIME_MS, 11) CPU_TIME_MS,
    LPAD(RECORDS, 12) RECORDS,
    RECORDS_PER_EXEC "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    DISK_READS_PER_EXEC "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    BUFFER_GETS_PER_EXEC "BUFFER_GETS/EXE",
    BUFFER_GETS_PER_RECORD "BUFFER_GETS/ROW",
    LPAD(AVG_PARSE, 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
  ( SELECT
      'TOTAL (HISTORY)' BEGIN_TIME,
      HSQ.INSTANCE_NUMBER INST_ID,
      SUM(HSQ.EXECUTIONS_DELTA) EXECUTIONS,
      SUM(HSQ.ROWS_PROCESSED_DELTA) RECORDS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ROWS_PROCESSED_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 9999999990.99) RECORDS_PER_EXEC,
      SUM(HSQ.DISK_READS_DELTA) DISK_READS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.DISK_READS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 9999999990.99) DISK_READS_PER_EXEC,
      SUM(HSQ.BUFFER_GETS_DELTA) BUFFER_GETS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 99999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(SUM(HSQ.ROWS_PROCESSED_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.ROWS_PROCESSED_DELTA)), 99999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(SUM(HSQ.ELAPSED_TIME_DELTA) / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ELAPSED_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 99999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(SUM(HSQ.CPU_TIME_DELTA) / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.CPU_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,  
      HSQ.PLAN_HASH_VALUE,
      SUM(HSQ.PARSE_CALLS_DELTA) PARSE_CALLS, 
      ' ' MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ, 
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    GROUP BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
    ORDER BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
UNION ALL
( SELECT
    RPAD(BEGIN_INTERVAL_TIME, 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ELAPSED_TIME_MS, 11) ELA_TIME_MS,
    ELAPSED_TIME_MS_PER_EXEC "ELA_TIME_MS/EXE",
    LPAD(CPU_TIME_MS, 11) CPU_TIME_MS,
    LPAD(RECORDS, 12) RECORDS,
    RECORDS_PER_EXEC "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    DISK_READS_PER_EXEC "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    BUFFER_GETS_PER_EXEC "BUFFER_GETS/EXE",
    BUFFER_GETS_PER_RECORD "BUFFER_GETS/ROW",
    LPAD(AVG_PARSE, 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
  ( SELECT
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') BEGIN_INTERVAL_TIME,
      HSQ.INSTANCE_NUMBER INST_ID,
      HSQ.EXECUTIONS_DELTA EXECUTIONS,
      HSQ.ROWS_PROCESSED_DELTA RECORDS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.ROWS_PROCESSED_DELTA /
        HSQ.EXECUTIONS_DELTA), 9999999990.99) RECORDS_PER_EXEC,
      HSQ.DISK_READS_DELTA DISK_READS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.DISK_READS_DELTA /
        HSQ.EXECUTIONS_DELTA), 9999999990.99) DISK_READS_PER_EXEC,
      HSQ.BUFFER_GETS_DELTA BUFFER_GETS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.BUFFER_GETS_DELTA /
        HSQ.EXECUTIONS_DELTA), 99999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(HSQ.ROWS_PROCESSED_DELTA, 0, 0, HSQ.BUFFER_GETS_DELTA /
        HSQ.ROWS_PROCESSED_DELTA), 99999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(HSQ.ELAPSED_TIME_DELTA / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.ELAPSED_TIME_DELTA /
        HSQ.EXECUTIONS_DELTA / 1000), 99999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(HSQ.CPU_TIME_DELTA / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.CPU_TIME_DELTA /
        HSQ.EXECUTIONS_DELTA / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,
      HSQ.PARSE_CALLS_DELTA PARSE_CALLS,
      HSQ.PLAN_HASH_VALUE,
      HSQ.MODULE MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ,
      DBA_HIST_SNAPSHOT HSS,
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSQ.SNAP_ID = HSS.SNAP_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    ORDER BY
      HSQ.SNAP_ID DESC,
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d231dbb-014d-1000-8048-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_CursorCache]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL EXECUTIONS, NULL ELA_TIME_MS, NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, NULL RECORDS, NULL "REC/EXE", NULL DISK_READS, NULL "DISK_READS/EXE", NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", NULL "BUFFER_GETS/ROW", NULL PARSE_MS, NULL PARSES, NULL MODULE
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL EXECUTIONS, NULL ELA_TIME_MS, NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, NULL RECORDS, NULL "REC/EXE", NULL DISK_READS, NULL "DISK_READS/EXE", NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", NULL "BUFFER_GETS/ROW", NULL PARSE_MS, NULL PARSES, NULL MODULE
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 22:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 09:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      :SQL_ID SQL_ID
    FROM
      DUAL
  )
),
SNAPSHOTS AS
( SELECT 
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.INSTANCE_NUMBER
)
SELECT
  'SQL_ID: ' || SQL_ID BEGIN_TIME,
  NULL PLAN_HASH,
  NULL INST,
  NULL EXECUTIONS, 
  NULL ELA_TIME_MS, 
  NULL "ELA_TIME_MS/EXE",
  NULL CPU_TIME_MS, 
  NULL RECORDS, 
  NULL "REC/EXE", 
  NULL DISK_READS, 
  NULL "DISK_READS/EXE", 
  NULL BUFFER_GETS,
  NULL "BUFFER_GETS/EXE", 
  NULL "BUFFER_GETS/ROW", 
  NULL PARSE_MS, 
  NULL PARSES, 
  NULL MODULE
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL PLAN_HASH,
    NULL INST,
    NULL EXECUTIONS, 
    NULL ELA_TIME_MS, 
    NULL "ELA_TIME_MS/EXE",
    NULL CPU_TIME_MS, 
    NULL RECORDS, 
    NULL "REC/EXE", 
    NULL DISK_READS, 
    NULL "DISK_READS/EXE", 
    NULL BUFFER_GETS,
    NULL "BUFFER_GETS/EXE", 
    NULL "BUFFER_GETS/ROW", 
    NULL PARSE_MS, 
    NULL PARSES, 
    NULL MODULE
  FROM
  BASIS_INFO
)
UNION ALL
( SELECT
    'V$SQL' BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(S.INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ROUND(ELAPSED_TIME / 1000), 11) ELA_TIME_MS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 99999999990.99) "ELA_TIME_MS/EXE",
    LPAD(ROUND(CPU_TIME / 1000), 11) CPU_TIME_MS,
    LPAD(ROWS_PROCESSED, 12) RECORDS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      999999990.99) "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      9999999990.99) "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      99999999990.99) "BUFFER_GETS/EXE",
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 99999999990.99) "BUFFER_GETS/ROW",
    LPAD('not avail.', 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
    BASIS_INFO BI,
    GV$SQL S
  WHERE
    S.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      S.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    RPAD('V$SQLSTATS', 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(SS.INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ROUND(ELAPSED_TIME / 1000), 11) ELA_TIME_MS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ELAPSED_TIME / 1000 / EXECUTIONS, 
      2)), 99999999990.99) "ELA_TIME_MS/EXE",
    LPAD(ROUND(CPU_TIME / 1000), 11) CPU_TIME_MS,
    LPAD(ROWS_PROCESSED, 12) RECORDS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(ROWS_PROCESSED / EXECUTIONS, 2)), 
      999999990.99) "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(DISK_READS / EXECUTIONS, 2)),  
      9999999990.99) "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    TO_CHAR(DECODE(EXECUTIONS, 0, 0, ROUND(BUFFER_GETS / EXECUTIONS, 2)), 
      99999999990.99) "BUFFER_GETS/EXE",
    TO_CHAR(DECODE(ROWS_PROCESSED, 0, 0, ROUND(BUFFER_GETS / ROWS_PROCESSED, 
      2)), 99999999990.99) "BUFFER_GETS/ROW",
    LPAD(ROUND(AVG_HARD_PARSE_TIME / 1000, 2), 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    'not available in V$SQLSTATS' MODULE 
  FROM
    BASIS_INFO BI,
    GV$SQLSTATS SS
  WHERE
    SS.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      SS.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    RPAD(BEGIN_TIME, 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ELAPSED_TIME_MS, 11) ELA_TIME_MS,
    ELAPSED_TIME_MS_PER_EXEC "ELA_TIME_MS/EXE",
    LPAD(CPU_TIME_MS, 11) CPU_TIME_MS,
    LPAD(RECORDS, 12) RECORDS,
    RECORDS_PER_EXEC "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    DISK_READS_PER_EXEC "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    BUFFER_GETS_PER_EXEC "BUFFER_GETS/EXE",
    BUFFER_GETS_PER_RECORD "BUFFER_GETS/ROW",
    LPAD(AVG_PARSE, 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
  ( SELECT
      'TOTAL (HISTORY)' BEGIN_TIME,
      HSQ.INSTANCE_NUMBER INST_ID,
      SUM(HSQ.EXECUTIONS_DELTA) EXECUTIONS,
      SUM(HSQ.ROWS_PROCESSED_DELTA) RECORDS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ROWS_PROCESSED_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 999999990.99) RECORDS_PER_EXEC,
      SUM(HSQ.DISK_READS_DELTA) DISK_READS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.DISK_READS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 9999999990.99) DISK_READS_PER_EXEC,
      SUM(HSQ.BUFFER_GETS_DELTA) BUFFER_GETS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA)), 99999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(SUM(HSQ.ROWS_PROCESSED_DELTA), 0, 0, SUM(HSQ.BUFFER_GETS_DELTA) / 
        SUM(HSQ.ROWS_PROCESSED_DELTA)), 99999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(SUM(HSQ.ELAPSED_TIME_DELTA) / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.ELAPSED_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 99999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(SUM(HSQ.CPU_TIME_DELTA) / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(SUM(HSQ.EXECUTIONS_DELTA), 0, 0, SUM(HSQ.CPU_TIME_DELTA) / 
        SUM(HSQ.EXECUTIONS_DELTA) / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,  
      HSQ.PLAN_HASH_VALUE,
      SUM(HSQ.PARSE_CALLS_DELTA) PARSE_CALLS, 
      ' ' MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ, 
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    GROUP BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
    ORDER BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
UNION ALL
( SELECT
    RPAD(BEGIN_INTERVAL_TIME, 19) BEGIN_TIME,
    LPAD(PLAN_HASH_VALUE, 10) PLAN_HASH,
    LPAD(INST_ID, 4) INST,
    LPAD(EXECUTIONS, 10) EXECUTIONS,
    LPAD(ELAPSED_TIME_MS, 11) ELA_TIME_MS,
    ELAPSED_TIME_MS_PER_EXEC "ELA_TIME_MS/EXE",
    LPAD(CPU_TIME_MS, 11) CPU_TIME_MS,
    LPAD(RECORDS, 12) RECORDS,
    RECORDS_PER_EXEC "REC/EXE",
    LPAD(DISK_READS, 10) DISK_READS,
    DISK_READS_PER_EXEC "DISK_READS/EXE",
    LPAD(BUFFER_GETS, 11) BUFFER_GETS,
    BUFFER_GETS_PER_EXEC "BUFFER_GETS/EXE",
    BUFFER_GETS_PER_RECORD "BUFFER_GETS/ROW",
    LPAD(AVG_PARSE, 11) PARSE_MS,
    LPAD(PARSE_CALLS, 6) PARSES,
    MODULE 
  FROM
  ( SELECT
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') BEGIN_INTERVAL_TIME,
      HSQ.INSTANCE_NUMBER INST_ID,
      HSQ.EXECUTIONS_DELTA EXECUTIONS,
      HSQ.ROWS_PROCESSED_DELTA RECORDS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.ROWS_PROCESSED_DELTA /
        HSQ.EXECUTIONS_DELTA), 999999990.99) RECORDS_PER_EXEC,
      HSQ.DISK_READS_DELTA DISK_READS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.DISK_READS_DELTA /
        HSQ.EXECUTIONS_DELTA), 9999999990.99) DISK_READS_PER_EXEC,
      HSQ.BUFFER_GETS_DELTA BUFFER_GETS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.BUFFER_GETS_DELTA /
        HSQ.EXECUTIONS_DELTA), 99999999990.99) BUFFER_GETS_PER_EXEC,
      TO_CHAR(DECODE(HSQ.ROWS_PROCESSED_DELTA, 0, 0, HSQ.BUFFER_GETS_DELTA /
        HSQ.ROWS_PROCESSED_DELTA), 99999999990.99) BUFFER_GETS_PER_RECORD,
      ROUND(HSQ.ELAPSED_TIME_DELTA / 1000) ELAPSED_TIME_MS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.ELAPSED_TIME_DELTA /
        HSQ.EXECUTIONS_DELTA / 1000), 99999999990.99) ELAPSED_TIME_MS_PER_EXEC,
      ROUND(HSQ.CPU_TIME_DELTA / 1000) CPU_TIME_MS,
      TO_CHAR(DECODE(HSQ.EXECUTIONS_DELTA, 0, 0, HSQ.CPU_TIME_DELTA /
        HSQ.EXECUTIONS_DELTA / 1000), 999999999990.99) CPU_TIME_MS_PER_EXEC,
      'not avail.' AVG_PARSE,
      HSQ.PARSE_CALLS_DELTA PARSE_CALLS,
      HSQ.PLAN_HASH_VALUE,
      HSQ.MODULE MODULE
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ,
      DBA_HIST_SNAPSHOT HSS,
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSQ.SNAP_ID = HSS.SNAP_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    ORDER BY
      HSQ.SNAP_ID DESC,
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d2c0d67-014d-1000-8049-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_KeyFigures]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_PUSH_JOIN_PREDICATE', 'FALSE') */
  NULL STAT_NAME, NULL VALUE, NULL VALUE_PER_EXEC, 
  NULL VALUE_PER_ROW, NULL "TOTAL_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL STAT_NAME, NULL VALUE, NULL VALUE_PER_EXEC, 
  NULL VALUE_PER_ROW, NULL "TOTAL_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,
    END_SNAP_ID,
    SQL_ID,
    SUPPRESS_ZERO_LINES,
    TIME_UNIT,
    DECODE(TIME_UNIT, 'MS', 1, 'S', 1000, 'M', 60000, 'H', 3600000, 'D', 86400000) TIME_FACTOR,
    TOTAL_VALUE_DETERMINATION
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 11:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('27.08.9999 00:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      :SQL_ID SQL_ID,
      'X' SUPPRESS_ZERO_LINES,
      'H' TIME_UNIT,                    /* MS, S, M, H, D */
      'SYSSTAT' TOTAL_VALUE_DETERMINATION     /* SQL, SYSSTAT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    MIN_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    RESTART,
    SQL_ID
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      FIRST_VALUE(HSS2.SNAP_ID) OVER (ORDER BY HSS2.SNAP_ID) MIN_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART,
      BI.SQL_ID
    FROM 
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2,
      BASIS_INFO BI
    WHERE
      BI.DBID = HSS2.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR
        BI.INSTANCE_NUMBER = HSS2.INSTANCE_NUMBER ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  )
),
LINES AS
( SELECT  1 LINENR, 'SQL_ID'                     STAT_NAME FROM DUAL UNION ALL
  SELECT  2 LINENR, 'Start Time'                 STAT_NAME FROM DUAL UNION ALL
  SELECT  3 LINENR, 'End Time'                   STAT_NAME FROM DUAL UNION ALL
  SELECT  4 LINENR, 'Instance Number'            STAT_NAME FROM DUAL UNION ALL
  SELECT  5 LINENR, 'Module'                     STAT_NAME FROM DUAL UNION ALL
  SELECT  6 LINENR, 'Executions'                 STAT_NAME FROM DUAL UNION ALL
  SELECT  7 LINENR, 'Records'                    STAT_NAME FROM DUAL UNION ALL
  SELECT  8 LINENR, 'Disk Reads'                 STAT_NAME FROM DUAL UNION ALL
  SELECT  9 LINENR, 'Buffer Gets'                STAT_NAME FROM DUAL UNION ALL
  SELECT 10 LINENR, 'Direct Writes'              STAT_NAME FROM DUAL UNION ALL
  SELECT 11 LINENR, 'Parse Calls'                STAT_NAME FROM DUAL UNION ALL
  SELECT 12 LINENR, 'Sharable Memory (kb)'       STAT_NAME FROM DUAL UNION ALL
  SELECT 13 LINENR, 'Hit Ratio (%)'              STAT_NAME FROM DUAL UNION ALL
  SELECT 14 LINENR, 'I/O Time / Block (ms)'      STAT_NAME FROM DUAL UNION ALL
  SELECT 15 LINENR, 'Active Sessions'            STAT_NAME FROM DUAL UNION ALL
  SELECT 16 LINENR, ' '                          STAT_NAME FROM DUAL UNION ALL
  SELECT 17 LINENR, 'Elapsed Time'          STAT_NAME FROM BASIS_INFO UNION ALL
  SELECT 18 LINENR, 'CPU Time'              STAT_NAME FROM DUAL UNION ALL
  SELECT 19 LINENR, 'I/O Wait Time'         STAT_NAME FROM DUAL UNION ALL
  SELECT 20 LINENR, 'Appl. Wait Time'       STAT_NAME FROM DUAL UNION ALL
  SELECT 21 LINENR, 'Conc. Wait Time'       STAT_NAME FROM DUAL UNION ALL
  SELECT 22 LINENR, 'Clust. Wait Time'      STAT_NAME FROM DUAL 
),
TOTAL_SECONDS AS
( SELECT
    MAX(SUM(INTERVAL_SECONDS)) TOTAL_SECONDS
  FROM
    SNAPSHOTS
  WHERE
    SNAP_ID != MIN_SNAP_ID
  GROUP BY
    DBID,
    INSTANCE_NUMBER
),
TOTAL_FIGURES_PER_SNAPSHOT AS    
( SELECT
    SNAP_ID,
    SUM(DECODE(STAT_NAME, 'DB time', VALUE, 0)) / 1000 DB_TIME_MS,
    SUM(DECODE(STAT_NAME, 'concurrency wait time', VALUE, 0)) * 10 CONCURRENCY_TIME_MS,
    SUM(DECODE(STAT_NAME, 'cluster wait time', VALUE, 0)) * 10 CLUSTER_TIME_MS,
    SUM(DECODE(STAT_NAME, 'application wait time', VALUE, 0)) * 10 APPLICATION_TIME_MS,
    SUM(DECODE(STAT_NAME, 'user I/O wait time', VALUE, 0)) * 10 USERIO_TIME_MS,
    SUM(DECODE(STAT_NAME, 'DB CPU', VALUE, 0)) / 1000 CPU_TIME_MS,
    SUM(DECODE(STAT_NAME, 'user calls', VALUE, 0)) USER_CALLS,
    SUM(DECODE(STAT_NAME, 'session logical reads', VALUE, 0)) BUFFER_GETS,
    SUM(DECODE(STAT_NAME, 'physical reads', VALUE, 0)) DISK_READS,
    SUM(DECODE(STAT_NAME, 'queries parallelized', VALUE, 
      'DML statements parallelized', VALUE,
      'DDL statements parallelized', VALUE, 0)) PX_EXECUTIONS,
    SUM(DECODE(STAT_NAME, 'parse count (total)', VALUE, 0)) PARSE_COUNT,
    SUM(DECODE(STAT_NAME, 'physical writes direct', VALUE, 0)) DIRECT_WRITES
  FROM
  ( SELECT
      SS.SNAP_ID,
      STAT_NAME,
      VALUE
    FROM
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSS
    WHERE
      HSS.DBID = SS.DBID AND
      HSS.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSS.SNAP_ID = SS.SNAP_ID AND
      STAT_NAME IN
      ( 'concurrency wait time',
        'cluster wait time',
        'application wait time',
        'user I/O wait time',
        'user calls',
        'session logical reads',
        'physical reads',
        'queries parallelized',
        'DML statements parallelized',
        'DDL statements parallelized',
        'parse count (total)',
        'physical writes direct'
      )
    UNION ALL
    ( SELECT
        SS.SNAP_ID,
        HSS.STAT_NAME,
        HSS.VALUE
      FROM
        SNAPSHOTS SS,
        DBA_HIST_SYS_TIME_MODEL HSS
      WHERE
        HSS.DBID = SS.DBID AND
        HSS.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSS.SNAP_ID = SS.SNAP_ID AND
        STAT_NAME IN
        ( 'DB time',
          'DB CPU'
        )
    )
  )
  GROUP BY
    SNAP_ID
),
TOTAL_FIGURES AS
( SELECT
    /* Very first interval in history (NULL values in TFPS1) has to be */
    /* ignored as no delta values are available */
    SUM(DECODE(TFPS1.DB_TIME_MS, NULL, 0, TFPS2.DB_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.DB_TIME_MS, 0))) TOTAL_DB_TIME_MS,
    SUM(DECODE(TFPS1.CONCURRENCY_TIME_MS, NULL, 0, TFPS2.CONCURRENCY_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.CONCURRENCY_TIME_MS, 0))) TOTAL_CONCURRENCY_TIME_MS,
    SUM(DECODE(TFPS1.CLUSTER_TIME_MS, NULL, 0, TFPS2.CLUSTER_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.CLUSTER_TIME_MS, 0))) TOTAL_CLUSTER_TIME_MS,
    SUM(DECODE(TFPS1.APPLICATION_TIME_MS, NULL, 0, TFPS2.APPLICATION_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.APPLICATION_TIME_MS, 0))) TOTAL_APPLICATION_TIME_MS,
    SUM(DECODE(TFPS1.USERIO_TIME_MS, NULL, 0, TFPS2.USERIO_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.USERIO_TIME_MS, 0))) TOTAL_USERIO_TIME_MS,
    SUM(DECODE(TFPS1.CPU_TIME_MS, NULL, 0, TFPS2.CPU_TIME_MS - 
      DECODE(SS.RESTART, 'NO', TFPS1.CPU_TIME_MS, 0))) TOTAL_CPU_TIME_MS,
    SUM(DECODE(TFPS1.USER_CALLS, NULL, 0, TFPS2.USER_CALLS - 
      DECODE(SS.RESTART, 'NO', TFPS1.USER_CALLS, 0))) TOTAL_USER_CALLS,
    -1 TOTAL_RECORDS,
    SUM(DECODE(TFPS1.BUFFER_GETS, NULL, 0, TFPS2.BUFFER_GETS - 
      DECODE(SS.RESTART, 'NO', TFPS1.BUFFER_GETS, 0))) TOTAL_BUFFER_GETS,
    SUM(DECODE(TFPS1.DISK_READS, NULL, 0, TFPS2.DISK_READS - 
      DECODE(SS.RESTART, 'NO', TFPS1.DISK_READS, 0))) TOTAL_DISK_READS,
    SUM(DECODE(TFPS1.PX_EXECUTIONS, NULL, 0, TFPS2.PX_EXECUTIONS - 
      DECODE(SS.RESTART, 'NO', TFPS1.PX_EXECUTIONS, 0))) TOTAL_PX_EXECUTIONS,
    SUM(DECODE(TFPS1.PARSE_COUNT, NULL, 0, TFPS2.PARSE_COUNT - 
      DECODE(SS.RESTART, 'NO', TFPS1.PARSE_COUNT, 0))) TOTAL_PARSE_COUNT,
    SUM(DECODE(TFPS1.DIRECT_WRITES, NULL, 0, TFPS2.DIRECT_WRITES - 
      DECODE(SS.RESTART, 'NO', TFPS1.DIRECT_WRITES, 0))) TOTAL_DIRECT_WRITES
  FROM
    BASIS_INFO BI,
    SNAPSHOTS SS,
    TOTAL_FIGURES_PER_SNAPSHOT TFPS1,
    TOTAL_FIGURES_PER_SNAPSHOT TFPS2
  WHERE
    BI.TOTAL_VALUE_DETERMINATION = 'SYSSTAT' AND
    TFPS2.SNAP_ID = SS.SNAP_ID AND
    TFPS1.SNAP_ID (+) = TFPS2.SNAP_ID - 1
  UNION ALL
  ( SELECT
      SUM(ELAPSED_TIME_DELTA / 1000) TOTAL_DB_TIME_MS,
      SUM(CCWAIT_DELTA / 1000) TOTAL_CONCURRENCY_TIME_MS,
      SUM(CLWAIT_DELTA / 1000) TOTAL_CLUSTER_TIME_MS,
      SUM(APWAIT_DELTA / 1000) TOTAL_APPLICATION_TIME_MS,
      SUM(IOWAIT_DELTA / 1000) TOTAL_USERIO_TIME_MS,
      SUM(CPU_TIME_DELTA / 1000) TOTAL_CPU_TIME,
      SUM(EXECUTIONS_DELTA) TOTAL_USER_CALLS,
      SUM(ROWS_PROCESSED_DELTA) TOTAL_RECORDS,
      SUM(BUFFER_GETS_DELTA) TOTAL_BUFFER_GETS,
      SUM(DISK_READS_DELTA) TOTAL_DISK_READS,
      SUM(PX_SERVERS_EXECS_DELTA) TOTAL_PX_EXECUTIONS,
      SUM(PARSE_CALLS_DELTA) TOTAL_PARSE_COUNT,
      SUM(DIRECT_WRITES_DELTA) TOTAL_DIRECT_WRITES
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SQLSTAT HSQ
    WHERE
      BI.TOTAL_VALUE_DETERMINATION = 'SQL' AND
      SS.SNAP_ID != SS.MIN_SNAP_ID AND
      SS.SNAP_ID = HSQ.SNAP_ID AND
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER 
  )
)
SELECT
  STAT_NAME,
  VALUE,
  VALUE_PER_EXEC,
  VALUE_PER_ROW,
  "TOTAL_%"
FROM
( SELECT
    STAT_NAME,
    MAX(DECODE(LINENR, 
       1, SQL_ID, 
       2, TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss'),
       3, TO_CHAR(END_INTERVAL_TIME,   'dd.mm.yyyy hh24:mi:ss'),
       4, INST_ID,
       5, SUBSTR(MODULE, 1, 19),
       6, TO_CHAR(EXECUTIONS,                    999999999999999990),
       7, TO_CHAR(RECORDS,                       999999999999999990),
       8, TO_CHAR(DISK_READS,                    999999999999999990),
       9, TO_CHAR(BUFFER_GETS,                   999999999999999990),
      10, TO_CHAR(DIRECT_WRITES,                 999999999999999990),
      11, TO_CHAR(PARSE_CALLS,                   999999999999999990),
      12, TO_CHAR(SHARABLE_MEM_KB,               999999999999999990),
      13, TO_CHAR(DECODE(BUFFER_GETS, 0, 0, 
          (1 - DISK_READS / BUFFER_GETS) * 100), 999999999999990.99),
      14, TO_CHAR(DECODE(DISK_READS, 0, 0, IO_WAIT_TIME_MS / DISK_READS),  999999999999990.99),
      15, TO_CHAR(DECODE(TOTAL_SECONDS, 0, 0, ELAPSED_TIME_MS / 1000 / TOTAL_SECONDS), 999999999999990.99),
      16, NULL,
      17, LPAD(ROUND(ELAPSED_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
      18, LPAD(ROUND(CPU_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
      19, LPAD(ROUND(IO_WAIT_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
      20, LPAD(ROUND(APP_WAIT_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
      21, LPAD(ROUND(CONC_WAIT_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
      22, LPAD(ROUND(CLUSTER_WAIT_TIME_MS / TIME_FACTOR) || ' ' || LOWER(TIME_UNIT), 19),
    NULL)) VALUE,
    MAX(DECODE(LINENR,
       1, NULL, 
       2, NULL,
       3, NULL,
       4, NULL,
       5, SUBSTR(MODULE, 20, 16),
       6, NULL,
       7, TO_CHAR(DECODE(EXECUTIONS, 0, 0, RECORDS / EXECUTIONS),              999999999990.99),
       8, TO_CHAR(DECODE(EXECUTIONS, 0, 0, DISK_READS / EXECUTIONS),           999999999990.99),
       9, TO_CHAR(DECODE(EXECUTIONS, 0, 0, BUFFER_GETS / EXECUTIONS),          999999999990.99),
      10, TO_CHAR(DECODE(EXECUTIONS, 0, 0, DIRECT_WRITES / EXECUTIONS),        999999999990.99),
      11, TO_CHAR(DECODE(EXECUTIONS, 0, 0, PARSE_CALLS / EXECUTIONS),          999999999990.99),
      12, NULL,
      13, NULL,
      14, NULL,
      15, NULL,
      16, NULL,
      17, TO_CHAR(DECODE(EXECUTIONS, 0, 0, ELAPSED_TIME_MS / EXECUTIONS),      999999990.99) || ' ms',
      18, TO_CHAR(DECODE(EXECUTIONS, 0, 0, CPU_TIME_MS / EXECUTIONS),          999999990.99) || ' ms',
      19, TO_CHAR(DECODE(EXECUTIONS, 0, 0, IO_WAIT_TIME_MS / EXECUTIONS),      999999990.99) || ' ms',
      20, TO_CHAR(DECODE(EXECUTIONS, 0, 0, APP_WAIT_TIME_MS / EXECUTIONS),     999999990.99) || ' ms',
      21, TO_CHAR(DECODE(EXECUTIONS, 0, 0, CONC_WAIT_TIME_MS / EXECUTIONS),    999999990.99) || ' ms',
      22, TO_CHAR(DECODE(EXECUTIONS, 0, 0, CLUSTER_WAIT_TIME_MS / EXECUTIONS), 999999990.99) || ' ms',
    NULL)) VALUE_PER_EXEC,
    MAX(DECODE(LINENR,
       1, NULL, 
       2, NULL,
       3, NULL,
       4, NULL,
       5, SUBSTR(MODULE, 36, 15),
       6, NULL,
       7, NULL,
       8, TO_CHAR(DECODE(RECORDS, 0, 0, DISK_READS / RECORDS),           99999999990.99),
       9, TO_CHAR(DECODE(RECORDS, 0, 0, BUFFER_GETS / RECORDS),          99999999990.99),
      10, TO_CHAR(DECODE(RECORDS, 0, 0, DIRECT_WRITES / RECORDS),        99999999990.99),
      11, NULL,
      12, NULL,
      13, NULL,
      14, NULL,
      15, NULL,
      16, NULL,
      17, TO_CHAR(DECODE(RECORDS, 0, 0, ELAPSED_TIME_MS / RECORDS),      99999990.99) || ' ms',
      18, TO_CHAR(DECODE(RECORDS, 0, 0, CPU_TIME_MS / RECORDS),          99999990.99) || ' ms',
      19, TO_CHAR(DECODE(RECORDS, 0, 0, IO_WAIT_TIME_MS / RECORDS),      99999990.99) || ' ms',
      20, TO_CHAR(DECODE(RECORDS, 0, 0, APP_WAIT_TIME_MS / RECORDS),     99999990.99) || ' ms',
      21, TO_CHAR(DECODE(RECORDS, 0, 0, CONC_WAIT_TIME_MS / RECORDS),    99999990.99) || ' ms',
      22, TO_CHAR(DECODE(RECORDS, 0, 0, CLUSTER_WAIT_TIME_MS / RECORDS), 99999990.99) || ' ms',
    NULL)) VALUE_PER_ROW,
    MAX(DECODE(LINENR,
       1, TOTAL_VALUE_DETERMINATION, 
       2, NULL,
       3, NULL,
       4, NULL,
       5, SUBSTR(MODULE, 50, 7),
       6, TO_CHAR(DECODE(TOTAL_USER_CALLS, 0, 0, EXECUTIONS / TOTAL_USER_CALLS * 100),             990.99),
       7, TO_CHAR(DECODE(TOTAL_RECORDS, -1, NULL, 0, 0, RECORDS / TOTAL_RECORDS * 100),            990.99),
       8, TO_CHAR(DECODE(TOTAL_DISK_READS, 0, 0, DISK_READS / TOTAL_DISK_READS * 100),             990.99),
       9, TO_CHAR(DECODE(TOTAL_BUFFER_GETS, 0, 0, BUFFER_GETS / TOTAL_BUFFER_GETS * 100),          990.99),
      10, TO_CHAR(DECODE(TOTAL_DIRECT_WRITES, 0, 0, DIRECT_WRITES / TOTAL_DIRECT_WRITES * 100),    990.99),
      11, TO_CHAR(DECODE(TOTAL_PARSE_COUNT, 0, 0, PARSE_CALLS / TOTAL_PARSE_COUNT * 100),          990.99),
      12, NULL,
      13, NULL,
      14, NULL,
      15, NULL,
      16, NULL,
      17, TO_CHAR(DECODE(TOTAL_DB_TIME_MS, 0, 0, ELAPSED_TIME_MS / TOTAL_DB_TIME_MS * 100),                     990.99),
      18, TO_CHAR(DECODE(TOTAL_CPU_TIME_MS, 0, 0, CPU_TIME_MS / TOTAL_CPU_TIME_MS * 100),                       990.99),
      19, TO_CHAR(DECODE(TOTAL_USERIO_TIME_MS, 0, 0, IO_WAIT_TIME_MS / TOTAL_USERIO_TIME_MS * 100),             990.99),
      20, TO_CHAR(DECODE(TOTAL_APPLICATION_TIME_MS, 0, 0, APP_WAIT_TIME_MS / TOTAL_APPLICATION_TIME_MS * 100),  990.99),
      21, TO_CHAR(DECODE(TOTAL_CONCURRENCY_TIME_MS, 0, 0, CONC_WAIT_TIME_MS / TOTAL_CONCURRENCY_TIME_MS * 100), 990.99),
      22, TO_CHAR(DECODE(TOTAL_CLUSTER_TIME_MS, 0, 0, CLUSTER_WAIT_TIME_MS / TOTAL_CLUSTER_TIME_MS * 100), 990.99),
    NULL)) "TOTAL_%",
    LINENR,
    SUPPRESS_ZERO_LINES
  FROM
  ( SELECT
      SS.SQL_ID SQL_ID, 
      MIN(HSQ.MODULE) MODULE,
      SUM(HSQ.EXECUTIONS_DELTA) EXECUTIONS,
      SUM(HSQ.ROWS_PROCESSED_DELTA) RECORDS,
      SUM(HSQ.DISK_READS_DELTA) DISK_READS,
      SUM(HSQ.BUFFER_GETS_DELTA) BUFFER_GETS,
      SUM(HSQ.ELAPSED_TIME_DELTA) / 1000 ELAPSED_TIME_MS,
      SUM(HSQ.CPU_TIME_DELTA) / 1000 CPU_TIME_MS,
      SUM(HSQ.IOWAIT_DELTA) / 1000 IO_WAIT_TIME_MS,
      SUM(HSQ.APWAIT_DELTA) / 1000 APP_WAIT_TIME_MS, 
      SUM(HSQ.CCWAIT_DELTA) / 1000 CONC_WAIT_TIME_MS,
      SUM(HSQ.CLWAIT_DELTA) / 1000 CLUSTER_WAIT_TIME_MS,
      SUM(HSQ.DIRECT_WRITES_DELTA) DIRECT_WRITES,
      SUM(HSQ.PARSE_CALLS_DELTA) PARSE_CALLS,
      MAX(ROUND(HSQ.SHARABLE_MEM / 1024)) SHARABLE_MEM_KB,
      L.LINENR LINENR,
      L.STAT_NAME STAT_NAME,
      MIN(SS.BEGIN_INTERVAL_TIME) BEGIN_INTERVAL_TIME,
      MAX(SS.END_INTERVAL_TIME) END_INTERVAL_TIME,
      DECODE(MIN(BI.INSTANCE_NUMBER), -2, 'ALL', MIN(SS.INSTANCE_NUMBER)) INST_ID,
      TS.TOTAL_SECONDS,
      BI.TOTAL_VALUE_DETERMINATION,
      BI.SUPPRESS_ZERO_LINES,
      BI.TIME_UNIT,
      BI.TIME_FACTOR
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SQLSTAT HSQ, 
      LINES L,
      TOTAL_SECONDS TS
    WHERE
      HSQ.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HSQ.SNAP_ID (+) = SS.SNAP_ID AND
      SS.SNAP_ID != SS.MIN_SNAP_ID AND
      HSQ.SQL_ID (+) = SS.SQL_ID
    GROUP BY
      SS.SQL_ID,
      L.LINENR,
      L.STAT_NAME,
      TS.TOTAL_SECONDS,
      BI.TOTAL_VALUE_DETERMINATION,
      BI.SUPPRESS_ZERO_LINES,
      BI.TIME_UNIT,
      BI.TIME_FACTOR
  ),
  TOTAL_FIGURES
  GROUP BY
    LINENR,
    STAT_NAME,
    SUPPRESS_ZERO_LINES
)
WHERE
  SUPPRESS_ZERO_LINES = ' ' OR LTRIM(RTRIM(SUBSTR(VALUE, 1, 17))) != '0' OR ( LINENR < 17 AND LINENR != 10 )
ORDER BY
  LINENR
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[1j0yg4tg9qtft]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d2d3e9f-014d-1000-804a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_ProfileBaselineAndPatchHints_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SQL_ID, NULL PLAN_HASH, NULL HINTS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SQL_ID, NULL PLAN_HASH, NULL HINTS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    :SQL_ID SQL_ID,
    -1 PLAN_HASH
  FROM
    DUAL
)
SELECT
  DECODE(RN, 1, SQL_ID, NULL) SQL_ID,
  DECODE(RN, 1, TO_CHAR(PLAN_HASH, 9999999990), NULL) PLAN_HASH,
  HINTS
FROM
( SELECT
    SP.SQL_ID,
    SP.PLAN_HASH_VALUE PLAN_HASH,
    EXTRACTVALUE(VALUE(P), '/hint') HINTS,
    ROW_NUMBER () OVER (PARTITION BY SP.SQL_ID, SP.PLAN_HASH_VALUE ORDER BY 1) RN
  FROM
    BASIS_INFO BI,
    DBA_HIST_SQL_PLAN SP,
    ( XMLTABLE('/*/outline_data/hint' PASSING XMLTYPE(OTHER_XML) ) ) P
  WHERE
    SP.SQL_ID LIKE BI.SQL_ID AND
    ( BI.PLAN_HASH = -1 OR SP.PLAN_HASH_VALUE = BI.PLAN_HASH ) AND
    SP.OTHER_XML IS NOT NULL
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d2df12d-014d-1000-804b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_PlanStatistics]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL ACTION, NULL ID, NULL CBO_COSTS, NULL CBO_ROWS, NULL REAL_ROWS,
  NULL ROWS_PER_START, NULL BUFFER_GETS, NULL BG_PER_START, NULL DISK_READS,
  NULL TIME, NULL STARTS, NULL AP, NULL FP FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL ACTION, NULL ID, NULL CBO_COSTS, NULL CBO_ROWS, NULL REAL_ROWS,
  NULL ROWS_PER_START, NULL BUFFER_GETS, NULL BG_PER_START, NULL DISK_READS,
  NULL TIME, NULL STARTS, NULL AP, NULL FP FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    :SQL_ID SQL_ID,
    'X' INCLUDE_PREDICATES
  FROM
    DUAL
)
SELECT
  'SQL_ID: ' || SQL_ID ACTION,
  NULL ID,
  NULL CBO_COSTS,
  NULL CBO_ROWS,
  NULL REAL_ROWS,
  NULL ROWS_PER_START,
  NULL BUFFER_GETS,
  NULL BG_PER_START,
  NULL DISK_READS,
  NULL TIME,
  NULL STARTS, 
  NULL AP,
  NULL FP
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL ACTION,
    NULL ID,
    NULL CBO_COSTS,
    NULL CBO_ROWS,
    NULL REAL_ROWS,
    NULL ROWS_PER_START,
    NULL BUFFER_GETS,
    NULL BG_PER_START,
    NULL DISK_READS,
    NULL TIME,
    NULL STARTS, 
    NULL AP,
    NULL FP
  FROM
    DUAL
)
UNION ALL
( SELECT
    ACTION,
    ID,
    CBO_COSTS,
    CBO_ROWS,
    REAL_ROWS,
    ROWS_PER_START,
    BUFFER_GETS,
    BG_PER_START,
    DISK_READS,
    TIME,
    STARTS,
    ACCESS_PREDICATES AP,
    FILTER_PREDICATES FP
  FROM
  ( SELECT 
      LPAD(' ', PS.DEPTH) || OPERATION || ' ' || 
        OPTIONS || DECODE(OBJECT_NAME, NULL, NULL, ' (' || 
        OBJECT_NAME || ')') ACTION,
      TO_CHAR(PS.ID, 990) ID,
      TO_CHAR(PS.COST, 99999990) CBO_COSTS,
      TO_CHAR(PS.CARDINALITY, 999999990) CBO_ROWS,
      TO_CHAR(PS.LAST_OUTPUT_ROWS, 999999990) REAL_ROWS,
      TO_CHAR(DECODE(PS.LAST_STARTS, 0, 0, ROUND(PS.LAST_OUTPUT_ROWS / PS.LAST_STARTS, 2)), 9999999990.99) ROWS_PER_START,
      TO_CHAR(PS.LAST_CR_BUFFER_GETS + PS.LAST_CU_BUFFER_GETS, 9999999990) BUFFER_GETS,
      TO_CHAR(DECODE(PS.LAST_STARTS, 0, 0, ROUND((PS.LAST_CR_BUFFER_GETS + PS.LAST_CU_BUFFER_GETS) / 
        PS.LAST_STARTS, 2)), 99999990.99) BG_PER_START,
      TO_CHAR(PS.LAST_DISK_READS, 999999990) DISK_READS,
      TO_CHAR(PS.LAST_ELAPSED_TIME, 9999999990) TIME,
      TO_CHAR(PS.LAST_STARTS, 999990) STARTS,
      DECODE(BI.INCLUDE_PREDICATES, 'X', PS.ACCESS_PREDICATES, ' ') ACCESS_PREDICATES,
      DECODE(BI.INCLUDE_PREDICATES, 'X', PS.FILTER_PREDICATES, ' ') FILTER_PREDICATES
    FROM 
      BASIS_INFO BI,
      V$SQL_PLAN_STATISTICS_ALL PS
    WHERE
      PS.SQL_ID = BI.SQL_ID
    ORDER BY 
      PS.CHILD_NUMBER,
      PS.ID
  )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[83uxr1dyhsknn]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d2fc67d-014d-1000-804c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQL_ID_WaitClasses_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /* 11g: V$SQLSTATS_PLAN_HASH */ 
  NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL ELAPSED_MS, NULL "CPU_%", NULL "IO_%",
  NULL "APP_%", NULL "CON_%", NULL "CLU_%", NULL "JVA_%", NULL "PLS_%", NULL "OTH_%"
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL PLAN_HASH, NULL INST, NULL ELAPSED_MS, NULL "CPU_%", NULL "IO_%",
  NULL "APP_%", NULL "CON_%", NULL "CLU_%", NULL "JVA_%", NULL "PLS_%", NULL "OTH_%"
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 22:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 09:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      :SQL_ID SQL_ID
    FROM
      DUAL
  )
),
SNAPSHOTS AS
( SELECT 
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME
  GROUP BY
    HSS.INSTANCE_NUMBER
)
SELECT
  'SQL_ID: ' || SQL_ID BEGIN_TIME,
  NULL PLAN_HASH,
  NULL INST,
  NULL ELAPSED_MS, 
  NULL "CPU_%", 
  NULL "IO_%",
  NULL "APP_%", 
  NULL "CON_%", 
  NULL "CLU_%", 
  NULL "JVA_%",
  NULL "PLS_%",
  NULL "OTH_%"
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL PLAN_HASH,
    NULL INST,
    NULL ELAPSED_MS, 
    NULL "CPU_%", 
    NULL "IO_%",
    NULL "APP_%", 
    NULL "CON_%", 
    NULL "CLU_%", 
    NULL "JVA_%",
    NULL "PLS_%",
    NULL "OTH_%"
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    'V$SQL' BEGIN_TIME,
    TO_CHAR(PLAN_HASH_VALUE, 9999999990) PLAN_HASH,
    TO_CHAR(S.INST_ID, 990) INST,
    TO_CHAR(ELAPSED_TIME / 1000, 9999999990) ELAPSED_MS,
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CPU_TIME / ELAPSED_TIME * 100), 9990) "CPU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, USER_IO_WAIT_TIME / ELAPSED_TIME * 100), 9990) "IO_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, APPLICATION_WAIT_TIME / ELAPSED_TIME * 100), 9990) "APP_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CONCURRENCY_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CON_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CLUSTER_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CLU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, JAVA_EXEC_TIME / ELAPSED_TIME * 100), 9990) "JVA_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, PLSQL_EXEC_TIME / ELAPSED_TIME * 100), 9990) "PLS_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, GREATEST(0, ELAPSED_TIME - CPU_TIME - USER_IO_WAIT_TIME - 
      APPLICATION_WAIT_TIME - CONCURRENCY_WAIT_TIME - CLUSTER_WAIT_TIME - JAVA_EXEC_TIME - 
      PLSQL_EXEC_TIME) / ELAPSED_TIME * 100), 9990) "OTH_%"
  FROM
    BASIS_INFO BI,
    GV$SQL S
  WHERE
    S.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      S.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    'V$SQLSTATS' BEGIN_TIME,
    TO_CHAR(PLAN_HASH_VALUE, 9999999990) PLAN_HASH,
    TO_CHAR(SS.INST_ID, 990) INST,
    TO_CHAR(ELAPSED_TIME / 1000, 9999999990) ELAPSED_MS,
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CPU_TIME / ELAPSED_TIME * 100), 9990) "CPU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, USER_IO_WAIT_TIME / ELAPSED_TIME * 100), 9990) "IO_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, APPLICATION_WAIT_TIME / ELAPSED_TIME * 100), 9990) "APP_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CONCURRENCY_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CON_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CLUSTER_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CLU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, JAVA_EXEC_TIME / ELAPSED_TIME * 100), 9990) "JVA_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, PLSQL_EXEC_TIME / ELAPSED_TIME * 100), 9990) "PLS_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, GREATEST(0, ELAPSED_TIME - CPU_TIME - USER_IO_WAIT_TIME - 
      APPLICATION_WAIT_TIME - CONCURRENCY_WAIT_TIME - CLUSTER_WAIT_TIME - JAVA_EXEC_TIME - 
      PLSQL_EXEC_TIME) / ELAPSED_TIME * 100), 9990) "OTH_%"
  FROM
    BASIS_INFO BI,
    GV$SQLSTATS_PLAN_HASH SS
  WHERE
    SS.SQL_ID = BI.SQL_ID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      SS.INST_ID = BI.INSTANCE_NUMBER )
)
UNION ALL
( SELECT
    'TOTAL (HISTORY)' BEGIN_TIME,
    TO_CHAR(PLAN_HASH_VALUE, 9999999990) PLAN_HASH,
    TO_CHAR(INST_ID, 990) INST,
    TO_CHAR(ELAPSED_TIME / 1000, 9999999990) ELAPSED_MS,
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CPU_TIME / ELAPSED_TIME * 100), 9990) "CPU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, USER_IO_WAIT_TIME / ELAPSED_TIME * 100), 9990) "IO_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, APPLICATION_WAIT_TIME / ELAPSED_TIME * 100), 9990) "APP_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CONCURRENCY_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CON_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CLUSTER_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CLU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, JAVA_EXEC_TIME / ELAPSED_TIME * 100), 9990) "JVA_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, PLSQL_EXEC_TIME / ELAPSED_TIME * 100), 9990) "PLS_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, GREATEST(0, ELAPSED_TIME - CPU_TIME - USER_IO_WAIT_TIME - 
      APPLICATION_WAIT_TIME - CONCURRENCY_WAIT_TIME - CLUSTER_WAIT_TIME - JAVA_EXEC_TIME - 
      PLSQL_EXEC_TIME) / ELAPSED_TIME * 100), 9990) "OTH_%"
  FROM
  ( SELECT
      HSQ.PLAN_HASH_VALUE,
      HSQ.INSTANCE_NUMBER INST_ID,
      SUM(HSQ.ELAPSED_TIME_DELTA) ELAPSED_TIME,
      SUM(HSQ.CPU_TIME_DELTA) CPU_TIME,
      SUM(HSQ.IOWAIT_DELTA) USER_IO_WAIT_TIME,
      SUM(HSQ.APWAIT_DELTA) APPLICATION_WAIT_TIME,
      SUM(HSQ.CCWAIT_DELTA) CONCURRENCY_WAIT_TIME,
      SUM(HSQ.CLWAIT_DELTA) CLUSTER_WAIT_TIME,
      SUM(HSQ.JAVEXEC_TIME_DELTA) JAVA_EXEC_TIME,
      SUM(HSQ.PLSEXEC_TIME_DELTA) PLSQL_EXEC_TIME
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ, 
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    GROUP BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
    ORDER BY
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
UNION ALL
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') BEGIN_TIME,
    TO_CHAR(PLAN_HASH_VALUE, 9999999990) PLAN_HASH,
    TO_CHAR(INST_ID, 990) INST,
    TO_CHAR(ELAPSED_TIME / 1000, 9999999990) ELAPSED_MS,
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CPU_TIME / ELAPSED_TIME * 100), 9990) "CPU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, USER_IO_WAIT_TIME / ELAPSED_TIME * 100), 9990) "IO_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, APPLICATION_WAIT_TIME / ELAPSED_TIME * 100), 9990) "APP_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CONCURRENCY_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CON_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, CLUSTER_WAIT_TIME / ELAPSED_TIME * 100), 9990) "CLU_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, JAVA_EXEC_TIME / ELAPSED_TIME * 100), 9990) "JVA_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, PLSQL_EXEC_TIME / ELAPSED_TIME * 100), 9990) "PLS_%",
    TO_CHAR(DECODE(ELAPSED_TIME, 0, 0, GREATEST(0, ELAPSED_TIME - CPU_TIME - USER_IO_WAIT_TIME - 
      APPLICATION_WAIT_TIME - CONCURRENCY_WAIT_TIME - CLUSTER_WAIT_TIME - JAVA_EXEC_TIME - 
      PLSQL_EXEC_TIME) / ELAPSED_TIME * 100), 9990) "OTH_%"
  FROM
  ( SELECT
      HSS.BEGIN_INTERVAL_TIME,
      HSQ.PLAN_HASH_VALUE,
      HSQ.INSTANCE_NUMBER INST_ID,
      HSQ.ELAPSED_TIME_DELTA ELAPSED_TIME,
      HSQ.CPU_TIME_DELTA CPU_TIME,
      HSQ.IOWAIT_DELTA USER_IO_WAIT_TIME,
      HSQ.APWAIT_DELTA APPLICATION_WAIT_TIME,
      HSQ.CCWAIT_DELTA CONCURRENCY_WAIT_TIME,
      HSQ.CLWAIT_DELTA CLUSTER_WAIT_TIME,
      HSQ.JAVEXEC_TIME_DELTA JAVA_EXEC_TIME,
      HSQ.PLSEXEC_TIME_DELTA PLSQL_EXEC_TIME
    FROM
      BASIS_INFO BI,
      DBA_HIST_SQLSTAT HSQ,
      DBA_HIST_SNAPSHOT HSS,
      SNAPSHOTS SS
    WHERE
      SS.INSTANCE_NUMBER = HSQ.INSTANCE_NUMBER AND
      HSQ.SQL_ID = BI.SQL_ID AND
      HSQ.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER AND
      HSQ.SNAP_ID = HSS.SNAP_ID AND
      HSQ.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID 
    ORDER BY
      HSQ.SNAP_ID DESC,
      HSQ.INSTANCE_NUMBER,
      HSQ.PLAN_HASH_VALUE
  )
)
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[gd90t4t7rw68r]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d30bcdd-014d-1000-804d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQLMonitoring_BindValues_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL SQL_EXEC_START,
  NULL BIND_NAME, NULL BIND_VALUE, NULL BIND_TYPE FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL SQL_EXEC_START,
  NULL BIND_NAME, NULL BIND_VALUE, NULL BIND_TYPE FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SESSION_ID,
    SQL_ID,
    SQL_EXEC_ID,
    STATUS
  FROM
  ( SELECT
      -1 INSTANCE_NUMBER,
      -1 SESSION_ID,
      :SQL_ID SQL_ID,
      -1 SQL_EXEC_ID,
      '%' STATUS    /* EXECUTING, DONE (ERROR), DONE (FIRST N ROWS), DONE (ALL ROWS) or DONE */
    FROM
      DUAL
  )
)
SELECT
  DECODE(BV.POS, 1, TO_CHAR(SM.INST_ID, 990), NULL) INST,
  DECODE(BV.POS, 1, TO_CHAR(SM.SID, 99990), NULL) SID,
  DECODE(BV.POS, 1, SM.SQL_ID, NULL) SQL_ID,
  DECODE(BV.POS, 1, TO_CHAR(SM.SQL_EXEC_ID, 9999999990), NULL) SQL_EXEC_ID,
  DECODE(BV.POS, 1, TO_CHAR(SM.SQL_EXEC_START, 'dd.mm.yyyy hh24:mi:ss'), NULL) SQL_EXEC_START,
  BV.NAME BIND_NAME,
  BV.VALUE BIND_VALUE,
  BV.TYPE BIND_TYPE
FROM
  BASIS_INFO BI,
  GV$SQL_MONITOR SM,
  XMLTABLE
  ( '/binds/bind'
    PASSING XMLTYPE(SM.BINDS_XML)
    COLUMNS NAME VARCHAR2(30) PATH '@name',
            VALUE VARCHAR2(4000) PATH '.',
            TYPE VARCHAR2(15) PATH '@dtystr',
            POS NUMBER PATH '@pos'
  ) BV
WHERE
  ( BI.INSTANCE_NUMBER = -1 OR BI.INSTANCE_NUMBER = SM.INST_ID ) AND
  ( BI.SESSION_ID = -1 OR SM.SID = BI.SESSION_ID ) AND
  SM.BINDS_XML IS NOT NULL AND
  SM.SQL_ID LIKE BI.SQL_ID AND
  ( BI.SQL_EXEC_ID = -1 OR SM.SQL_EXEC_ID = BI.SQL_EXEC_ID ) AND
  SM.STATUS LIKE BI.STATUS 
ORDER BY
  SM.SQL_EXEC_START DESC,
  SM.INST_ID,
  SM.SID,
  SM.SQL_ID,
  SM.SQL_EXEC_ID,
  BV.POS
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d32200c-014d-1000-804e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQLMonitoring_ExecutionPlan_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL PLAN_ID, NULL ACTION_INFO,
  NULL STARTS, NULL RECORDS, NULL IO_READ_MB, NULL WA_TEMP_MB FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL PLAN_ID, NULL ACTION_INFO, 
  NULL STARTS, NULL RECORDS, NULL IO_READ_MB, NULL WA_TEMP_MB FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SQL_ID,
    SESSION_ID,
    SQL_EXEC_ID
  FROM
  ( SELECT
      -2 INSTANCE_NUMBER,              /* -1 for current instance, -2 for all instances */
      -1 SESSION_ID,
      :SQL_ID SQL_ID,
      -1 SQL_EXEC_ID
    FROM DUAL
  )
)
SELECT
  DECODE(SPM.PLAN_LINE_ID, 0, TO_CHAR(SPM.INST_ID, 990), ' ') INST,
  DECODE(SPM.PLAN_LINE_ID, 0, TO_CHAR(SPM.SID, 99990), ' ') SID,
  DECODE(SPM.PLAN_LINE_ID, 0, SPM.SQL_ID, ' ') SQL_ID,
  DECODE(SPM.PLAN_LINE_ID, 0, TO_CHAR(SPM.SQL_EXEC_ID, 9999999990), ' ') SQL_EXEC_ID,
  TO_CHAR(SPM.PLAN_LINE_ID, 999990) PLAN_ID,
  LPAD(' ', SPM.PLAN_DEPTH, ' ') || 
    SPM.PLAN_OPERATION || 
    DECODE(SPM.PLAN_OPTIONS, NULL, NULL, ' ' || SPM.PLAN_OPTIONS || 
    DECODE(SPM.PLAN_OBJECT_NAME, NULL, NULL, ' (' || SPM.PLAN_OBJECT_NAME || ')')) ACTION_INFO,
  TO_CHAR(SPM.STARTS, 9999999990) STARTS,
  TO_CHAR(SPM.OUTPUT_ROWS, 9999999990) RECORDS,
  TO_CHAR(SPM.PHYSICAL_READ_BYTES / 1024 / 1024, 999999990) IO_READ_MB,
  TO_CHAR(SPM.WORKAREA_MAX_TEMPSEG / 1024 / 1024, 999999990) WA_TEMP_MB
FROM
  BASIS_INFO BI,
  GV$SQL_PLAN_MONITOR SPM
WHERE
  ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = SPM.INST_ID ) AND
  SPM.SQL_ID LIKE BI.SQL_ID AND
  ( BI.SESSION_ID = -1 OR SPM.SID = BI.SESSION_ID ) AND
  ( BI.SQL_EXEC_ID = -1 OR SPM.SQL_EXEC_ID = BI.SQL_EXEC_ID )
ORDER BY
  SPM.SQL_EXEC_START DESC,
  SPM.SID,
  SPM.SQL_ID,
  SPM.SQL_EXEC_ID,
  SPM.PLAN_LINE_ID
))]]></sql>
				<binds>
					<bind id="SQL_ID">
						<prompt><![CDATA[SQL_ID]]></prompt>
						<tooltip><![CDATA[SQL_ID]]></tooltip>
						<value><![CDATA[83uxr1dyhsknn]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d328adb-014d-1000-804f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_SQLMonitoring_Overview_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL STATUS, NULL SQL_EXEC_START,
  NULL ELAPSED_S, NULL CPU_S, NULL BUFFER_GETS, 
  NULL DISK_READS, NULL PX_REQ, NULL PX_ALLOC, NULL ERR_MSG
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST, NULL SID, NULL SQL_ID, NULL SQL_EXEC_ID, NULL STATUS, NULL SQL_EXEC_START,
  NULL ELAPSED_S, NULL CPU_S, NULL BUFFER_GETS, 
  NULL DISK_READS, NULL PX_REQ, NULL PX_ALLOC, NULL ERR_MSG
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SESSION_ID,
    SQL_ID,
    ONLY_DOWNGRADES,
    STATUS,
    MIN_ELAPSED_TIME_S,
    MIN_CPU_TIME_S,
    SORT_BY
  FROM
  ( SELECT
      -1 INSTANCE_NUMBER,
      -1 SESSION_ID,
      '%' SQL_ID,
      -1 MIN_ELAPSED_TIME_S,
      -1 MIN_CPU_TIME_S,
      ' ' ONLY_DOWNGRADES,
      '%' STATUS,    /* EXECUTING, DONE (ERROR), DONE (FIRST N ROWS), DONE (ALL ROWS) or DONE */
      'START_TIME' SORT_BY      /* START_TIME, ELAPSED, CPU, BUFFER_GETS, DISK_READS */
    FROM
      DUAL
  )
)
SELECT
  SM.INST_ID INST,
  TO_CHAR(SM.SID, 9990) SID,
  SM.SQL_ID,
  TO_CHAR(SM.SQL_EXEC_ID, 9999999990) SQL_EXEC_ID,
  SM.STATUS,
  TO_CHAR(SM.SQL_EXEC_START, 'dd.mm.yyyy hh24:mi:ss') SQL_EXEC_START,
  TO_CHAR(SM.ELAPSED_TIME / 1000000, 99999990) ELAPSED_S,
  TO_CHAR(SM.CPU_TIME / 1000000, 99999990) CPU_S,
  TO_CHAR(SM.BUFFER_GETS, 99999999990) BUFFER_GETS,
  TO_CHAR(SM.DISK_READS, 999999990) DISK_READS,
  SM.PX_SERVERS_REQUESTED PX_REQ,
  SM.PX_SERVERS_ALLOCATED PX_ALLOC,
  SUBSTR(SM.ERROR_MESSAGE, 1, INSTR(SM.ERROR_MESSAGE, ':') - 1) ERR_MSG
FROM
  BASIS_INFO BI,
  GV$SQL_MONITOR SM
WHERE
  ( BI.INSTANCE_NUMBER = -1 OR BI.INSTANCE_NUMBER = SM.INST_ID ) AND
  ( BI.SESSION_ID = -1 OR SM.SID = BI.SESSION_ID ) AND
  SM.SQL_ID LIKE BI.SQL_ID AND
  SM.STATUS LIKE BI.STATUS AND
  ( BI.MIN_ELAPSED_TIME_S = -1 OR SM.ELAPSED_TIME / 1000000 >= BI.MIN_ELAPSED_TIME_S ) AND
  ( BI.MIN_CPU_TIME_S = -1 OR SM.CPU_TIME / 1000000 >= BI.MIN_CPU_TIME_S ) AND
  ( BI.ONLY_DOWNGRADES = ' ' OR SM.PX_SERVERS_REQUESTED > SM.PX_SERVERS_ALLOCATED )
ORDER BY
  DECODE(BI.SORT_BY, 'START_TIME', SM.SQL_EXEC_START) DESC,
  DECODE(BI.SORT_BY, 'ELAPSED', SM.ELAPSED_TIME, 'CPU', SM.CPU_TIME, 
    'BUFFER_GETS', SM.BUFFER_GETS, 'DISK_READS', SM.DISK_READS) DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d3387b3-014d-1000-8050-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_TempSegments]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST, NULL SID, NULL SQL_ID, NULL TABLESPACE, NULL CONTENTS, NULL SEGTYPE,
  NULL SIZE_MB, NULL "SIZE_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST, NULL SID, NULL SQL_ID, NULL TABLESPACE, NULL CONTENTS, NULL SEGTYPE,
  NULL SIZE_MB, NULL "SIZE_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    -1 INSTANCE_NUMBER,
    '%' SQL_ID,
    -1 SESSION_ID,
    '%' TABLESPACE_NAME,
    '%' CONTENTS,
    '%' SEGTYPE,
    'SQL_ID SEGTYPE TABLESPACE' AGGREGATE_BY,   /* 'SID INSTANCE SQL_ID TABLESPACE CONTENTS SEGTYPE' or substring */
    20 NUM_RECORDS
  FROM
    DUAL
)
SELECT
  INST,
  SID,
  SQL_ID,
  TABLESPACE,
  CONTENTS,
  SEGTYPE,
  TO_CHAR(SIZE_MB, 999990.99) SIZE_MB,
  TO_CHAR(PERCENT, 990.99) "SIZE_%"
FROM
( SELECT
    DECODE(BI.INSTANCE_NUMBER, -1, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'INSTANCE'), 0, 'any', TO_CHAR(TSU.INST_ID)),
      TO_CHAR(TSU.INST_ID)) INST,
    DECODE(BI.SESSION_ID, -1, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SID'), 0, 'any', TO_CHAR(S.SID, 9990)),
      TO_CHAR(S.SID, 9990)) SID,
    DECODE(INSTR(BI.SQL_ID, '%'), 0, TSU.SQL_ID, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_ID'), 0, 'any', TO_CHAR(TSU.SQL_ID))) SQL_ID,
    DECODE(INSTR(BI.TABLESPACE_NAME, '%'), 0, TSU.TABLESPACE, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'TABLESPACE'), 0, 'any', TSU.TABLESPACE)) TABLESPACE,
    DECODE(INSTR(BI.CONTENTS, '%'), 0, TSU.CONTENTS, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'CONTENTS'), 0, 'any', TSU.CONTENTS)) CONTENTS,
    DECODE(INSTR(BI.SEGTYPE, '%'), 0, TSU.SEGTYPE, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SEGTYPE'), 0, 'any', TSU.SEGTYPE)) SEGTYPE,
    SUM(TSU.BLOCKS * TS.BLOCK_SIZE) / 1024 / 1024 SIZE_MB,
    RATIO_TO_REPORT(SUM(TSU.BLOCKS * TS.BLOCK_SIZE)) OVER () * 100 PERCENT,
    BI.NUM_RECORDS
  FROM
    BASIS_INFO BI,
    GV$TEMPSEG_USAGE TSU,
    GV$SESSION S,
    DBA_TABLESPACES TS
  WHERE
    TSU.SQL_ID LIKE BI.SQL_ID AND
    TSU.TABLESPACE LIKE BI.TABLESPACE_NAME AND
    ( BI.INSTANCE_NUMBER = -1 OR
    TSU.INST_ID = BI.INSTANCE_NUMBER ) AND
    TSU.CONTENTS LIKE BI.CONTENTS AND
    TSU.SEGTYPE LIKE BI.SEGTYPE AND
    TSU.INST_ID = S.INST_ID (+) AND
    TSU.SESSION_ADDR = S.SADDR (+) AND
    TSU.TABLESPACE = TS.TABLESPACE_NAME (+)
  GROUP BY
    BI.NUM_RECORDS,
    DECODE(BI.INSTANCE_NUMBER, -1, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'INSTANCE'), 0, 'any', TO_CHAR(TSU.INST_ID)),
      TO_CHAR(TSU.INST_ID)),
    DECODE(BI.SESSION_ID, -1, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SID'), 0, 'any', TO_CHAR(S.SID, 9990)),
      TO_CHAR(S.SID, 9990)),
    DECODE(INSTR(BI.SQL_ID, '%'), 0, TSU.SQL_ID, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SQL_ID'), 0, 'any', TO_CHAR(TSU.SQL_ID))),
    DECODE(INSTR(BI.TABLESPACE_NAME, '%'), 0, TSU.TABLESPACE, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'TABLESPACE'), 0, 'any', TSU.TABLESPACE)),
    DECODE(INSTR(BI.CONTENTS, '%'), 0, TSU.CONTENTS, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'CONTENTS'), 0, 'any', TSU.CONTENTS)),
    DECODE(INSTR(BI.SEGTYPE, '%'), 0, TSU.SEGTYPE, 
      DECODE(INSTR(BI.AGGREGATE_BY, 'SEGTYPE'), 0, 'any', TSU.SEGTYPE))
  ORDER BY
    SUM(TSU.BLOCKS * TS.BLOCK_SIZE) DESC
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d34dd2a-014d-1000-8051-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_TopSegmentsInCursorCache]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL INST, NULL OWNER, NULL SEGMENT_NAME, NULL SQL_STATEMENTS,
  NULL LOGICAL_READS, NULL PHYSICAL_READS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL INST, NULL OWNER, NULL SEGMENT_NAME, NULL SQL_STATEMENTS,
  NULL LOGICAL_READS, NULL PHYSICAL_READS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    -1 INSTANCE_NUMBER,
    30 NUM_RECORDS
  FROM
    DUAL
),
SQL_STATEMENT_OBJECTS AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    OWNER,
    SEGMENT_NAME,
    SQL_STATEMENTS
  FROM
  ( SELECT
      OD.INST_ID,
      OD.TO_OWNER OWNER,
      OD.TO_NAME SEGMENT_NAME,
      COUNT(*) SQL_STATEMENTS,
      BI.NUM_RECORDS
    FROM
      BASIS_INFO BI,
      GV$SQL S,
      GV$OBJECT_DEPENDENCY OD
    WHERE
      ( BI.INSTANCE_NUMBER = -1 OR BI.INSTANCE_NUMBER = S.INST_ID ) AND
      S.INST_ID = OD.INST_ID AND
      S.ADDRESS = OD.FROM_ADDRESS AND
      S.HASH_VALUE = OD.FROM_HASH 
    GROUP BY 
      OD.INST_ID,
      OD.TO_OWNER,
      OD.TO_NAME,
      BI.NUM_RECORDS
    ORDER BY
      COUNT(*) DESC
  )
  WHERE
    ROWNUM <= NUM_RECORDS
) 
SELECT
  INST,
  OWNER,
  SEGMENT_NAME,
  SQL_STATEMENTS,
  LOGICAL_READS,
  PHYSICAL_READS
FROM
( SELECT
    TO_CHAR(SO.INST_ID, 990) INST,
    SO.OWNER,
    SO.SEGMENT_NAME,
    TO_CHAR(SO.SQL_STATEMENTS, 9999999999990) SQL_STATEMENTS,
    TO_CHAR(SUM(DECODE(SS.STATISTIC_NAME, 'logical reads', 
      VALUE, 0)), 999999999990) LOGICAL_READS,
    TO_CHAR(SUM(DECODE(SS.STATISTIC_NAME, 'physical reads', 
      VALUE, 0)), 9999999999990) PHYSICAL_READS  
  FROM
    SQL_STATEMENT_OBJECTS SO,
    GV$SEGSTAT SS,
    DBA_OBJECTS O
  WHERE
    SO.INST_ID = SS.INST_ID AND
    SO.OWNER = O.OWNER AND
    SO.SEGMENT_NAME = O.OBJECT_NAME AND
    O.OBJECT_ID = SS.OBJ# AND
    O.DATA_OBJECT_ID = SS.DATAOBJ# AND
    SS.STATISTIC_NAME IN ('logical reads', 'physical reads')
  GROUP BY
    SO.INST_ID,
    SO.OWNER,
    SO.SEGMENT_NAME,
    SO.SQL_STATEMENTS
  ORDER BY
    SQL_STATEMENTS DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d35cc23-014d-1000-8052-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_TopSQLInASH]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL SQL_ID, NULL COMMAND, NULL ASH_POS, NULL ASH_TIME_S, NULL HIST_POS,
  NULL HIST_TIME_S, NULL SQLSTATS_POS, NULL SQLSTATS_TIME_S, NULL SQL_POS,
  NULL SQL_TIME_S FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SQL_ID, NULL COMMAND, NULL ASH_POS, NULL ASH_TIME_S, NULL HIST_POS,
  NULL HIST_TIME_S, NULL SQLSTATS_POS, NULL SQLSTATS_TIME_S, NULL SQL_POS,
  NULL SQL_TIME_S FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    NUM_RECORDS
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 00:00:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 01:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      100 NUM_RECORDS
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.END_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND
    ( BI.END_SNAP_ID = -1 OR HSS.SNAP_ID <= BI.END_SNAP_ID )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
)
SELECT
  'BEGIN: ' || TO_CHAR(BEGIN_TIME, 'dd.mm.yyyy') SQL_ID,
  TO_CHAR(BEGIN_TIME, 'hh24:mi:ss') COMMAND,
  NULL ASH_POS,
  NULL ASH_TIME_S,
  NULL HIST_POS,
  NULL HIST_TIME_S,
  NULL SQLSTATS_POS,
  NULL SQLSTATS_TIME_S,
  NULL SQL_POS,
  NULL SQL_TIME_S
FROM
  SNAPSHOTS
UNION ALL
( SELECT
    'END:   ' || TO_CHAR(END_TIME, 'dd.mm.yyyy') SQL_ID,
    TO_CHAR(END_TIME, 'hh24:mi:ss') COMMAND,
    NULL ASH_POS,
    NULL ASH_TIME_S,
    NULL HIST_POS,
    NULL HIST_TIME_S,
    NULL SQLSTATS_POS,
    NULL SQLSTATS_TIME_S,
    NULL SQL_POS,
    NULL SQL_TIME_S
  FROM
    SNAPSHOTS
)
UNION ALL
( SELECT
    'INSTANCE: ' SQL_ID,
    TO_CHAR(INSTANCE_NUMBER) COMMAND,
    NULL ASH_POS,
    NULL ASH_TIME_S,
    NULL HIST_POS,
    NULL HIST_TIME_S,
    NULL SQLSTATS_POS,
    NULL SQLSTATS_TIME_S,
    NULL SQL_POS,
    NULL SQL_TIME_S
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    NULL SQL_ID,
    NULL COMMAND,
    NULL ASH_POS,
    NULL ASH_TIME_S,
    NULL HIST_POS,
    NULL HIST_TIME_S,
    NULL SQLSTATS_POS,
    NULL SQLSTATS_TIME_S,
    NULL SQL_POS,
    NULL SQL_TIME_S
  FROM
    SNAPSHOTS
)
UNION ALL
( SELECT
    SQL_ID,
    COMMAND,
    TO_CHAR(ROWNUM, 999990) ASH_POS,
    TO_CHAR(ASH_SAMPLES * 10, 999999990) ASH_TIME_S,
    TO_CHAR(HIST_POS, 9999990) HIST_POS,
    TO_CHAR(HIST_TIME_S, 9999999990) HIST_TIME_S,
    TO_CHAR(SQLSTATS_POS, 99999999990) SQLSTATS_POS,
    TO_CHAR(SQLSTATS_TIME_S, 99999999999990) SQLSTATS_TIME_S,
    TO_CHAR(SQL_POS, 999990) SQL_POS,
    TO_CHAR(SQL_TIME_S, 999999990) SQL_TIME_S
  FROM
  ( SELECT
      ASH.SQL_ID SQL_ID,
      DECODE (MIN(A.NAME),
        'ALTER INDEX',    'AI',
        'ALTER TABLE',    'AT',
        'ANALYZE INDEX',  'NI',
        'ANALYZE TABLE',  'NT',
        'CREATE INDEX',   'CI',
        'CALL METHOD',    'CM',
        'CREATE TABLE',   'CT',
        'DELETE',         'DE',
        'EXPLAIN',        'EX',
        'INSERT',         'IN',
        'LOCK',           'LO',
        'PL/SQL EXECUTE', 'PL',
        'SELECT',         'SE',
        'UPDATE',         'UP',
        MIN(A.NAME)) COMMAND,
      COUNT(*) ASH_SAMPLES,
      HIST_POS,
      HIST_TIME_S,
      SQLSTATS_POS,
      SQLSTATS_TIME_S,
      SQL_POS,
      SQL_TIME_S
    FROM
      AUDIT_ACTIONS A,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH, 
      SNAPSHOTS SNS,
      ( SELECT
          SQL_ID,
          HIST_TIME_S,
          ROWNUM HIST_POS
        FROM
        ( SELECT 
            HSS.SQL_ID SQL_ID,
            ROUND(SUM(HSS.ELAPSED_TIME_DELTA) / 1000000) HIST_TIME_S
          FROM 
            DBA_HIST_SQLSTAT HSS,
            SNAPSHOTS SS
          WHERE 
            HSS.DBID = SS.DBID AND
            HSS.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
            HSS.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID
          GROUP BY
            HSS.SQL_ID
          ORDER BY
            2 DESC
        )
      ) HSS,
      ( SELECT
          SQL_ID,
          SQLSTATS_TIME_S,
          ROWNUM SQLSTATS_POS
        FROM
        ( SELECT 
            SQL_ID,
            ROUND(ELAPSED_TIME / 1000000) SQLSTATS_TIME_S
          FROM 
            BASIS_INFO BI,
            GV$SQLSTATS SS
          WHERE
            BI.INSTANCE_NUMBER = SS.INST_ID
          ORDER BY
            2 DESC
        )
      ) SS,
      ( SELECT
          SQL_ID,
          SQL_TIME_S,
          ROWNUM SQL_POS
        FROM
        ( SELECT 
            SQL_ID,
            ROUND(SUM(ELAPSED_TIME) / 1000000) SQL_TIME_S
          FROM 
            BASIS_INFO BI,
            GV$SQL S
          WHERE
            BI.INSTANCE_NUMBER = S.INST_ID
          GROUP BY
            SQL_ID
          ORDER BY
            2 DESC
        )
      ) S
    WHERE
      ASH.DBID = SNS.DBID AND
      ASH.INSTANCE_NUMBER = SNS.INSTANCE_NUMBER AND
      ASH.SQL_OPCODE = A.ACTION (+) AND
      ASH.SQL_ID = HSS.SQL_ID(+) AND
      ASH.SQL_ID = SS.SQL_ID (+) AND
      ASH.SQL_ID = S.SQL_ID (+) AND
      ASH.SQL_ID IS NOT NULL AND
      ASH.SNAP_ID BETWEEN SNS.BEGIN_SNAP_ID AND SNS.END_SNAP_ID
    GROUP BY
      ASH.SQL_ID,
      HIST_POS,
      HIST_TIME_S,
      SQLSTATS_POS,
      SQLSTATS_TIME_S,
      SQL_POS,
      SQL_TIME_S
    ORDER BY
      COUNT(*) DESC 
  ) A,
  BASIS_INFO BI
  WHERE
    ( BI.NUM_RECORDS = -1 OR ROWNUM <= BI.NUM_RECORDS )
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<folder>
			<name><![CDATA[TopSQLPerAWRInterval]]></name>
			<tooltip><![CDATA[]]></tooltip>
			<description><![CDATA[]]></description>
				<display id="2d3c26a7-014d-1000-8053-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Buffer Gets]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Buffer Gets' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3c9707-014d-1000-8054-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Elapsed Time (s)]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Elapsed Time (s)' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3d1007-014d-1000-8055-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Executions]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Executions' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3d5b26-014d-1000-8056-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Records]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Records' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3eadbe-014d-1000-8057-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Disk Reads]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Disk Reads' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3f18f6-014d-1000-8058-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[CPU Time (s)]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'CPU Time (s)' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
			<display id="2d3f7e5d-014d-1000-8059-7f0000014ee2" type="" style="Table" enable="true">
				<name><![CDATA[Cluster Time (s)]]></name>
				<description><![CDATA[]]></description>
				<tooltip><![CDATA[]]></tooltip>
				<drillclass><![CDATA[null]]></drillclass>
				<CustomValues>
					<TYPE>horizontal</TYPE>
				</CustomValues>
				<query>
					<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL VALUE_TOTAL, NULL VALUE_PER_S, 
  NULL SQL_ID_1, NULL VALUE_1, NULL PCT_1, NULL SQL_ID_2, 
  NULL VALUE_2, NULL PCT_2, NULL SQL_ID_3, NULL VALUE_3, 
  NULL PCT_3, NULL SQL_ID_4, NULL VALUE_4, NULL PCT_4, 
  NULL SQL_ID_5, NULL VALUE_5, NULL PCT_5
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    KEY_FIGURE
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 03:55:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 05:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   
      -1 END_SNAP_ID,
      'Cluster Time (s)' KEY_FIGURE
        /* 'Elapsed Time (s)', 'Executions', 'Records', 'Disk Reads', 
           'Buffer Gets', 'CPU Time (s)', 'Direct Writes' 'Cluster Time (s)', 'PX Servers' */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER INST_ID,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME,
    HSS.END_INTERVAL_TIME,
    TO_CHAR(HSS.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS
  WHERE
    BI.DBID = HSS.DBID AND
    ( BI.INSTANCE_NUMBER = -2 OR
      BI.INSTANCE_NUMBER = HSS.INSTANCE_NUMBER ) AND
    HSS.BEGIN_INTERVAL_TIME >= BI.BEGIN_TIME AND 
    HSS.END_INTERVAL_TIME <= BI.END_TIME
)
SELECT
  'KEY FIGURE:' BEGIN_TIME,
  KEY_FIGURE VALUE_TOTAL,
  NULL VALUE_PER_S,
  NULL SQL_ID_1,
  NULL VALUE_1,
  NULL PCT_1,
  NULL SQL_ID_2,
  NULL VALUE_2,
  NULL PCT_2,
  NULL SQL_ID_3,
  NULL VALUE_3,
  NULL PCT_3,
  NULL SQL_ID_4,
  NULL VALUE_4,
  NULL PCT_4,
  NULL SQL_ID_5,
  NULL VALUE_5,
  NULL PCT_5
FROM
  BASIS_INFO
UNION ALL
( SELECT
    NULL BEGIN_TIME,
    NULL VALUE_TOTAL,
    NULL VALUE_PER_S,
    NULL SQL_ID_1,
    NULL VALUE_1,
    NULL PCT_1,
    NULL SQL_ID_2,
    NULL VALUE_2,
    NULL PCT_2,
    NULL SQL_ID_3,
    NULL VALUE_3,
    NULL PCT_3,
    NULL SQL_ID_4,
    NULL VALUE_4,
    NULL PCT_4,
    NULL SQL_ID_5,
    NULL VALUE_5,
    NULL PCT_5
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
      TO_CHAR(VALUE_TOTAL, 99999999999999990) VALUE_TOTAL,
      TO_CHAR(VALUE_PER_S, 9999990.99) VALUE_PER_S,
      SQL_ID_1,
      TO_CHAR(VALUE_1, 999999990) VALUE_1,
      TO_CHAR(PCT_1, 990.99) PCT_1,
      SQL_ID_2,
      TO_CHAR(VALUE_2, 999999990) VALUE_2,
      TO_CHAR(PCT_2, 990.99) PCT_2,
      SQL_ID_3,
      TO_CHAR(VALUE_3, 999999990) VALUE_3,
      TO_CHAR(PCT_3, 990.99) PCT_3,
      SQL_ID_4,
      TO_CHAR(VALUE_4, 999999990) VALUE_4,
      TO_CHAR(PCT_4, 990.99) PCT_4,
      SQL_ID_5,
      TO_CHAR(VALUE_5, 999999990) VALUE_5,
      TO_CHAR(PCT_5, 990.99) PCT_5
    FROM
    ( SELECT DISTINCT
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) VALUE_TOTAL,
        SUM(SUM(VALUE)) OVER (PARTITION BY SNAP_ID) / MAX(INTERVAL_SECONDS) VALUE_PER_S,
        NTH_VALUE(SQL_ID, 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_1,
        NTH_VALUE(SUM(VALUE), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_1,
        NTH_VALUE(SUM(PERCENT), 1) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_1,
        NTH_VALUE(SQL_ID, 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_2,
        NTH_VALUE(SUM(VALUE), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_2,
        NTH_VALUE(SUM(PERCENT), 2) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_2,
        NTH_VALUE(SQL_ID, 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_3,
        NTH_VALUE(SUM(VALUE), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_3,
        NTH_VALUE(SUM(PERCENT), 3) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_3,
        NTH_VALUE(SQL_ID, 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_4,
        NTH_VALUE(SUM(VALUE), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_4,
        NTH_VALUE(SUM(PERCENT), 4) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_4,
        NTH_VALUE(SQL_ID, 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) SQL_ID_5,
        NTH_VALUE(SUM(VALUE), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) VALUE_5,
        NTH_VALUE(SUM(PERCENT), 5) OVER (PARTITION BY SNAP_ID ORDER BY SUM(VALUE) DESC 
          ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) PCT_5
      FROM
      ( SELECT
          BEGIN_INTERVAL_TIME,
          SNAP_ID,
          INTERVAL_SECONDS,
          SQL_ID,
          VALUE,
          RATIO_TO_REPORT(VALUE) OVER (PARTITION BY SNAP_ID) * 100 PERCENT
        FROM
        ( SELECT
            SS.BEGIN_INTERVAL_TIME,
            SS.SNAP_ID,
            SS.INTERVAL_SECONDS,
            S.SQL_ID,
            DECODE ( BI.KEY_FIGURE,
              'Elapsed Time (s)', S.ELAPSED_TIME_DELTA / 1000000,
              'Executions', S.EXECUTIONS_DELTA,
              'Records', S.ROWS_PROCESSED_DELTA,
              'Disk Reads', S.DISK_READS_DELTA,
              'Buffer Gets', S.BUFFER_GETS_DELTA,
              'CPU Time (s)', S.CPU_TIME_DELTA / 1000000,
              'Direct Writes', S.DIRECT_WRITES_DELTA,
              'Cluster Time (s)', S.CLWAIT_DELTA / 1000000,
              'PX Servers', S.PX_SERVERS_EXECS_DELTA ) VALUE
          FROM
            BASIS_INFO BI,
            SNAPSHOTS SS,
            DBA_HIST_SQLSTAT S
          WHERE
            SS.DBID = S.DBID AND
            SS.INST_ID = S.INSTANCE_NUMBER AND
            SS.SNAP_ID = S.SNAP_ID
        )
      )
      GROUP BY
        BEGIN_INTERVAL_TIME,
        SNAP_ID,
        SQL_ID
    )
    ORDER BY
      SNAP_ID DESC
  )
)
))]]></sql>
				</query>
					<pdf version="VERSION_1_7" compression="CONTENT">
						<docproperty title="null" author="null" subject="null" keywords="null" />
						<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
						<column>
							<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
							<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
							<blob blob="NONE" zip="false" />
						</column>
						<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
						<header enable="false" generatedate="false">
							<data>
							null							</data>
						</header>
						<footer enable="false" generatedate="false">
							<data value="null" />
						</footer>
						<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
							<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
						</security>
						<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
					</pdf>
			</display>
		</folder>
		<display id="2d42036c-014d-1000-805a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_UsedHints]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL HINT, NULL NUM_SQL, NULL SQL_ID_EXAMPLE, NULL MODULE 
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL HINT, NULL NUM_SQL, NULL SQL_ID_EXAMPLE, NULL MODULE 
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT
    '%' MODULE
  FROM
    DUAL
)
SELECT
  HINT,
  TO_CHAR(COUNT(*), 999990) NUM_SQL,
  MIN(SQL_ID) SQL_ID_EXAMPLE,
  MODULE
FROM
( SELECT
    UPPER(REGEXP_REPLACE(S.SQL_TEXT, '.*[/][*][+] ([^*]+)[*][/].*', 
      '\1', 1, 1, 'i')) HINT,
    S.SQL_ID,
    S.MODULE,
    S.ACTION
  FROM
    BASIS_INFO BI,
    V$SQL S
  WHERE
    S.SQL_TEXT LIKE '%/*' || '+' || '%*/%' AND
    UPPER(S.SQL_TEXT) NOT LIKE '%/*' || '+' || ' FIRST_ROWS(%' AND
    UPPER(S.SQL_TEXT) NOT LIKE '%/*' || '+' || ' FIRST_ROWS (%' AND
    UPPER(S.SQL_TEXT) NOT LIKE '%/* OPT_DYN_SAMP%' AND
    NOT ( S.MODULE = 'CL_SQL_STATEMENT==============CP' AND
          UPPER(S.SQL_TEXT) LIKE '%/*' || '+' || ' MATERIALIZE%' ) AND
    S.MODULE IS NOT NULL AND
    S.MODULE LIKE BI.MODULE
)
GROUP BY
  HINT,
  MODULE,
  ACTION
ORDER BY
  HINT,
  MODULE,
  ACTION
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d42b50c-014d-1000-805b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SQL_Workareas]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TYPE, NULL SQL_ID, NULL SID, NULL ID, NULL OPERATION_TYPE, NULL PGA_MB, NULL MAX_PGA_MB,
  NULL TEMP_MB, NULL MAX_TEMP_MB, NULL NUM_PASSES, NULL OPTIMAL, NULL ONEPASS, NULL MULTIPASS FROM DUAL
  WHERE 1 = 0
UNION ALL (
SELECT NULL TYPE, NULL SQL_ID, NULL SID, NULL ID, NULL OPERATION_TYPE, NULL PGA_MB, NULL MAX_PGA_MB,
  NULL TEMP_MB, NULL MAX_TEMP_MB, NULL NUM_PASSES, NULL OPTIMAL, NULL ONEPASS, NULL MULTIPASS FROM DUAL
  WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SQL_ID,
    SID,
    WA_TYPE,
    TEMP_MB_LIMIT,
    PGA_MB_LIMIT,
    NUM_RECORDS,
    ORDER_BY,
    ONLY_MULTIPASSES
  FROM
  ( SELECT
      '%' SQL_ID,
      -1 SID,
      -1 INSTANCE_NUMBER,
      'ACTIVE' WA_TYPE,       /* ALL, INACTIVE, ACTIVE */
      -1 TEMP_MB_LIMIT,
      -1 PGA_MB_LIMIT,
      30 NUM_RECORDS,
      'TEMP_MB' ORDER_BY,        /* TEMP_MB, PGA_MB */
      ' ' ONLY_MULTIPASSES
    FROM
      DUAL
   )
)
SELECT
  TYPE,
  SQL_ID,
  SID,
  ID,
  OPERATION_TYPE,
  PGA_MB,
  MAX_PGA_MB,
  TEMP_MB,
  MAX_TEMP_MB,
  NUM_PASSES,
  OPTIMAL,
  ONEPASS,
  MULTIPASS
FROM
( SELECT
    TYPE,
    SQL_ID,
    DECODE(SID, -1, '  n/a', TO_CHAR(SID, 9990)) SID,
    TO_CHAR(ID, 990) ID,
    OPERATION_TYPE,
    TO_CHAR(PGA_MB, 99990.99) PGA_MB,
    DECODE(MAX_PGA_MB, -1, '       n/a', TO_CHAR(MAX_PGA_MB, 999990.99)) MAX_PGA_MB,
    TO_CHAR(TEMP_MB, 999990.99) TEMP_MB,
    DECODE(MAX_TEMP_MB, -1, '        n/a', TO_CHAR(MAX_TEMP_MB, 9999990.99)) MAX_TEMP_MB,
    DECODE(NUM_PASSES, -1, '       n/a', TO_CHAR(NUM_PASSES, 999999990)) NUM_PASSES,
    DECODE(OPTIMAL, -1, '      n/a', TO_CHAR(OPTIMAL, 99999990)) OPTIMAL,
    DECODE(ONEPASS, -1, '    n/a', TO_CHAR(ONEPASS, 999990)) ONEPASS,
    DECODE(MULTIPASS, -1, '      n/a', TO_CHAR(MULTIPASS, 99999990)) MULTIPASS,
    NUM_RECORDS
  FROM
  ( SELECT
      'INACTIVE' TYPE,
      SW.SQL_ID,
      -1 SID,
      OPERATION_ID ID,
      OPERATION_TYPE,
      LAST_MEMORY_USED / 1024 / 1024 PGA_MB,
      -1 MAX_PGA_MB,
      NVL(LAST_TEMPSEG_SIZE, 0) / 1024 / 1024 TEMP_MB,
      NVL(MAX_TEMPSEG_SIZE, 0) / 1024 / 1024 MAX_TEMP_MB,
      -1 NUM_PASSES,
      OPTIMAL_EXECUTIONS OPTIMAL,
      ONEPASS_EXECUTIONS ONEPASS,
      MULTIPASSES_EXECUTIONS MULTIPASS,
      BI.ORDER_BY,
      BI.NUM_RECORDS
    FROM
      BASIS_INFO BI,
      GV$SQL_WORKAREA SW
    WHERE
      BI.INSTANCE_NUMBER = SW.INST_ID AND
      SW.SQL_ID LIKE BI.SQL_ID AND
      BI.SID = -1 AND
      BI.WA_TYPE IN ('ALL', 'INACTIVE') AND
      ( BI.TEMP_MB_LIMIT = -1 OR 
        SW.LAST_TEMPSEG_SIZE / 1024 / 1024 >= BI.TEMP_MB_LIMIT OR
        SW.MAX_TEMPSEG_SIZE / 1024 / 1024 >= BI.TEMP_MB_LIMIT
      ) AND
      ( BI.PGA_MB_LIMIT = -1 OR
        SW.LAST_MEMORY_USED / 1024 / 1024 >= BI.PGA_MB_LIMIT
      ) AND
      ( BI.ONLY_MULTIPASSES = ' ' OR MULTIPASSES_EXECUTIONS > 0 )
    UNION ALL
    ( SELECT
        'ACTIVE' TYPE,
        SW.SQL_ID,
        SW.SID,
        OPERATION_ID ID,
        OPERATION_TYPE,
        ACTUAL_MEM_USED / 1024 / 1024 PGA_MB,
        MAX_MEM_USED / 1024 / 1024 MAX_PGA_MB,
        NVL(TEMPSEG_SIZE, 0) / 1024 / 1024 TEMP_MB,
        -1 MAX_TEMP_MB,
        NUMBER_PASSES NUM_PASSES,
        -1 OPTIMAL,
        -1 ONEPASS,
        -1 MULTIPASS,
        BI.ORDER_BY,
        BI.NUM_RECORDS
      FROM
        BASIS_INFO BI,
        GV$SQL_WORKAREA_ACTIVE SW
      WHERE
        BI.INSTANCE_NUMBER = SW.INST_ID AND
        SW.SQL_ID LIKE BI.SQL_ID AND
        ( BI.SID = -1 OR SW.SID = BI.SID ) AND
        BI.WA_TYPE IN ('ALL', 'ACTIVE') AND
        ( BI.TEMP_MB_LIMIT = -1 OR 
          SW.TEMPSEG_SIZE / 1024 / 1024 >= BI.TEMP_MB_LIMIT 
        ) AND
        ( BI.PGA_MB_LIMIT = -1 OR
          SW.ACTUAL_MEM_USED / 1024 / 1024 >= BI.PGA_MB_LIMIT OR
          SW.MAX_MEM_USED / 1024 / 1024 >= BI.PGA_MB_LIMIT 
        ) AND
        BI.ONLY_MULTIPASSES = ' '
    )
  ) S
  ORDER BY
    DECODE(ORDER_BY, 
      'PGA_MB', GREATEST(S.PGA_MB, S.MAX_PGA_MB), 
      'TEMP_MB', GREATEST(S.TEMP_MB, S.MAX_TEMP_MB)) DESC
)
WHERE
  ( NUM_RECORDS = -1 OR ROWNUM <= NUM_RECORDS )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[SystemStat]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2d448203-014d-1000-805c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemMetrics_KeySysmetrics]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL TIME_INTERVAL, NULL "HITRATIO_%", NULL "COMMITS_PER_S", NULL "CPU_%",
  NULL "READ_MB_PER_S", NULL "WRITE_MB_PER_S", NULL "READS_PER_USER_CALL", NULL "USER_CALLS_PER_S", 
  NULL "REDO_MB_PER_S", NULL "NETWORK_MB_PER_S", NULL "HARD_PARSE_PER_S" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL TIME_INTERVAL, NULL "HITRATIO_%", NULL "COMMITS_PER_S", NULL "CPU_%",
  NULL "READ_MB_PER_S", NULL "WRITE_MB_PER_S", NULL "READS_PER_USER_CALL", NULL "USER_CALLS_PER_S", 
  NULL "REDO_MB_PER_S", NULL "NETWORK_MB_PER_S", NULL "HARD_PARSE_PER_S" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    AREA
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      'CURRENT' AREA       /* CURRENT, HISTORY or ALL */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
)
SELECT 
  TIME_INTERVAL,
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Buffer Cache Hit Ratio', VALUE, 0)), 999990.99) "HITRATIO_%",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'User Commits Per Sec', VALUE, 0)), 999999990.99) "COMMITS_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Host CPU Utilization (%)', VALUE, 0)), 990.99) "CPU_%",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Physical Read Bytes Per Sec', VALUE, 0)) / 1024 / 1024, 999999990.99) "READ_MB_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Physical Write Bytes Per Sec', VALUE, 0)) / 1024 / 1024, 9999999990.99) "WRITE_MB_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Logical Reads Per User Call', VALUE, 0)), 999999999999990.99) "READS_PER_USER_CALL",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'User Calls Per Sec', VALUE, 0)), 999999999990.99) "USER_CALLS_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Redo Generated Per Sec', VALUE, 0) / 1024 / 1024), 999999990.99) "REDO_MB_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Network Traffic Volume Per Sec', VALUE, 0) / 1024 / 1024), 999999999990.99) "NETWORK_MB_PER_S",
  TO_CHAR(SUM(DECODE(METRIC_NAME, 'Hard Parse Count Per Sec', VALUE, 0)), 999999999990.99) "HARD_PARSE_PER_S"
FROM
  ( SELECT
      TO_CHAR(BEGIN_TIME, 'YYYY-MM-DD HH24:MI:SS') || ' - ' ||
        TO_CHAR(END_TIME, 'YYYY-MM-DD HH24:MI:SS') TIME_INTERVAL,
      METRIC_NAME,
      VALUE
    FROM
      BASIS_INFO BI,
      GV$SYSMETRIC_HISTORY SMH
    WHERE
      BI.INSTANCE_NUMBER = SMH.INST_ID AND
      SMH.GROUP_ID = 2 AND
      BI.AREA IN ('CURRENT', 'ALL')
    UNION
    ( SELECT
        TO_CHAR(BEGIN_TIME, 'YYYY-MM-DD HH24:MI:SS') || ' - ' ||
          TO_CHAR(END_TIME, 'YYYY-MM-DD HH24:MI:SS') TIME_INTERVAL,
        METRIC_NAME,
        VALUE  
      FROM
        BASIS_INFO BI,
        DBA_HIST_SYSMETRIC_HISTORY HSH
      WHERE
        BI.DBID = HSH.DBID AND
        BI.INSTANCE_NUMBER = HSH.INSTANCE_NUMBER AND
        GROUP_ID = 2 AND
        BI.AREA IN ('HISTORY', 'ALL')
    )
  )
GROUP BY
  TIME_INTERVAL
ORDER BY
  TIME_INTERVAL DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d466703-014d-1000-805d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_ChainedRows]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT 
  NULL BEGIN_TIME, NULL ROWID_FETCHES_PER_S, NULL CHAINED_ROW_FETCHES_PER_S,
  NULL "CHAINED_ROW_FETCHES_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT 
  NULL BEGIN_TIME, NULL ROWID_FETCHES_PER_S, NULL CHAINED_ROW_FETCHES_PER_S,
  NULL "CHAINED_ROW_FETCHES_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(DECODE(SECONDS, 0, 0, ROWID_FETCHES / SECONDS), 
    999999999999999990) ROWID_FETCHES_PER_S,
  TO_CHAR(DECODE(SECONDS, 0, 0, CHAINED_ROW_FETCHES / SECONDS), 
    999999999999999999999990) CHAINED_ROW_FETCHES_PER_S,
  TO_CHAR(DECODE(ROWID_FETCHES, 0, 0, CHAINED_ROW_FETCHES / ROWID_FETCHES * 100), 
    99999999999999990.99) "CHAINED_ROW_FETCHES_%"
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(ROWID_FETCHES) ROWID_FETCHES,
    SUM(CHAINED_ROW_FETCHES) CHAINED_ROW_FETCHES
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) ROWID_FETCHES,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CHAINED_ROW_FETCHES,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'table fetch by rowid' AND
      HSY2.STAT_NAME = 'table fetch continued row'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d47054a-014d-1000-805e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_ConsistentGets]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL GETS_PER_S, NULL CACHED_PER_S,
  NULL "CACHED_%", NULL DIRECT_PER_S, NULL "DIRECT_%", NULL CONS_CHNG_PER_S, 
  NULL "CONS_CHNG_%" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL GETS_PER_S, NULL CACHED_PER_S,
  NULL "CACHED_%", NULL DIRECT_PER_S, NULL "DIRECT_%", NULL CONS_CHNG_PER_S, 
  NULL "CONS_CHNG_%" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(DECODE(SECONDS, 0, 0, TOTAL_GETS / SECONDS), 
    999999990) TOTAL_PER_S,
  TO_CHAR(DECODE(SECONDS, 0, 0, CACHED_GETS / SECONDS), 
    99999999990) CACHED_PER_S,
  TO_CHAR(DECODE(TOTAL_GETS, 0, 0, CACHED_GETS / TOTAL_GETS * 100), 
    9990.99) "CACHED_%",
  TO_CHAR(DECODE(SECONDS, 0, 0, DIRECT_GETS / SECONDS), 
    99999999990) DIRECT_PER_S,
  TO_CHAR(DECODE(TOTAL_GETS, 0, 0, DIRECT_GETS / TOTAL_GETS * 100), 
    9990.99) "DIRECT_%",
  TO_CHAR(DECODE(SECONDS, 0, 0, CONSISTENT_CHANGES / SECONDS), 
    99999999999990) CONS_CHNG_PER_S,
  TO_CHAR(DECODE(TOTAL_GETS, 0, 0, CONSISTENT_CHANGES / TOTAL_GETS * 100), 
    9999990.99) "CONS_CHNG_%"
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(TOTAL_GETS) TOTAL_GETS,
    SUM(CACHED_GETS) CACHED_GETS,
    SUM(DIRECT_GETS) DIRECT_GETS,
    SUM(CONSISTENT_CHANGES) CONSISTENT_CHANGES
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) TOTAL_GETS,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CACHED_GETS,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DIRECT_GETS,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CONSISTENT_CHANGES,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'consistent gets' AND
      HSY2.STAT_NAME = 'consistent gets from cache' AND
      HSY3.STAT_NAME = 'consistent gets direct' AND
      HSY4.STAT_NAME = 'consistent changes' 
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4a81e0-014d-1000-805f-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_DBWR]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL TOTAL_MB_PER_S, NULL APP_MB_PER_S, NULL "CACHE_%",
  NULL "UNDO_%", NULL KB_PER_REQ, NULL CHECKPOINTS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL TOTAL_MB, NULL APP_MB, NULL "CACHE_%",
  NULL "UNDO_%", NULL KB_PER_REQ, NULL CHECKPOINTS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(TOTAL_MB / SECONDS, 9999999990.99) TOTAL_MB_PER_S,
    /* Difference between TOTAL and APP: External tools, difference data vs. block size */
  TO_CHAR(APP_MB / SECONDS, 9999999990.99) APP_MB_PER_S,
  TO_CHAR(CACHE_MB / APP_MB * 100, 990.99) "CACHE_%",
  TO_CHAR(UNDO_MB / APP_MB * 100, 990.99) "UNDO_%",
  TO_CHAR(APP_MB / REQUESTS * 1024, 999990.99) KB_PER_REQ,
  TO_CHAR(CHECKPOINTS, 9999999990) CHECKPOINTS
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(TOTAL_MB) TOTAL_MB,
    SUM(APP_MB) APP_MB, 
    SUM(CACHE_MB) CACHE_MB,
    SUM(REQUESTS) REQUESTS,
    SUM(UNDO_MB) UNDO_MB,
    SUM(CHECKPOINTS) CHECKPOINTS
  FROM    
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1024 / 1024 TOTAL_MB,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1024 / 1024 APP_MB,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) * 8192 / 1024 / 1024 CACHE_MB,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) REQUESTS,
      DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
        LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) * 8192 / 1024 / 1024 UNDO_MB,
      DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
        LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CHECKPOINTS,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4,
      DBA_HIST_SYSSTAT HSY5,
      DBA_HIST_SYSSTAT HSY6
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY5.DBID = SS.DBID AND
      HSY6.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY5.SNAP_ID = SS.SNAP_ID AND
      HSY6.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'physical write total bytes' AND
      HSY2.STAT_NAME = 'physical write bytes' AND
      HSY3.STAT_NAME = 'physical writes from cache' AND
      HSY4.STAT_NAME = 'physical write IO requests' AND
      HSY5.STAT_NAME = 'DBWR undo block writes' AND
      HSY6.STAT_NAME = 'DBWR checkpoints'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4ad919-014d-1000-8060-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_CPU]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL TIME_MODEL_TOTAL_S, NULL SYSSTAT_TOTAL_S, NULL SYSSTAT_RECURSIVE_S,
  NULL SYSSTAT_PARSE_S FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL TIME_MODEL_TOTAL_S, NULL SYSSTAT_TOTAL_S, NULL SYSSTAT_RECURSIVE_S,
  NULL SYSSTAT_PARSE_S FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME, 
  TO_CHAR(TIME_MODEL_TOTAL_S, 99999999999990.99) TIME_MODEL_TOTAL_S,
  TO_CHAR(SYSSTAT_TOTAL_S, 99999999990.99) SYSSTAT_TOTAL_S,
  TO_CHAR(SYSSTAT_RECURSIVE_S, 999999999999990.99) SYSSTAT_RECURSIVE_S,
  TO_CHAR(SYSSTAT_PARSE_S, 99999999990.99) SYSSTAT_PARSE_S
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(TIME_MODEL_TOTAL_S) TIME_MODEL_TOTAL_S,
    SUM(SYSSTAT_TOTAL_S) SYSSTAT_TOTAL_S,
    SUM(SYSSTAT_RECURSIVE_S) SYSSTAT_RECURSIVE_S,
    SUM(SYSSTAT_PARSE_S) SYSSTAT_PARSE_S
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME,
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HST.VALUE, HST.VALUE - 
        LAG(HST.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1000000 TIME_MODEL_TOTAL_S,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 SYSSTAT_TOTAL_S,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 SYSSTAT_RECURSIVE_S,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 SYSSTAT_PARSE_S,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYS_TIME_MODEL HST
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HST.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HST.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HST.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'CPU used by this session' AND
      HSY2.STAT_NAME = 'recursive cpu usage' AND
      HSY3.STAT_NAME = 'parse time cpu' AND
      HST.STAT_NAME = 'DB CPU'
  )
  WHERE
    PREV_SNAP_ID IS NOT NULL 
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4b5310-014d-1000-8061-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_DiskReads]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL TOTAL_REQS, NULL "APP_REQ_%",
  NULL TOTAL_GB, NULL "APP_GB_%", NULL DISK_READS, NULL "CACHE_%",
  NULL "DIRECT_%", NULL "PRFTCH_%", NULL "LOB_%", NULL "TEMP_%", 
  NULL "WARMUP_%", NULL "RETRY_%"
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL TOTAL_REQS, NULL "APP_REQ_%",
  NULL TOTAL_GB, NULL "APP_GB_%", NULL DISK_READS, NULL "CACHE_%",
  NULL "DIRECT_%", NULL "PRFTCH_%", NULL "LOB_%", NULL "TEMP_%", 
  NULL "WARMUP_%", NULL "RETRY_%"
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'DAY' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TOTAL_REQS,
  "APP_REQ_%",
  TOTAL_GB,
  "APP_GB_%",
  DISK_READS,
  "CACHE_%",
  "DIRECT_%",
  "PRFTCH_%",
  "LOB_%",
  "TEMP_%",
  "WARMUP_%",
  "RETRY_%"
FROM
( SELECT
    BEGIN_TIME, 
    TO_CHAR(TOTAL_REQUESTS, 999999990) TOTAL_REQS,
    TO_CHAR(DECODE(TOTAL_REQUESTS, 0, 0, 
      APP_REQUESTS / TOTAL_REQUESTS * 100), 99990.99) "APP_REQ_%",
    TO_CHAR(TOTAL_BYTES / 1024 / 1024 / 1024, 999990.99) TOTAL_GB,
    TO_CHAR(DECODE(TOTAL_BYTES, 0, 0, 
      APP_BYTES / TOTAL_BYTES * 100), 9990.99) "APP_GB_%",
    TO_CHAR(DISK_READS, 99999999990) DISK_READS,
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      CACHE_READS / DISK_READS * 100), 990.99) "CACHE_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      DIRECT_READS / DISK_READS * 100), 9990.99) "DIRECT_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      PREFETCH_READS / DISK_READS * 100), 9990.99) "PRFTCH_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      WARMUP_READS / DISK_READS * 100), 9990.99) "WARMUP_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      CORR_RETRY_READS / DISK_READS * 100), 990.99) "RETRY_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      DIRECT_LOB_READS / DISK_READS * 100), 990.99) "LOB_%",
    TO_CHAR(DECODE(DISK_READS, 0, 0,
      DIRECT_TEMP_READS / DISK_READS * 100), 990.99) "TEMP_%"
  FROM
  ( SELECT
      BEGIN_TIME,
      SUM(SECONDS) SECONDS,
      SUM(TOTAL_BYTES) TOTAL_BYTES,
      SUM(APP_BYTES) APP_BYTES,
      SUM(CACHE_READS) CACHE_READS,
      SUM(DIRECT_READS) DIRECT_READS,
      SUM(PREFETCH_READS) PREFETCH_READS,
      SUM(WARMUP_READS) WARMUP_READS,
      SUM(CORR_RETRY_READS) CORR_RETRY_READS,
      SUM(DIRECT_LOB_READS) DIRECT_LOB_READS,
      SUM(DIRECT_TEMP_READS) DIRECT_TEMP_READS,
      SUM(TOTAL_REQUESTS) TOTAL_REQUESTS,
      SUM(APP_REQUESTS) APP_REQUESTS,
      SUM(DISK_READS) DISK_READS
    FROM
    ( SELECT
        TO_CHAR(SS.BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
        SS.INTERVAL_SECONDS SECONDS,
        DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
          LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) TOTAL_BYTES,
        DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
          LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) APP_BYTES,
        DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
          LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CACHE_READS,
        DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
          LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DIRECT_READS,
        DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
          LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) PREFETCH_READS,
        DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
          LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) WARMUP_READS,
        DECODE(SS.RESTART, 'YES', HSY7.VALUE, HSY7.VALUE - 
          LAG(HSY7.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) CORR_RETRY_READS,
        DECODE(SS.RESTART, 'YES', HSY8.VALUE, HSY8.VALUE - 
          LAG(HSY8.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DIRECT_LOB_READS,
        DECODE(SS.RESTART, 'YES', HSY9.VALUE, HSY9.VALUE - 
          LAG(HSY9.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DIRECT_TEMP_READS,
        DECODE(SS.RESTART, 'YES', HSY10.VALUE, HSY10.VALUE - 
          LAG(HSY10.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) TOTAL_REQUESTS,
        DECODE(SS.RESTART, 'YES', HSY11.VALUE, HSY11.VALUE - 
          LAG(HSY11.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) APP_REQUESTS,
        DECODE(SS.RESTART, 'YES', HSY12.VALUE, HSY12.VALUE - 
          LAG(HSY12.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DISK_READS
      FROM 
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2, 
        DBA_HIST_SYSSTAT HSY3,
        DBA_HIST_SYSSTAT HSY4,
        DBA_HIST_SYSSTAT HSY5,
        DBA_HIST_SYSSTAT HSY6,
        DBA_HIST_SYSSTAT HSY7,
        DBA_HIST_SYSSTAT HSY8,
        DBA_HIST_SYSSTAT HSY9,
        DBA_HIST_SYSSTAT HSY10,
        DBA_HIST_SYSSTAT HSY11,
        DBA_HIST_SYSSTAT HSY12
      WHERE
        HSY1.DBID = SS.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY3.DBID = SS.DBID AND
        HSY4.DBID = SS.DBID AND
        HSY5.DBID = SS.DBID AND
        HSY6.DBID = SS.DBID AND
        HSY7.DBID = SS.DBID AND
        HSY8.DBID = SS.DBID AND
        HSY9.DBID = SS.DBID AND
        HSY10.DBID = SS.DBID AND
        HSY11.DBID = SS.DBID AND
        HSY12.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY7.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY8.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY9.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY10.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY11.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY12.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY1.SNAP_ID = SS.SNAP_ID AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        HSY3.SNAP_ID = SS.SNAP_ID AND
        HSY4.SNAP_ID = SS.SNAP_ID AND
        HSY5.SNAP_ID = SS.SNAP_ID AND
        HSY6.SNAP_ID = SS.SNAP_ID AND
        HSY7.SNAP_ID = SS.SNAP_ID AND
        HSY8.SNAP_ID = SS.SNAP_ID AND
        HSY9.SNAP_ID = SS.SNAP_ID AND
        HSY10.SNAP_ID = SS.SNAP_ID AND
        HSY11.SNAP_ID = SS.SNAP_ID AND
        HSY12.SNAP_ID = SS.SNAP_ID AND
        HSY1.STAT_NAME = 'physical read total bytes' AND
        HSY2.STAT_NAME = 'physical read bytes' AND
        HSY3.STAT_NAME = 'physical reads cache' AND
        HSY4.STAT_NAME = 'physical reads direct' AND
        HSY5.STAT_NAME = 'physical reads cache prefetch' AND
        HSY6.STAT_NAME = 'physical reads prefetch warmup' AND
        HSY7.STAT_NAME = 'physical reads retry corrupt' AND
        HSY8.STAT_NAME = 'physical reads direct (lob)' AND
        HSY9.STAT_NAME = 'physical reads direct temporary tablespace' AND
        HSY10.STAT_NAME = 'physical read total IO requests' AND
        HSY11.STAT_NAME = 'physical read IO requests' AND
        HSY12.STAT_NAME = 'physical reads'
    )
    GROUP BY
      BEGIN_TIME
  )
)
ORDER BY
  BEGIN_TIME DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4bd390-014d-1000-8062-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_FullTableScans]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL "FTS_TOTAL/H", NULL "FTS_LONG/H", NULL "FTS_DIRECT/H",
  NULL "FTS_ROWID/H", NULL "FTS_ROWS/S", NULL "FTS_BLOCKS/S" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL "FTS_TOTAL/H", NULL "FTS_LONG/H", NULL "FTS_DIRECT/H",
  NULL "FTS_ROWID/H", NULL "FTS_ROWS/S", NULL "FTS_BLOCKS/S" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR((FTS_SHORT + FTS_LONG) / SECONDS * 3600, 9999990.99) "FTS_TOTAL/H",
  TO_CHAR(FTS_LONG / SECONDS * 3600, 999990.99) "FTS_LONG/H",
  TO_CHAR(FTS_DIRECT / SECONDS * 3600, 99999990.99) "FTS_DIRECT/H",
  TO_CHAR(FTS_ROWID / SECONDS * 3600, 9999990.99) "FTS_ROWID/H",
  TO_CHAR(FTS_ROWS / SECONDS, 999990.99) "FTS_ROWS/S",
  TO_CHAR(FTS_BLOCKS / SECONDS, 99999990.99) "FTS_BLOCKS/S"
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(FTS_SHORT) FTS_SHORT,
    SUM(FTS_LONG) FTS_LONG, 
    SUM(FTS_DIRECT) FTS_DIRECT,
    SUM(FTS_ROWID) FTS_ROWID,
    SUM(FTS_ROWS) FTS_ROWS,
    SUM(FTS_BLOCKS) FTS_BLOCKS
  FROM    
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_SHORT,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_LONG,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_DIRECT,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_ROWID,
      DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
        LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_ROWS,
      DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
        LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) FTS_BLOCKS,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4,
      DBA_HIST_SYSSTAT HSY5,
      DBA_HIST_SYSSTAT HSY6
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY5.DBID = SS.DBID AND
      HSY6.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY5.SNAP_ID = SS.SNAP_ID AND
      HSY6.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'table scans (short tables)' AND
      HSY2.STAT_NAME = 'table scans (long tables)' AND
      HSY3.STAT_NAME = 'table scans (direct read)' AND
      HSY4.STAT_NAME = 'table scans (rowid ranges)' AND
      HSY5.STAT_NAME = 'table scan rows gotten' AND
      HSY6.STAT_NAME = 'table scan blocks gotten'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4c48e8-014d-1000-8063-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_KeyFigures]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT /*+ OPT_PARAM('_OPTIMIZER_DISTINCT_AGG_TRANSFORM', 'FALSE') */
  NULL BEGIN_TIME, NULL SECONDS, NULL ACT_SESS, NULL CPUS_USED, NULL "T_MS/USERC.", NULL "READS/USERC.", 
  NULL "HITRATIO", NULL "LOG. READS/S", NULL "DISK READS/S", 
  NULL "USER CALLS/S", 
  NULL "COMMITS/S", NULL "REDO BLKS/S" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL SECONDS, NULL ACT_SESS, NULL CPUS_USED, NULL "T_MS/USERC.", NULL "READS/USERC.", 
  NULL "HITRATIO", NULL "LOG. READS/S", NULL "DISK READS/S", 
  NULL "USER CALLS/S",
  NULL "COMMITS/S", NULL "REDO BLKS/S" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    AGGREGATE_BY,
    SORT_ORDER,
    EXCLUDE_WEEKENDS
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,        /* -1 for current instance, -2 for all instances */
      TO_DATE('01.01.1000 12:57:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 00:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY,  /* SNAPSHOT, DAY, HOUR_OF_DAY, INSTANCE, SS_INST, DAY_INST, HOD_INST */
      'DESC' SORT_ORDER,     /* ASC, DESC */
      ' ' EXCLUDE_WEEKENDS
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    DBID,
    INSTANCE_NUMBER,
    SNAP_ID,
    PREV_SNAP_ID,
    MIN_SNAP_ID,
    BEGIN_INTERVAL_TIME,
    END_INTERVAL_TIME,
    INTERVAL_SECONDS,
    SUM(INTERVAL_SECONDS) OVER () TOTAL_SECONDS,
    RESTART
  FROM
  ( SELECT
      HSS2.DBID,
      HSS2.INSTANCE_NUMBER,
      HSS2.SNAP_ID,
      HSS1.SNAP_ID PREV_SNAP_ID,
      MIN(HSS2.SNAP_ID) OVER (PARTITION BY HSS2.INSTANCE_NUMBER) MIN_SNAP_ID,
      HSS2.BEGIN_INTERVAL_TIME,
      HSS2.END_INTERVAL_TIME,
      TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
        TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
        86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
                 TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
        INTERVAL_SECONDS,
      DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SNAPSHOT HSS1, 
      DBA_HIST_SNAPSHOT HSS2
    WHERE
      HSS2.DBID = BI.DBID AND
      HSS1.DBID (+) = HSS2.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR 
        HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER ) AND
      HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
      HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
    ORDER BY
      HSS2.SNAP_ID
  )
),
KEYFIG_PER_INTERVAL AS
( SELECT
    SNAP_ID,
    MIN(BEGIN_INTERVAL_TIME) OVER (PARTITION BY SNAP_ID) BEGIN_INTERVAL_TIME,
    PREV_SNAP_ID,
    INSTANCE_NUMBER,
    SECONDS,
    READS,
    USER_CALLS,
    RECURSIVE_CALLS,
    PHYSICAL_READS,
    COMMITS,
    REDO_BLOCKS,
    DB_TIME_US,
    CPU_TIME_US,
    PHYSICAL_READS_CACHE
  FROM
  ( SELECT
      SS.INSTANCE_NUMBER,
      SS.SNAP_ID,
      SS.BEGIN_INTERVAL_TIME,
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) READS,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) USER_CALLS,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) RECURSIVE_CALLS,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) PHYSICAL_READS,
      DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
        LAG(HSY5.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) COMMITS,
      DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
        LAG(HSY6.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) REDO_BLOCKS,
      DECODE(SS.RESTART, 'YES', HSY7.VALUE, HSY7.VALUE - 
        LAG(HSY7.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) DB_TIME_US,
      DECODE(SS.RESTART, 'YES', HSY8.VALUE, HSY8.VALUE - 
        LAG(HSY8.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) CPU_TIME_US,
      DECODE(SS.RESTART, 'YES', HSY9.VALUE, HSY9.VALUE - 
        LAG(HSY9.VALUE, 1) OVER (PARTITION BY SS.INSTANCE_NUMBER ORDER BY SS.SNAP_ID)) PHYSICAL_READS_CACHE,
      SS.PREV_SNAP_ID,
      SS.MIN_SNAP_ID
    FROM
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4,
      DBA_HIST_SYSSTAT HSY5,
      DBA_HIST_SYSSTAT HSY6,
      DBA_HIST_SYS_TIME_MODEL HSY7,
      DBA_HIST_SYS_TIME_MODEL HSY8,
      DBA_HIST_SYSSTAT HSY9
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY5.DBID = SS.DBID AND
      HSY6.DBID = SS.DBID AND
      HSY7.DBID = SS.DBID AND
      HSY8.DBID = SS.DBID AND
      HSY9.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY7.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY8.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY9.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY5.SNAP_ID = SS.SNAP_ID AND
      HSY6.SNAP_ID = SS.SNAP_ID AND
      HSY7.SNAP_ID = SS.SNAP_ID AND
      HSY8.SNAP_ID = SS.SNAP_ID AND
      HSY9.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'session logical reads' AND
      HSY2.STAT_NAME = 'user calls' AND
      HSY3.STAT_NAME = 'recursive calls' AND
      HSY4.STAT_NAME = 'physical reads' AND
      HSY5.STAT_NAME = 'user commits' AND
      HSY6.STAT_NAME = 'redo blocks written' AND
      HSY7.STAT_NAME = 'DB time' AND
      HSY8.STAT_NAME = 'DB CPU' AND
      HSY9.STAT_NAME = 'physical reads cache'
  )
  WHERE
    SNAP_ID != MIN_SNAP_ID
)
SELECT 
  'BEGIN TIME:' BEGIN_INTERVAL_TIME, 
  TO_CHAR(MIN(END_INTERVAL_TIME), 'dd.mm.yyyy') SECONDS, 
  TO_CHAR(MIN(END_INTERVAL_TIME), 'hh24:mi:ss') ACT_SESS, 
  NULL CPUS_USED, 
  NULL "T_MS/USERC.", 
  NULL "READS/USERC.", 
  NULL "HITRATIO", 
  NULL "LOG. READS/S", 
  NULL "DISK READS/S", 
  NULL "USER CALLS/S", 
  NULL "COMMITS/S", 
  NULL "REDO BLKS/S" 
FROM
  SNAPSHOTS
UNION ALL
( SELECT 
    'END TIME:' BEGIN_INTERVAL_TIME, 
    TO_CHAR(MAX(END_INTERVAL_TIME), 'dd.mm.yyyy') SECONDS, 
    TO_CHAR(MAX(END_INTERVAL_TIME), 'hh24:mi:ss') ACT_SESS, 
    NULL CPUS_USED, 
    NULL "T_MS/USERC.", 
    NULL "READS/USERC.", 
    NULL "HITRATIO", 
    NULL "LOG. READS/S", 
    NULL "DISK READS/S", 
    NULL "USER CALLS/S", 
    NULL "COMMITS/S", 
    NULL "REDO BLKS/S" 
  FROM 
    SNAPSHOTS
)
UNION ALL
( SELECT 
    'INSTANCE:' BEGIN_INTERVAL_TIME, 
    DECODE(INSTANCE_NUMBER, -2, 'ALL', TO_CHAR(INSTANCE_NUMBER)) SECONDS, 
    NULL ACT_SESS, 
    NULL CPUS_USED, 
    NULL "T_MS/USERC.", 
    NULL "READS/USERC.", 
    NULL "HITRATIO", 
    NULL "LOG. READS/S", 
    NULL "DISK READS/S", 
    NULL "USER CALLS/S", 
    NULL "COMMITS/S", 
    NULL "REDO BLKS/S" 
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    'AGGREGATION BY:' BEGIN_INTERVAL_TIME, 
    AGGREGATE_BY SECONDS, 
    NULL ACT_SESS, 
    NULL CPUS_USED, 
    NULL "T_MS/USERC.", 
    NULL "READS/USERC.", 
    NULL "HITRATIO", 
    NULL "LOG. READS/S", 
    NULL "DISK READS/S", 
    NULL "USER CALLS/S", 
    NULL "COMMITS/S", 
    NULL "REDO BLKS/S" 
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    'WEEKENDS EXCLUDED:' BEGIN_INTERVAL_TIME, 
    DECODE(EXCLUDE_WEEKENDS, 'X', 'YES', 'NO') SECONDS, 
    NULL ACT_SESS, 
    NULL CPUS_USED, 
    NULL "T_MS/USERC.", 
    NULL "READS/USERC.", 
    NULL "HITRATIO", 
    NULL "LOG. READS/S", 
    NULL "DISK READS/S", 
    NULL "USER CALLS/S", 
    NULL "COMMITS/S", 
    NULL "REDO BLKS/S" 
  FROM 
    BASIS_INFO
)
UNION ALL
( SELECT 
    NULL BEGIN_INTERVAL_TIME, 
    NULL SECONDS, 
    NULL ACT_SESS, 
    NULL CPUS_USED, 
    NULL "T_MS/USERC.", 
    NULL "READS/USERC.", 
    NULL "HITRATIO", 
    NULL "LOG. READS/S", 
    NULL "DISK READS/S", 
    NULL "USER CALLS/S", 
    NULL "COMMITS/S", 
    NULL "REDO BLKS/S" 
  FROM 
    DUAL
)
UNION ALL
( SELECT 
    * 
  FROM
  ( SELECT
      BEGIN_TIME,
      TO_CHAR(SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER)), 9999999990) SECONDS, 
      TO_CHAR(SUM(DB_TIME_US) / 1000000 / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 999990.99) ACT_SESS,
      TO_CHAR(SUM(CPU_TIME_US) / 1000000 / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 99990.99) CPUS_USED,
      TO_CHAR(SUM(DB_TIME_US) / 1000 / SUM(USER_CALLS), 9999990.99)
        "T_MS/USERC.",
      TO_CHAR(SUM(READS) / SUM(USER_CALLS), 99999990.99)
        "READS/USERC.",
      TO_CHAR((SUM(READS) - SUM(PHYSICAL_READS_CACHE)) / SUM(READS) * 100, 9990.99) 
        "HITRATIO",
      TO_CHAR(SUM(READS) / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 99999990.99) 
      "LOG. READS/S",
      TO_CHAR(SUM(PHYSICAL_READS) / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 99999990.99) 
      "DISK READS/S",
      TO_CHAR(SUM(USER_CALLS) / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 99999990.99) 
      "USER CALLS/S",
      TO_CHAR(SUM(COMMITS) / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 99990.99) "COMMITS/S",
      TO_CHAR(SUM(REDO_BLOCKS) / (SUM(SECONDS) / COUNT(DISTINCT(INSTANCE_NUMBER))), 9999990.99) 
      "REDO BLKS/S"
    FROM
    ( SELECT
        DECODE(BI.AGGREGATE_BY,
          'SNAPSHOT', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS'),
          'DAY', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)'),
          'HOUR_OF_DAY', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'HH24') || ':00',
          'INSTANCE', 'Instance: ' || TO_CHAR(K.INSTANCE_NUMBER),
          'SS_INST', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD HH24:MI:SS') ||
             ' (Instance: ' || TO_CHAR(K.INSTANCE_NUMBER) || ')',
          'DAY_INST', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'YYYY-MM-DD (DY)') ||
             ' (Instance: ' || TO_CHAR(K.INSTANCE_NUMBER) || ')',
          'HOD_INST', TO_CHAR(K.BEGIN_INTERVAL_TIME, 'HH24') || ':00' ||
             ' (Instance: ' || TO_CHAR(K.INSTANCE_NUMBER) || ')') BEGIN_TIME,
        K.*,
        BI.SORT_ORDER,
        BI.AGGREGATE_BY
      FROM
        BASIS_INFO BI,
        KEYFIG_PER_INTERVAL K
      WHERE
        K.PREV_SNAP_ID IS NOT NULL AND
        ( BI.EXCLUDE_WEEKENDS = ' ' OR 
          TO_CHAR(K.BEGIN_INTERVAL_TIME, 'D') NOT IN (7, 1) )
    )
    GROUP BY
      BEGIN_TIME,
      SORT_ORDER,
      AGGREGATE_BY
    ORDER BY
      DECODE(SORT_ORDER, 
        'ASC', MIN(BEGIN_TIME), SYSDATE),
      DECODE(SORT_ORDER, 
        'DESC', MIN(BEGIN_TIME), SYSDATE) DESC
  )
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4e9bcf-014d-1000-8066-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_LGWR]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL "REDO_GB/H", NULL "WRITES/S", NULL "KB/WRITE",
  NULL "MS/WRT_REQ", NULL "WRT_MB/S", NULL "WRT_BUSY_%", NULL "SYNCS/S", 
  NULL "MS/SYNC", NULL SYNC_SESS, NULL "COMMITS/S" FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL "REDO_GB/H", NULL "WRITES/S", NULL "KB/WRITE",
  NULL "MS/WRT_REQ", NULL "WRT_MB/S", NULL "WRT_BUSY_%", NULL "SYNCS/S",
  NULL "MS/SYNC", NULL SYNC_SESS, NULL "COMMITS/S" FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT 
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(DECODE(SECONDS, 0, 0, REDO_SIZE_MB / SECONDS * 3600 / 1024), 99990.99) "REDO_GB/H",
  TO_CHAR(DECODE(SECONDS, 0, 0, REDO_WRITES / SECONDS), 9990.99) "WRITES/S",
  TO_CHAR(DECODE(REDO_WRITES, 0, 0, REDO_SIZE_MB / REDO_WRITES * 1000), 99999.99) "KB/WRITE",
  TO_CHAR(DECODE(REDO_WRITES, 0, 0, WRITE_TIME_S / REDO_WRITES * 1000), 999990.99) "MS/WRT_REQ",
  TO_CHAR(DECODE(WRITE_TIME_S, 0, 0, REDO_SIZE_MB / WRITE_TIME_S), 9990.99) "WRT_MB/S",
  TO_CHAR(DECODE(SECONDS, 0, 0, WRITE_TIME_S / SECONDS * 100), 999990.99) "WRT_BUSY_%",
  TO_CHAR(DECODE(SECONDS, 0, 0, SYNC_REQS / SECONDS), 9990.99) "SYNCS/S",
  TO_CHAR(DECODE(SYNC_REQS, 0, 0, SYNC_TIME_S / SYNC_REQS * 1000), 9990.99) "MS/SYNC",
  TO_CHAR(DECODE(SECONDS, 0, 0, SYNC_TIME_S / SECONDS), 99990.99) SYNC_SESS,
  TO_CHAR(DECODE(SECONDS, 0, 0, COMMITS / SECONDS), 99990.99) "COMMITS/S"
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(REDO_SIZE_MB) REDO_SIZE_MB,
    SUM(REDO_WRITES) REDO_WRITES, 
    SUM(WRITE_TIME_S) WRITE_TIME_S,
    SUM(SYNC_REQS) SYNC_REQS,
    SUM(SYNC_TIME_S) SYNC_TIME_S,
    SUM(COMMITS) COMMITS
  FROM    
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1024 / 1024 REDO_SIZE_MB,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) REDO_WRITES,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 WRITE_TIME_S,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) SYNC_REQS,
      DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
        LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 SYNC_TIME_S,
      DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
        LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) COMMITS,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4,
      DBA_HIST_SYSSTAT HSY5,
      DBA_HIST_SYSSTAT HSY6
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY5.DBID = SS.DBID AND
      HSY6.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY5.SNAP_ID = SS.SNAP_ID AND
      HSY6.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'redo size' AND
      HSY2.STAT_NAME = 'redo writes' AND
      HSY3.STAT_NAME = 'redo write time' AND
      HSY4.STAT_NAME = 'redo synch writes' AND
      HSY5.STAT_NAME = 'redo synch time' AND
      HSY6.STAT_NAME = 'user commits'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4f0c06-014d-1000-8067-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_Network]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL "RNDTRP_CLNT/S", NULL "MB_TO_CLNT/S",
  NULL "MB_FR_CLNT/S", NULL "KB_TO_CLNT/RNDTRP", NULL "KB_FR_CLNT/RNDTRP", NULL "RNDTRP_DBLNK/S",
  NULL "MB_TO_DBLNK/S", NULL "MB_FR_DBLINK/S"
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL "RNDTRP_CLNT/S", NULL "MB_TO_CLNT/S",
  NULL "MB_FR_CLNT/S", NULL "MB_TO_CLNT/RNDTRP", NULL "MB_FR_CLNT/RNDTRP", NULL "RNDTRP_DBLNK/S",
  NULL "MB_TO_DBLNK/S", NULL "MB_FR_DBLINK/S"
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  "RNDTRP_CLNT/S",
  "MB_TO_CLNT/S",
  "MB_FR_CLNT/S",
  "KB_TO_CLNT/RNDTRP",
  "KB_FR_CLNT/RNDTRP",
  "RNDTRP_DBLNK/S",
  "MB_TO_DBLNK/S",
  "MB_FR_DBLINK/S"
FROM
( SELECT
    BEGIN_TIME, 
    TO_CHAR(DECODE(SECONDS, 0, 0, ROUNDTRIPS_CLIENT / SECONDS), 999999990.99) "RNDTRP_CLNT/S",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_TO_CLIENT + VECTOR_BYTES_TO_CLIENT ) / 1024 / 1024 /
      SECONDS), 99999990.99) "MB_TO_CLNT/S",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_FROM_CLIENT + VECTOR_BYTES_FROM_CLIENT ) / 1024 / 1024 /
      SECONDS), 99999990.99) "MB_FR_CLNT/S",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_TO_CLIENT + VECTOR_BYTES_TO_CLIENT ) / 1024 /
      ROUNDTRIPS_CLIENT), 9999999999990.99) "KB_TO_CLNT/RNDTRP",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_FROM_CLIENT + VECTOR_BYTES_FROM_CLIENT ) / 1024 /
      ROUNDTRIPS_CLIENT), 9999999999990.99) "KB_FR_CLNT/RNDTRP",
    TO_CHAR(DECODE(SECONDS, 0, 0, ROUNDTRIPS_DBLINK / SECONDS), 9999999990.99) "RNDTRP_DBLNK/S",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_TO_DBLINK + VECTOR_BYTES_TO_DBLINK ) / 1024 / 1024 /
      SECONDS), 999999990.99) "MB_TO_DBLNK/S",
    TO_CHAR(DECODE(SECONDS, 0, 0, ( BYTES_FROM_DBLINK + VECTOR_BYTES_FROM_DBLINK ) / 1024 / 1024 /
      SECONDS), 9999999990.99) "MB_FR_DBLINK/S"
  FROM
  ( SELECT
      BEGIN_TIME,
      SUM(SECONDS) SECONDS,
      SUM(ROUNDTRIPS_CLIENT) ROUNDTRIPS_CLIENT,
      SUM(BYTES_TO_CLIENT) BYTES_TO_CLIENT,
      SUM(BYTES_FROM_CLIENT) BYTES_FROM_CLIENT,
      SUM(VECTOR_BYTES_TO_CLIENT) VECTOR_BYTES_TO_CLIENT,
      SUM(VECTOR_BYTES_FROM_CLIENT) VECTOR_BYTES_FROM_CLIENT,
      SUM(ROUNDTRIPS_DBLINK) ROUNDTRIPS_DBLINK,
      SUM(BYTES_TO_DBLINK) BYTES_TO_DBLINK,
      SUM(BYTES_FROM_DBLINK) BYTES_FROM_DBLINK,
      SUM(VECTOR_BYTES_TO_DBLINK) VECTOR_BYTES_TO_DBLINK,
      SUM(VECTOR_BYTES_FROM_DBLINK) VECTOR_BYTES_FROM_DBLINK
    FROM
    ( SELECT
        TO_CHAR(SS.BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
        SS.INTERVAL_SECONDS SECONDS,
        DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
          LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) ROUNDTRIPS_CLIENT,
        DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
          LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) BYTES_TO_CLIENT,
        DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
          LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) BYTES_FROM_CLIENT,
        DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
          LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) VECTOR_BYTES_TO_CLIENT,
        DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
          LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) VECTOR_BYTES_FROM_CLIENT,
        DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
          LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) ROUNDTRIPS_DBLINK,
        DECODE(SS.RESTART, 'YES', HSY7.VALUE, HSY7.VALUE - 
          LAG(HSY7.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) BYTES_TO_DBLINK,
        DECODE(SS.RESTART, 'YES', HSY8.VALUE, HSY8.VALUE - 
          LAG(HSY8.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) BYTES_FROM_DBLINK,
        DECODE(SS.RESTART, 'YES', HSY9.VALUE, HSY9.VALUE - 
          LAG(HSY9.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) VECTOR_BYTES_TO_DBLINK,
        DECODE(SS.RESTART, 'YES', HSY10.VALUE, HSY10.VALUE - 
          LAG(HSY10.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) VECTOR_BYTES_FROM_DBLINK
      FROM 
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2, 
        DBA_HIST_SYSSTAT HSY3,
        DBA_HIST_SYSSTAT HSY4,
        DBA_HIST_SYSSTAT HSY5,
        DBA_HIST_SYSSTAT HSY6,
        DBA_HIST_SYSSTAT HSY7,
        DBA_HIST_SYSSTAT HSY8,
        DBA_HIST_SYSSTAT HSY9,
        DBA_HIST_SYSSTAT HSY10
      WHERE
        HSY1.DBID = SS.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY3.DBID = SS.DBID AND
        HSY4.DBID = SS.DBID AND
        HSY5.DBID = SS.DBID AND
        HSY6.DBID = SS.DBID AND
        HSY7.DBID = SS.DBID AND
        HSY8.DBID = SS.DBID AND
        HSY9.DBID = SS.DBID AND
        HSY10.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY7.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY8.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY9.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY10.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY1.SNAP_ID = SS.SNAP_ID AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        HSY3.SNAP_ID = SS.SNAP_ID AND
        HSY4.SNAP_ID = SS.SNAP_ID AND
        HSY5.SNAP_ID = SS.SNAP_ID AND
        HSY6.SNAP_ID = SS.SNAP_ID AND
        HSY7.SNAP_ID = SS.SNAP_ID AND
        HSY8.SNAP_ID = SS.SNAP_ID AND
        HSY9.SNAP_ID = SS.SNAP_ID AND
        HSY10.SNAP_ID = SS.SNAP_ID AND
        HSY1.STAT_NAME = 'SQL*Net roundtrips to/from client' AND
        HSY2.STAT_NAME = 'bytes sent via SQL*Net to client' AND
        HSY3.STAT_NAME = 'bytes received via SQL*Net from client' AND
        HSY4.STAT_NAME = 'bytes via SQL*Net vector to client' AND
        HSY5.STAT_NAME = 'bytes via SQL*Net vector from client' AND
        HSY6.STAT_NAME = 'SQL*Net roundtrips to/from dblink' AND
        HSY7.STAT_NAME = 'bytes sent via SQL*Net to dblink' AND
        HSY8.STAT_NAME = 'bytes received via SQL*Net from dblink' AND
        HSY9.STAT_NAME = 'bytes via SQL*Net vector to dblink' AND
        HSY10.STAT_NAME = 'bytes via SQL*Net vector from dblink' 
    )
    GROUP BY
      BEGIN_TIME
  )
)
ORDER BY
  BEGIN_TIME DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d4f989e-014d-1000-8068-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_ParallelExecutions]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL NO_DOWNGRADE, 
  NULL DG_TOTAL, NULL DG_1_25_PCT, 
  NULL DG_25_50_PCT, NULL DG_50_75_PCT, 
  NULL DG_75_99_PCT, NULL DG_SERIAL
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL NO_DOWNGRADE, 
  NULL DG_TOTAL, NULL DG_1_25_PCT, 
  NULL DG_25_50_PCT, NULL DG_50_75_PCT, 
  NULL DG_75_99_PCT, NULL DG_SERIAL
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    ONLY_DOWNGRADES,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'X' ONLY_DOWNGRADES,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  NO_DOWNGRADE,
  DG_TOTAL,
  DG_1_25_PCT,
  DG_25_50_PCT,
  DG_50_75_PCT,
  DG_75_99_PCT,
  DG_SERIAL
FROM
( SELECT
    BEGIN_TIME,
    TO_CHAR(NO_DOWNGRADE, 99999999990) NO_DOWNGRADE,
    TO_CHAR(DG_1_25_PCT + DG_25_50_PCT + DG_50_75_PCT +
      DG_75_99_PCT + DG_SERIAL, 9999990) DG_TOTAL,
    TO_CHAR(DG_1_25_PCT, 9999999990) DG_1_25_PCT,
    TO_CHAR(DG_25_50_PCT, 99999999990) DG_25_50_PCT,
    TO_CHAR(DG_50_75_PCT, 99999999990) DG_50_75_PCT,
    TO_CHAR(DG_75_99_PCT, 99999999990) DG_75_99_PCT,
    TO_CHAR(DG_SERIAL, 99999990) DG_SERIAL,
    ONLY_DOWNGRADES
  FROM
  ( SELECT
      TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
      SUM(SECONDS) SECONDS,
      SUM(NO_DOWNGRADE) NO_DOWNGRADE,
      SUM(DG_1_25_PCT) DG_1_25_PCT,
      SUM(DG_25_50_PCT) DG_25_50_PCT,
      SUM(DG_50_75_PCT) DG_50_75_PCT,
      SUM(DG_75_99_PCT) DG_75_99_PCT,
      SUM(DG_SERIAL) DG_SERIAL,
      ONLY_DOWNGRADES
    FROM
    ( SELECT
        SS.BEGIN_INTERVAL_TIME, 
        SS.INTERVAL_SECONDS SECONDS,
        DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
          LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) NO_DOWNGRADE,
        DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
          LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DG_1_25_PCT,
        DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
          LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DG_25_50_PCT,
        DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
          LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DG_50_75_PCT,
        DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
          LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DG_75_99_PCT,
        DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
          LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) DG_SERIAL,
        SS.PREV_SNAP_ID,
        BI.ONLY_DOWNGRADES,
        BI.AGGREGATE_BY
      FROM 
        BASIS_INFO BI,
        SNAPSHOTS SS,
        DBA_HIST_SYSSTAT HSY1, 
        DBA_HIST_SYSSTAT HSY2, 
        DBA_HIST_SYSSTAT HSY3,
        DBA_HIST_SYSSTAT HSY4,
        DBA_HIST_SYSSTAT HSY5,
        DBA_HIST_SYSSTAT HSY6
      WHERE
        HSY1.DBID = SS.DBID AND
        HSY2.DBID = SS.DBID AND
        HSY3.DBID = SS.DBID AND
        HSY4.DBID = SS.DBID AND
        HSY5.DBID = SS.DBID AND
        HSY6.DBID = SS.DBID AND
        HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        HSY1.SNAP_ID = SS.SNAP_ID AND
        HSY2.SNAP_ID = SS.SNAP_ID AND
        HSY3.SNAP_ID = SS.SNAP_ID AND
        HSY4.SNAP_ID = SS.SNAP_ID AND
        HSY5.SNAP_ID = SS.SNAP_ID AND
        HSY6.SNAP_ID = SS.SNAP_ID AND
        HSY1.STAT_NAME = 'Parallel operations not downgraded' AND
        HSY2.STAT_NAME = 'Parallel operations downgraded 1 to 25 pct' AND
        HSY3.STAT_NAME = 'Parallel operations downgraded 25 to 50 pct' AND
        HSY4.STAT_NAME = 'Parallel operations downgraded 50 to 75 pct' AND
        HSY5.STAT_NAME = 'Parallel operations downgraded 75 to 99 pct' AND
        HSY6.STAT_NAME = 'Parallel operations downgraded to serial'
    )
    WHERE 
      PREV_SNAP_ID IS NOT NULL
    GROUP BY
      ONLY_DOWNGRADES,
      TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
    ORDER BY
      1 DESC
  )
)
WHERE
  ( ONLY_DOWNGRADES = ' ' OR DG_TOTAL > 0 )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d5032be-014d-1000-8069-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_Parsing]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL DB_TIME_S, 
  NULL PARSE_TIME_S, NULL PARSE_CPU_S, 
  NULL USER_CALLS, NULL TOTAL_PARSES, 
  NULL HARD_PARSES, NULL PARSE_FAILURES
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL DB_TIME_S, 
  NULL PARSE_TIME_S, NULL PARSE_CPU_S, 
  NULL USER_CALLS, NULL TOTAL_PARSES, 
  NULL HARD_PARSES, NULL PARSE_FAILURES
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(DB_TIME_S, 99999990) DB_TIME_S,
  TO_CHAR(PARSE_TIME_S, 99999999990) PARSE_TIME_S,
  TO_CHAR(PARSE_CPU_S, 9999999990) PARSE_CPU_S,
  TO_CHAR(USER_CALLS, 999999990) USER_CALLS,
  TO_CHAR(TOTAL_PARSES, 99999999990) TOTAL_PARSES,
  TO_CHAR(HARD_PARSES, 9999999990) HARD_PARSES,
  TO_CHAR(PARSE_FAILURES, 9999999999990) PARSE_FAILURES
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(DB_TIME_S) DB_TIME_S,
    SUM(PARSE_TIME_S) PARSE_TIME_S,
    SUM(PARSE_CPU_S) PARSE_CPU_S,
    SUM(USER_CALLS) USER_CALLS,
    SUM(TOTAL_PARSES) TOTAL_PARSES,
    SUM(HARD_PARSES) HARD_PARSES,
    SUM(PARSE_FAILURES) PARSE_FAILURES
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 DB_TIME_S,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE - 
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 PARSE_TIME_S,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 100 PARSE_CPU_S,
      DECODE(SS.RESTART, 'YES', HSY4.VALUE, HSY4.VALUE - 
        LAG(HSY4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) USER_CALLS,
      DECODE(SS.RESTART, 'YES', HSY5.VALUE, HSY5.VALUE - 
        LAG(HSY5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) TOTAL_PARSES,
      DECODE(SS.RESTART, 'YES', HSY6.VALUE, HSY6.VALUE - 
        LAG(HSY6.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) HARD_PARSES,
      DECODE(SS.RESTART, 'YES', HSY7.VALUE, HSY7.VALUE - 
        LAG(HSY7.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) PARSE_FAILURES,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3,
      DBA_HIST_SYSSTAT HSY4,
      DBA_HIST_SYSSTAT HSY5,
      DBA_HIST_SYSSTAT HSY6,
      DBA_HIST_SYSSTAT HSY7
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY4.DBID = SS.DBID AND
      HSY5.DBID = SS.DBID AND
      HSY6.DBID = SS.DBID AND
      HSY7.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY4.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY5.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY6.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY7.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY4.SNAP_ID = SS.SNAP_ID AND
      HSY5.SNAP_ID = SS.SNAP_ID AND
      HSY6.SNAP_ID = SS.SNAP_ID AND
      HSY7.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'DB time' AND
      HSY2.STAT_NAME = 'parse time elapsed' AND
      HSY3.STAT_NAME = 'parse time cpu' AND
      HSY4.STAT_NAME = 'user calls' AND
      HSY5.STAT_NAME = 'parse count (total)' AND
      HSY6.STAT_NAME = 'parse count (hard)' AND
      HSY7.STAT_NAME = 'parse count (failures)'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d50c136-014d-1000-806a-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[SystemStatistics_SQLWorkareas]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL SECONDS, NULL OPTIMAL, NULL ONEPASS,
  NULL MULTIPASS FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL SECONDS, NULL OPTIMAL, NULL ONEPASS,
  NULL MULTIPASS FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    ONLY_PASSES,
    ONLY_MULTIPASSES,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'X' ONLY_PASSES,
      'X' ONLY_MULTIPASSES,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME, 
  TO_CHAR(SECONDS, 999990) SECONDS,
  TO_CHAR(OPTIMAL, 9999990) OPTIMAL,
  TO_CHAR(ONEPASS, 999990) ONEPASS,
  TO_CHAR(MULTIPASS, 99999990) MULTIPASS
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    SUM(OPTIMAL) OPTIMAL,
    SUM(ONEPASS) ONEPASS,
    SUM(MULTIPASS) MULTIPASS,
    ONLY_PASSES,
    ONLY_MULTIPASSES
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME,
      SS.INTERVAL_SECONDS SECONDS,
      DECODE(SS.RESTART, 'YES', HSY1.VALUE, HSY1.VALUE - 
        LAG(HSY1.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) OPTIMAL,
      DECODE(SS.RESTART, 'YES', HSY2.VALUE, HSY2.VALUE -  
        LAG(HSY2.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) ONEPASS,
      DECODE(SS.RESTART, 'YES', HSY3.VALUE, HSY3.VALUE - 
        LAG(HSY3.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) MULTIPASS,
      SS.PREV_SNAP_ID,
      BI.ONLY_PASSES,
      BI.ONLY_MULTIPASSES,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_SYSSTAT HSY1, 
      DBA_HIST_SYSSTAT HSY2, 
      DBA_HIST_SYSSTAT HSY3
    WHERE
      HSY1.DBID = SS.DBID AND
      HSY2.DBID = SS.DBID AND
      HSY3.DBID = SS.DBID AND
      HSY1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY2.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY3.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HSY1.SNAP_ID = SS.SNAP_ID AND
      HSY2.SNAP_ID = SS.SNAP_ID AND
      HSY3.SNAP_ID = SS.SNAP_ID AND
      HSY1.STAT_NAME = 'workarea executions - optimal' AND
      HSY2.STAT_NAME = 'workarea executions - onepass' AND
      HSY3.STAT_NAME = 'workarea executions - multipass' 
  )
  WHERE
    PREV_SNAP_ID IS NOT NULL AND
    ( ONLY_PASSES = ' ' AND ONLY_MULTIPASSES = ' ' OR
      ONLY_PASSES = 'X' AND ONLY_MULTIPASSES = ' ' AND ( ONEPASS > 0 OR MULTIPASS > 0 ) OR
      ONLY_MULTIPASSES = 'X' AND MULTIPASS > 0  
    )
    GROUP BY
      TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY),
      ONLY_PASSES,
      ONLY_MULTIPASSES
    ORDER BY
      1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[CBOStatistics]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2d53831c-014d-1000-806b-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[CBOStatistics_StatisticOverviewForTable_11g+]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL LINE FROM DUAL WHERE 1 = 0
UNION ALL(
SELECT NULL LINE FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /* 11g: Advanced Compression */
    NVL(:OWNER,'%') OWNER,
    NVL(:TABLE_NAME,'TEST') TABLE_NAME,
    'X' TABLE_GENERAL_DATA,
    'X' TABLE_STATISTICS,
    'X' INDEX_GENERAL_DATA,
    'X' INDEX_STATISTICS,
    'X' INDEXED_COLUMNS,
    ' ' COLUMN_STATISTICS,
    'X' BLANK_LINES
  FROM
    DUAL
),
TABLE_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    T.*,
    NVL(TS.BLOCK_SIZE, 8192) BLOCK_SIZE,
    BI.TABLE_STATISTICS,
    BI.TABLE_GENERAL_DATA,
    BI.BLANK_LINES
  FROM
    BASIS_INFO BI,
    DBA_TABLES T,
    DBA_TABLESPACES TS
  WHERE
    T.OWNER LIKE BI.OWNER AND
    T.TABLE_NAME = BI.TABLE_NAME AND
    T.TABLESPACE_NAME = TS.TABLESPACE_NAME (+)
),
INDEX_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    I.*,
    T.BLOCKS TABLE_BLOCKS,
    T.BLOCK_SIZE,
    T.NUM_ROWS TABLE_ROWS,
    BI.INDEX_STATISTICS,
    BI.INDEX_GENERAL_DATA,
    BI.INDEXED_COLUMNS,
    BI.BLANK_LINES
  FROM
    BASIS_INFO BI,
    DBA_INDEXES I,
    TABLE_STATISTICS T
  WHERE
    I.TABLE_OWNER LIKE BI.OWNER AND
    I.TABLE_NAME = BI.TABLE_NAME AND
    I.INDEX_TYPE != 'LOB'
),
TABLE_PARTITION_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    T.TABLE_OWNER OWNER,
    T.TABLE_NAME,
    BI.TABLE_STATISTICS,
    BI.TABLE_GENERAL_DATA,
    BI.BLANK_LINES,
    MIN(TS.TABLESPACE_NAME) TABLESPACE_NAME, 
    MIN(TS.BLOCK_SIZE) BLOCK_SIZE
  FROM
    BASIS_INFO BI,
    DBA_TAB_PARTITIONS T,
    DBA_TABLESPACES TS
  WHERE
    T.TABLE_OWNER LIKE BI.OWNER AND
    T.TABLE_NAME = BI.TABLE_NAME AND
    T.TABLESPACE_NAME = TS.TABLESPACE_NAME (+)
  GROUP BY
    T.TABLE_OWNER,
    T.TABLE_NAME,
    BI.TABLE_STATISTICS,
    BI.TABLE_GENERAL_DATA,
    BI.BLANK_LINES
),
INDEX_PARTITION_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    I.INDEX_OWNER OWNER,
    I.INDEX_NAME,
    BI.INDEX_STATISTICS,
    BI.INDEX_GENERAL_DATA,
    BI.BLANK_LINES,
    MIN(I.TABLESPACE_NAME) TABLESPACE_NAME
  FROM
    BASIS_INFO BI,
    INDEX_STATISTICS INS,
    DBA_IND_PARTITIONS I
  WHERE
    I.INDEX_OWNER = INS.OWNER AND
    I.INDEX_NAME = INS.INDEX_NAME 
  GROUP BY
    I.INDEX_OWNER,
    I.INDEX_NAME,
    BI.INDEX_STATISTICS,
    BI.INDEX_GENERAL_DATA,
    BI.BLANK_LINES
),
COLUMN_STATISTICS AS
( SELECT /*+ MATERIALIZE */
    C.*,
    MAX(LENGTH(C.COLUMN_NAME)) OVER () MAX_COL_NAME_LEN,
    BI.COLUMN_STATISTICS,
    BI.BLANK_LINES
  FROM
    BASIS_INFO BI,
    DBA_TAB_COLS C
  WHERE
    C.OWNER LIKE BI.OWNER AND
    C.TABLE_NAME = BI.TABLE_NAME
),
INDEX_COLUMNS AS
( SELECT /*+ MATERIALIZE */
    IC.*,
    C.AVG_COL_LEN,
    C.NUM_DISTINCT,
    BI.INDEX_STATISTICS,
    BI.INDEX_GENERAL_DATA,
    BI.INDEXED_COLUMNS,
    BI.BLANK_LINES
  FROM
    BASIS_INFO BI,
    DBA_IND_COLUMNS IC,
    COLUMN_STATISTICS C
  WHERE
    IC.TABLE_OWNER LIKE BI.OWNER AND
    IC.TABLE_NAME = BI.TABLE_NAME AND
    C.OWNER = IC.TABLE_OWNER AND
    C.TABLE_NAME = IC.TABLE_NAME AND
    C.COLUMN_NAME = IC.COLUMN_NAME
)
SELECT LPAD('=', 60, '=') FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' 
UNION ALL
( SELECT '=' || LPAD(' ', 29 - LENGTH(TABLE_NAME) / 2 - 3.5, ' ') || 'TABLE: ' || TABLE_NAME || 
    LPAD(' ', 60 - LENGTH(LPAD(' ', 29 - LENGTH(TABLE_NAME) / 2 - 3.5, ' ')) - 9 - LENGTH(TABLE_NAME), ' ') || '=' 
  FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' OR TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT LPAD('=', 60, '=') FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' OR TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT ' ' FROM TABLE_STATISTICS WHERE TABLE_GENERAL_DATA = 'X' AND BLANK_LINES = 'X' )
UNION ALL
( SELECT RPAD('Owner:', 40) || OWNER FROM TABLE_STATISTICS WHERE TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Tablespace name:', 40) || TABLESPACE_NAME FROM TABLE_STATISTICS WHERE TABLE_GENERAL_DATA = 'X' AND TABLESPACE_NAME IS NOT NULL )
UNION ALL
( SELECT RPAD('Tablespace name:', 40) || TABLESPACE_NAME FROM TABLE_PARTITION_STATISTICS WHERE TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('IOT:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE IOT_TYPE IS NOT NULL AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('PCTFREE:', 40) || PCT_FREE FROM TABLE_STATISTICS WHERE PCT_FREE != 10 AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('FREELISTS:', 40) || FREELISTS FROM TABLE_STATISTICS WHERE FREELISTS > 1 AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('FREELIST GROUPS:', 40) || FREELIST_GROUPS FROM TABLE_STATISTICS WHERE FREELIST_GROUPS > 1 AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('INITRANS:', 40) || INI_TRANS FROM TABLE_STATISTICS WHERE INI_TRANS != 1 AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('NOLOGGING:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE LOGGING = 'NO' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Parallelism:', 40) || DEGREE || ' / ' || INSTANCES FROM TABLE_STATISTICS WHERE ( LTRIM(DEGREE) != '1' OR LTRIM(INSTANCES) NOT IN ( '0', '1' ) ) AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Preferred caching:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE CACHE = 'Y' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Partitioned:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE PARTITIONED = 'YES' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Temporary:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE TEMPORARY = 'Y' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Buffer pool:', 40) || BUFFER_POOL FROM TABLE_STATISTICS WHERE BUFFER_POOL != 'DEFAULT' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Table lock:', 40) || 'Disabled' FROM TABLE_STATISTICS WHERE TABLE_LOCK = 'DISABLED' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Initial extent:', 40) || INITIAL_EXTENT FROM TABLE_STATISTICS WHERE INITIAL_EXTENT > 65536 AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('User defined statistics:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE USER_STATS = 'YES' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Partially dropped table:', 40) || 'Yes' FROM TABLE_STATISTICS WHERE DROPPED = 'YES' AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT RPAD('Compression:', 40) || COMPRESS_FOR FROM TABLE_STATISTICS WHERE COMPRESSION NOT IN ('NONE', 'DISABLED') AND TABLE_GENERAL_DATA = 'X' )
UNION ALL
( SELECT ' ' FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' AND BLANK_LINES = 'X' )
UNION ALL
( SELECT RPAD('Statistics date:', 40) || TO_CHAR(LAST_ANALYZED, 'dd.mm.yyyy hh24:mi:ss') FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Sample size (rows):', 40) || TO_CHAR(SAMPLE_SIZE, 999999999999) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Sample size (%):', 40) || TO_CHAR(DECODE(NUM_ROWS, 0, 0, SAMPLE_SIZE / NUM_ROWS * 100), 999999999990.99) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT ' ' FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' AND BLANK_LINES = 'X' )
UNION ALL
( SELECT RPAD('Number of rows:', 40) || TO_CHAR(NUM_ROWS, 999999999999) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Average row length:', 40) || TO_CHAR(AVG_ROW_LEN, 999999999999) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Number of blocks:', 40) || TO_CHAR(BLOCKS, 999999999999) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Rows per block:', 40) || TO_CHAR(NUM_ROWS / BLOCKS, 999999999990.99) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('Data size (MB):', 40) || TO_CHAR(NUM_ROWS * AVG_ROW_LEN / 1024 / 1024, 999999999990.99) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT RPAD('High water mark size (MB):', 40) || TO_CHAR(BLOCKS * BLOCK_SIZE / 1024 / 1024, 999999999990.99) FROM TABLE_STATISTICS WHERE TABLE_STATISTICS = 'X' )
UNION ALL
( SELECT
    LINE
  FROM
  ( SELECT
      DECODE(SIGN(LNR - 4), -1, NAME, DECODE(SIGN(LNR - 50), -1, RPAD(NAME, 40), NAME )) || VALUE LINE
    FROM
    ( SELECT INDEX_NAME, 0 LNR, ' ' NAME , ' ' VALUE FROM INDEX_STATISTICS WHERE ( INDEX_STATISTICS = 'X' OR INDEX_GENERAL_DATA = 'X' OR INDEXED_COLUMNS = 'X' )  AND BLANK_LINES = 'X'
      UNION ALL
      ( SELECT INDEX_NAME, 1, LPAD('=', 60, '='), ' ' FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' OR INDEX_GENERAL_DATA = 'X' OR INDEXED_COLUMNS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 2, '=' || LPAD(' ', 29 - LENGTH(INDEX_NAME) / 2 - 3.5, ' ') || 'INDEX: ' || INDEX_NAME ||
          LPAD(' ', 60 - LENGTH(LPAD(' ', 29 - LENGTH(INDEX_NAME) / 2 - 3.5, ' ')) - 9 - LENGTH(INDEX_NAME), ' ') || '=', ' ' 
        FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' OR INDEX_GENERAL_DATA = 'X' OR INDEXED_COLUMNS = 'X'
      )
      UNION ALL 
      ( SELECT INDEX_NAME, 3, LPAD('=', 60, '='), ' ' FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' OR INDEX_GENERAL_DATA = 'X' OR INDEXED_COLUMNS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 4 , ' ' , ' ' FROM INDEX_STATISTICS WHERE INDEX_GENERAL_DATA = 'X' AND BLANK_LINES = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 5, 'Owner:', OWNER FROM INDEX_STATISTICS WHERE INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 6, 'Tablespace name:', TABLESPACE_NAME FROM INDEX_STATISTICS  WHERE INDEX_GENERAL_DATA = 'X' AND TABLESPACE_NAME IS NOT NULL )
      UNION ALL
      ( SELECT INDEX_NAME, 6, 'Tablespace name:', TABLESPACE_NAME FROM INDEX_PARTITION_STATISTICS  WHERE INDEX_GENERAL_DATA = 'X' )
       UNION ALL
      ( SELECT INDEX_NAME, 7, 'Unique:', 'Yes' FROM INDEX_STATISTICS WHERE UNIQUENESS = 'UNIQUE' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 8, 'Index type:', INDEX_TYPE FROM INDEX_STATISTICS WHERE INDEX_TYPE != 'NORMAL' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 9, 'PCTFREE:', TO_CHAR(PCT_FREE) FROM INDEX_STATISTICS WHERE PCT_FREE > 10 AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 10, 'FREELISTS:', TO_CHAR(FREELISTS) FROM INDEX_STATISTICS WHERE FREELISTS > 1 AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 11, 'FREELIST GROUPS:', TO_CHAR(FREELIST_GROUPS) FROM INDEX_STATISTICS WHERE FREELIST_GROUPS > 1 AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 12, 'INITRANS:', TO_CHAR(INI_TRANS) FROM INDEX_STATISTICS WHERE INI_TRANS > 2 AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 13, 'NOLOGGING:', 'Yes' FROM INDEX_STATISTICS WHERE LOGGING = 'NO' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 14, 'Parallelism:', DEGREE || ' / ' || INSTANCES FROM INDEX_STATISTICS WHERE ( LTRIM(DEGREE) != '1' OR LTRIM(INSTANCES) NOT IN ( '0', '1' )) AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 15, 'Partitioned:', 'Yes' FROM INDEX_STATISTICS WHERE PARTITIONED = 'YES' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 16, 'Temporary:', 'Yes' FROM INDEX_STATISTICS WHERE TEMPORARY = 'Y' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 17, 'Buffer pool:', BUFFER_POOL FROM INDEX_STATISTICS WHERE BUFFER_POOL != 'DEFAULT' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 18, 'Initial extent:', TO_CHAR(INITIAL_EXTENT) FROM INDEX_STATISTICS WHERE INITIAL_EXTENT > 65536 AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 19, 'User defined statistics:', 'Yes' FROM INDEX_STATISTICS WHERE USER_STATS = 'YES' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 20, 'UNUSABLE:', 'Yes' FROM INDEX_STATISTICS WHERE STATUS = 'UNUSABLE' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 21, 'Partially dropped index:', 'Yes' FROM INDEX_STATISTICS WHERE DROPPED = 'YES' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 22, 'Compression:', 'Yes (' || PREFIX_LENGTH || ')' FROM INDEX_STATISTICS WHERE COMPRESSION = 'ENABLED' AND INDEX_GENERAL_DATA = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 30, ' ', ' ' FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' AND BLANK_LINES = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 31, 'Statistics date:', TO_CHAR(LAST_ANALYZED, 'dd.mm.yyyy hh24:mi:ss') FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 32, 'Sample size (rows):', TO_CHAR(SAMPLE_SIZE, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 33, 'Sample size (%):', TO_CHAR(DECODE(NUM_ROWS, 0, 0, SAMPLE_SIZE / NUM_ROWS * 100), 999999999990.99) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' ) 
      UNION ALL
      ( SELECT INDEX_NAME, 40, ' ', ' ' FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' AND BLANK_LINES = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 41, 'Branch levels:', TO_CHAR(BLEVEL, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 42, 'Leaf blocks:', TO_CHAR(LEAF_BLOCKS, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 43, 'Leaf block size (MB):', TO_CHAR(LEAF_BLOCKS * BLOCK_SIZE / 1024 / 1024, 999999999990.99) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 44, 'Number of rows:', TO_CHAR(NUM_ROWS, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 45, 'Distinct keys:', TO_CHAR(DISTINCT_KEYS, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 46, 'Rows per distinct key:', TO_CHAR(DECODE(NUM_ROWS, 0, 0, NUM_ROWS / DISTINCT_KEYS), 999999999990.99) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 47, 'Clustering factor:', TO_CHAR(CLUSTERING_FACTOR, 999999999999) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 48, 'Clustering factor improvement ratio:', TO_CHAR(DECODE(TABLE_BLOCKS, 0, 0, CLUSTERING_FACTOR / TABLE_BLOCKS), 999999999990.99) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 49, 'Clustering factor regression ratio:', TO_CHAR(DECODE(CLUSTERING_FACTOR, 0, 0, TABLE_ROWS / CLUSTERING_FACTOR), 999999999990.99) FROM INDEX_STATISTICS WHERE INDEX_STATISTICS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 60, ' ', ' ' FROM INDEX_STATISTICS WHERE INDEXED_COLUMNS = 'X' AND BLANK_LINES = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 61, 'COLUMN                         ' || 
          'DISTINCT_VALUES COLUMN_LENGTH', ' ' FROM INDEX_STATISTICS WHERE INDEXED_COLUMNS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 62, 
'------------------------------ --------------- -------------', ' ' FROM INDEX_STATISTICS WHERE INDEXED_COLUMNS = 'X' )
      UNION ALL
      ( SELECT INDEX_NAME, 63 + COLUMN_POSITION, RPAD(COLUMN_NAME, 30) || TO_CHAR(NUM_DISTINCT, 999999999999990) || TO_CHAR(AVG_COL_LEN, 9999999999990), ' ' FROM INDEX_COLUMNS WHERE INDEXED_COLUMNS = 'X' )
    )
    ORDER BY
      INDEX_NAME,
      LNR
  )
)
UNION ALL
( SELECT ' ' FROM BASIS_INFO WHERE COLUMN_STATISTICS = 'X'  )
UNION ALL
( SELECT LPAD('=', 60, '=') FROM BASIS_INFO WHERE COLUMN_STATISTICS = 'X' )
UNION ALL
( SELECT '=' || LPAD(' ', 21, ' ') || 'COLUMN STATISTICS' || LPAD(' ', 20, ' ') || '=' FROM BASIS_INFO WHERE COLUMN_STATISTICS = 'X' )
UNION ALL
( SELECT LPAD('=', 60, '=') FROM BASIS_INFO WHERE COLUMN_STATISTICS = 'X' )
UNION ALL
( SELECT ' ' FROM BASIS_INFO WHERE COLUMN_STATISTICS = 'X' )
UNION ALL
( SELECT 
    RPAD('COLUMN_NAME', GREATEST(MAX_COL_NAME_LEN, 31), ' ') || 
      '  DIST_VALUES BUCKETS COL_LEN' 
  FROM 
    COLUMN_STATISTICS 
  WHERE 
    ROWNUM = 1 AND COLUMN_STATISTICS = 'X' 
)
UNION ALL
( SELECT RPAD('-', GREATEST(MAX_COL_NAME_LEN, 30), '-') || ' ' || 
    '------------- ------- -------' FROM COLUMN_STATISTICS WHERE ROWNUM = 1 AND COLUMN_STATISTICS = 'X' )
UNION ALL
( SELECT
    *
  FROM
  ( SELECT 
      RPAD(COLUMN_NAME, GREATEST(MAX_COL_NAME_LEN, 31), ' ') || TO_CHAR(NUM_DISTINCT, 999999999990) || TO_CHAR(NUM_BUCKETS, 9999990) || TO_CHAR(AVG_COL_LEN, 9999990) 
    FROM 
      COLUMN_STATISTICS
    WHERE
      COLUMN_STATISTICS = 'X' 
    ORDER BY
      COLUMN_NAME
  )
)
))]]></sql>
				<binds>
					<bind id="OWNER">
						<prompt><![CDATA[OWNER]]></prompt>
						<tooltip><![CDATA[OWNER]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
					<bind id="TABLE_NAME">
						<prompt><![CDATA[TABLE_NAME]]></prompt>
						<tooltip><![CDATA[TABLE_NAME]]></tooltip>
						<value><![CDATA[NULL_VALUE]]></value>
						<bracket><![CDATA[null]]></bracket>
					</bind>
				</binds>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
	<folder>
		<name><![CDATA[Resources]]></name>
		<tooltip><![CDATA[]]></tooltip>
		<description><![CDATA[]]></description>
			<display id="2d556563-014d-1000-806c-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Resources_Memory_Overview]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL COL1, NULL COL2, NULL COL3 FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL COL1, NULL COL2, NULL COL3 FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    SEGMENTS_PER_BUFFER_POOL,
    SQL_STATEMENTS,
    SHARED_POOL_AREAS,
    DISPLAY_GENERAL,
    DISPLAY_PARAMETERS,
    DISPLAY_SGA,
    DISPLAY_BUFFER_POOL,
    DISPLAY_SHARED_POOL,
    DISPLAY_SQL
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      20 SEGMENTS_PER_BUFFER_POOL,
      10 SQL_STATEMENTS,
      20 SHARED_POOL_AREAS,
       5 LOCAL_MEM_PER_PROCESS_MB,
      'X' DISPLAY_GENERAL,
      'X' DISPLAY_PARAMETERS,
      'X' DISPLAY_SGA,
      'X' DISPLAY_BUFFER_POOL,
      'X' DISPLAY_SHARED_POOL,
      'X' DISPLAY_SQL
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SEGMENTS AS
( SELECT /*+ MATERIALIZE */
    DS.OWNER,
    DS.SEGMENT_NAME,
    DS.SEGMENT_TYPE,
    DS.PARTITION_NAME,
    DS.BUFFER_POOL,
    DS.TABLESPACE_NAME,
    DS.BYTES,
    DT.BLOCK_SIZE
  FROM
    DBA_SEGMENTS DS,
    DBA_TABLESPACES DT
  WHERE
    DS.TABLESPACE_NAME = DT.TABLESPACE_NAME 
),
OBJECTS AS
( SELECT /*+ MATERIALIZE */
    OWNER,
    OBJECT_NAME,
    SUBOBJECT_NAME,
    DATA_OBJECT_ID
  FROM
    DBA_OBJECTS
),
PARAMETERS AS
( SELECT /*+ MATERIALIZE */
    P.INST_ID,
    P.NAME,
    P.VALUE,
    P.ISDEFAULT
  FROM
    BASIS_INFO BI,
    GV$PARAMETER2 P
  WHERE
    P.INST_ID = BI.INSTANCE_NUMBER AND
    UPPER(P.NAME) IN 
      ( 'BITMAP_MERGE_AREA_SIZE',
        'CREATE_BITMAP_AREA_SIZE',
        'DB_BLOCK_BUFFERS', 
        'DB_BLOCK_SIZE',
        'DB_CACHE_SIZE',
        'DB_KEEP_CACHE_SIZE',
        'DB_RECYCLE_CACHE_SIZE',
        'DB_2K_CACHE_SIZE',
        'DB_4K_CACHE_SIZE',
        'DB_8K_CACHE_SIZE',
        'DB_16K_CACHE_SIZE',
        'DB_32K_CACHE_SIZE',
        'HASH_AREA_SIZE',
        'JAVA_POOL_SIZE',
        'LARGE_POOL_SIZE',
        'LOCK_SGA',
        'LOG_BUFFER',
        'MEMORY_TARGET',
        'MEMORY_MAX_TARGET',
        'PGA_AGGREGATE_TARGET',
        'PROCESSES',
        'SGA_MAX_SIZE',
        'SGA_TARGET',
        'SHARED_POOL_SIZE',
        'SORT_AREA_SIZE',
        'STREAMS_POOL_SIZE',
        'WORKAREA_SIZE_POLICY',
        '_PGA_MAX_SIZE'
      )
),
MEMORY_AREAS_HELPER AS
( SELECT /*+ MATERIALIZE */
    *
  FROM
  ( SELECT 
      OS.INST_ID INST_ID,
      1 LINE,
      'Physical memory' NAME,
      VALUE / 1024 / 1024 VALUE
    FROM
      BASIS_INFO BI,
      GV$OSSTAT OS
    WHERE
      OS.INST_ID = BI.INSTANCE_NUMBER AND
      OS.STAT_NAME = 'PHYSICAL_MEMORY_BYTES'
    UNION ALL
    ( SELECT
        SS.INST_ID INST_ID,
        2 LINE,
        'Oracle SGA used' NAME,
        SUM(SS.BYTES) / 1024 / 1024 VALUE
      FROM 
        BASIS_INFO BI,
        GV$SGASTAT SS
      WHERE
        SS.INST_ID = BI.INSTANCE_NUMBER
      GROUP BY
        SS.INST_ID
    )
    UNION ALL
    ( SELECT
        SS.INST_ID INST_ID,
        3 LINE,
        'Oracle SGA reserved' NAME,
        GREATEST(P.VALUE, SUM(SS.BYTES)) / 1024 / 1024 VALUE
      FROM 
        BASIS_INFO BI,
        GV$SGASTAT SS,
        PARAMETERS P
      WHERE
        SS.INST_ID = BI.INSTANCE_NUMBER AND
        P.INST_ID = BI.INSTANCE_NUMBER AND
        UPPER(P.NAME) = 'SGA_MAX_SIZE'
      GROUP BY
        SS.INST_ID,
        P.VALUE
    )
    UNION ALL
    ( SELECT
        PS.INST_ID, 
        4 LINE,
        'Oracle PGA' NAME, 
        PS.VALUE / 1024 / 1024 VALUE
      FROM
        BASIS_INFO BI,
        GV$PGASTAT PS
      WHERE
        PS.INST_ID = BI.INSTANCE_NUMBER AND
        PS.NAME = 'total PGA allocated'
    )
    UNION ALL
    ( SELECT
        P.INST_ID,
        5 LINE,
        'Oracle process memory' NAME, 
        CURRENT_UTILIZATION * 5 VALUE
      FROM
        BASIS_INFO BI,
        GV$RESOURCE_LIMIT P
      WHERE
        P.INST_ID = BI.INSTANCE_NUMBER AND
        RESOURCE_NAME = 'processes'
    )
  )
),
MEMORY_AREAS AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    LINE,
    NAME,
    VALUE
  FROM
    MEMORY_AREAS_HELPER
  UNION ALL
  ( SELECT
      INST_ID,
      6 LINE,
      'Oracle total used' NAME,
      SUM(VALUE) VALUE
    FROM
      MEMORY_AREAS_HELPER
    WHERE
      NAME IN ('Oracle SGA used', 'Oracle PGA', 
        'Oracle process memory')
    GROUP BY
      INST_ID
  )
  UNION ALL
  ( SELECT
      INST_ID,
      7 LINE,
      'Oracle total reserved' NAME,
      SUM(VALUE) VALUE
    FROM
      MEMORY_AREAS_HELPER
    WHERE
      NAME IN ('Oracle SGA reserved', 'Oracle PGA', 
        'Oracle process memory')
    GROUP BY
      INST_ID
  )
),
MEMORY_AREAS_MAX_HELPER AS
( SELECT /*+ MATERIALIZE */
    *
  FROM
  ( SELECT 
      OS.INSTANCE_NUMBER INST_ID,
      1 LINE,
      'Physical memory' NAME,
      MAX(VALUE) / 1024 / 1024 VALUE
    FROM
      BASIS_INFO BI,
      DBA_HIST_OSSTAT OS
    WHERE
      BI.DBID = OS.DBID AND
      OS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
      OS.STAT_NAME = 'PHYSICAL_MEMORY_BYTES'
    GROUP BY
      OS.INSTANCE_NUMBER
    UNION ALL
    ( SELECT
        INST_ID,
        2 LINE,
        NAME,
        MAX(VALUE)
      FROM
      ( SELECT
          SS.INSTANCE_NUMBER INST_ID,
          'Oracle SGA used' NAME,
          GREATEST(MA.VALUE, SUM(SS.BYTES) / 1024 / 1024) VALUE
        FROM 
          BASIS_INFO BI,
          DBA_HIST_SGASTAT SS,
          MEMORY_AREAS MA
        WHERE
          BI.DBID = SS.DBID AND
          SS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
          MA.NAME = 'Oracle SGA used'
        GROUP BY
          MA.VALUE,
          SS.INSTANCE_NUMBER,
          SS.SNAP_ID
      )
      GROUP BY
        INST_ID,
        NAME
    )
    UNION ALL
    ( SELECT
        SS.INSTANCE_NUMBER INST_ID,
        3 LINE,
        'Oracle SGA reserved' NAME,
        GREATEST(MA.VALUE * 1024 * 1024, P.VALUE, MAX(SS.BYTES)) / 1024 / 1024 VALUE
      FROM 
        BASIS_INFO BI,
        ( SELECT
            DBID,
            INSTANCE_NUMBER,
            SNAP_ID,
            SUM(BYTES) BYTES
          FROM
            DBA_HIST_SGASTAT
          GROUP BY
            DBID,
            INSTANCE_NUMBER,
            SNAP_ID
        ) SS,
        PARAMETERS P,
        MEMORY_AREAS MA
      WHERE
        BI.DBID = SS.DBID AND
        BI.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
        P.INST_ID = BI.INSTANCE_NUMBER AND
        UPPER(P.NAME) = 'SGA_MAX_SIZE' AND
        MA.NAME = 'Oracle SGA reserved'
      GROUP BY
        MA.VALUE,
        SS.INSTANCE_NUMBER,
        P.VALUE
    )
    UNION ALL
    ( SELECT
        PS.INSTANCE_NUMBER INST_ID,
        4 LINE,
        'Oracle PGA' NAME, 
        MAX(PS.VALUE) / 1024 / 1024 VALUE
      FROM
        BASIS_INFO BI,
        DBA_HIST_PGASTAT PS
      WHERE
        BI.DBID = PS.DBID AND
        BI.INSTANCE_NUMBER = PS.INSTANCE_NUMBER AND
        PS.NAME = 'maximum PGA allocated'
      GROUP BY
        PS.INSTANCE_NUMBER
    )
    UNION ALL
    ( SELECT
        P.INSTANCE_NUMBER INST_ID,
        5 LINE,
        'Oracle process memory' NAME, 
        MAX(MAX_UTILIZATION) * 5 VALUE
      FROM
        BASIS_INFO BI,
        DBA_HIST_RESOURCE_LIMIT P
      WHERE
        BI.DBID = P.DBID AND
        BI.INSTANCE_NUMBER = P.INSTANCE_NUMBER AND
        RESOURCE_NAME = 'processes'
      GROUP BY
        P.INSTANCE_NUMBER
    )
  )
),
MEMORY_AREAS_MAX AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    LINE,
    NAME,
    VALUE
  FROM
    MEMORY_AREAS_MAX_HELPER
  UNION ALL
  ( SELECT
      INST_ID,
      6 LINE,
      'Oracle total used' NAME,
      SUM(VALUE) VALUE
    FROM
      MEMORY_AREAS_MAX_HELPER
    WHERE
      NAME IN ('Oracle SGA used', 'Oracle PGA', 
        'Oracle process memory')
    GROUP BY
      INST_ID
  )
  UNION ALL
  ( SELECT
      INST_ID,
      7 LINE,
      'Oracle total reserved' NAME,
      SUM(VALUE) VALUE
    FROM
      MEMORY_AREAS_MAX_HELPER
    WHERE
      NAME IN ('Oracle SGA reserved', 'Oracle PGA', 
        'Oracle process memory')
    GROUP BY
      INST_ID
  )
),
SGA_AREAS AS
( SELECT /*+ MATERIALIZE */
    SS.INST_ID INST_ID,
    NVL(POOL, NAME) NAME,
    SUM(BYTES) / 1024 / 1024 VALUE
  FROM 
    BASIS_INFO BI,
    GV$SGASTAT SS
  WHERE
    SS.INST_ID = BI.INSTANCE_NUMBER 
  GROUP BY
    SS.INST_ID,
    NVL(POOL, NAME) 
),
SGA_AREAS_MAX AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    NAME,
    MAX(VALUE) VALUE
  FROM
  ( SELECT
      SS.INSTANCE_NUMBER INST_ID,
      NVL(POOL, NAME) NAME,
      SUM(BYTES) / 1024 / 1024 VALUE
    FROM 
      BASIS_INFO BI,
      DBA_HIST_SGASTAT SS
    WHERE
      BI.DBID = SS.DBID AND
      BI.INSTANCE_NUMBER = SS.INSTANCE_NUMBER 
    GROUP BY
      SS.SNAP_ID,
      SS.INSTANCE_NUMBER, 
      NVL(POOL, NAME) 
  )
  GROUP BY
    INST_ID,
    NAME
),
BUFFER_POOLS AS
( SELECT /*+ MATERIALIZE */
    BP.INST_ID,
    BP.NAME,
    BP.BLOCK_SIZE,
    BP.CURRENT_SIZE,
    DECODE(BPS.DB_BLOCK_GETS + BPS.CONSISTENT_GETS, 0, 0, (1 - BPS.PHYSICAL_READS / 
      (BPS.DB_BLOCK_GETS + BPS.CONSISTENT_GETS)) * 100 ) QUALITY
  FROM
    BASIS_INFO BI,
    GV$BUFFER_POOL BP,
    GV$BUFFER_POOL_STATISTICS BPS
  WHERE
    BP.INST_ID = BI.INSTANCE_NUMBER AND
    BPS.INST_ID = BP.INST_ID AND
    BPS.NAME = BP.NAME AND
    BPS.BLOCK_SIZE = BP.BLOCK_SIZE
),
BUFFER_POOL_SEGMENTS AS
( SELECT /*+ MATERIALIZE */
    POOL_NAME,
    BLOCK_SIZE,
    OWNER,
    SEGMENT_NAME,
    SIZE_BYTE
  FROM
  ( SELECT
      POOL_NAME,
      BLOCK_SIZE,
      OWNER,
      SEGMENT_NAME,
      SUM(SIZE_BYTE) SIZE_BYTE,
      SEGMENTS_PER_BUFFER_POOL,
      ROW_NUMBER() OVER (PARTITION BY POOL_NAME, BLOCK_SIZE ORDER BY SUM(SIZE_BYTE) DESC) POOLN
    FROM
    ( SELECT 
        BP.NAME POOL_NAME,
        BP.BLOCK_SIZE,
        S.OWNER,
        S.SEGMENT_NAME,
        S.PARTITION_NAME,
        BP.BLOCK_SIZE * COUNT(*) SIZE_BYTE,
        BI.SEGMENTS_PER_BUFFER_POOL,
        ROW_NUMBER() OVER (PARTITION BY O.DATA_OBJECT_ID ORDER BY 1) CLUSTRN
      FROM
        BASIS_INFO BI,
        GV$BH B,
        OBJECTS O, 
        SEGMENTS S,
        BUFFER_POOLS BP
      WHERE 
        B.INST_ID = BI.INSTANCE_NUMBER AND
        O.DATA_OBJECT_ID = B.OBJD AND
        S.OWNER = O.OWNER AND
        S.SEGMENT_NAME = O.OBJECT_NAME AND
        NVL(S.PARTITION_NAME, ' ') = NVL(O.SUBOBJECT_NAME, ' ') AND
        BP.NAME = S.BUFFER_POOL AND
        BP.BLOCK_SIZE = S.BLOCK_SIZE AND
        BP.INST_ID = B.INST_ID
      GROUP BY
        BP.NAME,
        BP.BLOCK_SIZE,
        S.OWNER,
        S.SEGMENT_NAME,
        S.PARTITION_NAME,
        BI.SEGMENTS_PER_BUFFER_POOL,
        O.DATA_OBJECT_ID
    )
    WHERE
      CLUSTRN = 1
    GROUP BY
      POOL_NAME,
      BLOCK_SIZE,
      OWNER,
      SEGMENT_NAME,
      SEGMENTS_PER_BUFFER_POOL
  )
  WHERE
    ( SEGMENTS_PER_BUFFER_POOL = -1 OR
      POOLN <= SEGMENTS_PER_BUFFER_POOL )
),
SHARED_POOL_AREAS AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    NAME,
    BYTES
  FROM
  ( SELECT
      SS.INST_ID,
      SS.NAME,
      SS.BYTES,
      BI.SHARED_POOL_AREAS
    FROM
      BASIS_INFO BI,
      GV$SGASTAT SS
    WHERE
      SS.INST_ID = BI.INSTANCE_NUMBER AND
      SS.POOL = 'shared pool'
    ORDER BY
      SS.BYTES DESC
  )
  WHERE
  ( SHARED_POOL_AREAS = -1 OR
    ROWNUM <= SHARED_POOL_AREAS )
),
SHARED_POOL_AREAS_MAX AS
( SELECT /*+ MATERIALIZE */
    SS.INSTANCE_NUMBER,
    SS.NAME,
    MAX(SS.BYTES) BYTES
  FROM
    BASIS_INFO BI,
    DBA_HIST_SGASTAT SS
  WHERE
    BI.DBID = SS.DBID AND
    BI.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
    SS.POOL = 'shared pool'
  GROUP BY
    SS.INSTANCE_NUMBER,
    SS.NAME
),
SQL_STATEMENTS AS
( SELECT /*+ MATERIALIZE */
    INST_ID,
    SQL_ID,
    SHARABLE_MEM / 1024 / 1024 SHARABLE_MEM_MB
  FROM
  ( SELECT
      SS.INST_ID,
      SS.SQL_ID,
      SS.SHARABLE_MEM,
      BI.SQL_STATEMENTS,
      ROW_NUMBER () OVER (PARTITION BY SS.INST_ID ORDER BY SHARABLE_MEM DESC ) RN 
    FROM
      BASIS_INFO BI,
      GV$SQLSTATS SS
    WHERE
      SS.INST_ID = BI.INSTANCE_NUMBER
  )
  WHERE
  ( SQL_STATEMENTS = -1 OR RN <= SQL_STATEMENTS )
)
SELECT
  'EVALUATION TIME:' COL1,
  TO_CHAR(SYSDATE, 'dd.mm.yyyy hh24:mi:ss') COL2,
  NULL COL3
FROM
  DUAL
UNION ALL
( SELECT
    'INSTANCE NUMBER:',
    TO_CHAR(INSTANCE_NUMBER),
    NULL
  FROM
    BASIS_INFO
)
UNION ALL
( SELECT NULL, NULL, NULL FROM DUAL )
UNION ALL
( SELECT 'GENERAL OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT '****************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT 'AREA', 'CURRENT_SIZE', 'MAXIMUM_SIZE' FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT
    NAME,
    TO_CHAR(VALUE, 999999999990.99)  || ' GB', 
    TO_CHAR(MAX_VALUE, 9999999990.99) || ' GB'
  FROM
  ( SELECT
      M.NAME,
      M.VALUE / 1024 VALUE,
      MM.VALUE / 1024 MAX_VALUE
    FROM
      BASIS_INFO BI,
      MEMORY_AREAS M,
      MEMORY_AREAS_MAX MM
    WHERE
      BI.DISPLAY_GENERAL = 'X' AND
      M.NAME = MM.NAME
    ORDER BY
      M.LINE
  )
)
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_GENERAL = 'X' )
UNION ALL
( SELECT 'SGA OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT '************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT 'AREA', 'CURRENT_SIZE', 'MAXIMUM_SIZE' FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT
    NAME,
    TO_CHAR(VALUE, 999999999990.99)  || ' MB', 
    TO_CHAR(MAX_VALUE, 9999999990.99) || ' MB'
  FROM
  ( SELECT
      DECODE(SA.NAME, 
        'buffer_cache', 'Buffer pool',
        'shared pool',  'Shared pool',
        'java pool',    'Java pool',
        'large pool',   'Large pool',
        'streams pool', 'Streams pool',
        'log_buffer',   'Log buffer',
        'fixed_sga',    'Fixed SGA',
        SA.NAME) NAME,
      SA.VALUE,
      GREATEST(SA.VALUE, SMA.VALUE) MAX_VALUE
    FROM
      BASIS_INFO BI,
      SGA_AREAS SA,
      SGA_AREAS_MAX SMA
    WHERE
      BI.DISPLAY_SGA = 'X' AND
      SA.NAME = SMA.NAME
    ORDER BY
      SA.VALUE DESC
  )
)
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SGA = 'X' )
UNION ALL
( SELECT 'BUFFER POOL OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_BUFFER_POOL = 'X' )
UNION ALL
( SELECT '********************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_BUFFER_POOL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_BUFFER_POOL = 'X' )
UNION ALL
( SELECT
    *
  FROM
  ( SELECT
      NAME,
      VALUE, 
      MAX_VALUE
    FROM
    ( SELECT
        NAME || ' (' || BLOCK_SIZE || ' byte)' NAME,
        NAME POOL_NAME,
        BLOCK_SIZE,
        1 LINE,
        TO_CHAR(CURRENT_SIZE, 999999999990.99)  || ' MB' VALUE,
        'Quality:' || TO_CHAR(QUALITY,  990.99) || ' %' MAX_VALUE
      FROM
        BASIS_INFO BI,
        BUFFER_POOLS BP
      WHERE
        BI.DISPLAY_BUFFER_POOL = 'X' 
      UNION ALL
      ( SELECT
          NULL NAME,
          NAME POOL_NAME,
          BLOCK_SIZE,
          2 LINE,
          NULL,
          NULL
        FROM
          BASIS_INFO BI,
          BUFFER_POOLS BP
        WHERE
          BI.DISPLAY_BUFFER_POOL = 'X' 
      )
      UNION ALL
      ( SELECT
          NAME,
          POOL_NAME,
          BLOCK_SIZE,
          2 + RN LINE,
          TO_CHAR(VALUE, 999999999990.99)  || ' MB' VALUE,
          TO_CHAR(MAX_VALUE, 99999999990.99) || ' %' MAX_VALUE
        FROM
        ( SELECT
            SEGMENT_NAME NAME,
            POOL_NAME,
            BPS.BLOCK_SIZE,
            ROW_NUMBER () OVER (PARTITION BY BPS.POOL_NAME, BPS.BLOCK_SIZE ORDER BY SIZE_BYTE DESC) RN,
            SIZE_BYTE / 1024 / 1024 VALUE,
            DECODE(BP.CURRENT_SIZE, 0, 0, BPS.SIZE_BYTE / 
              1024 / 1024 / BP.CURRENT_SIZE * 100) MAX_VALUE,
            BI.SEGMENTS_PER_BUFFER_POOL
          FROM
            BASIS_INFO BI,
            BUFFER_POOLS BP,
            BUFFER_POOL_SEGMENTS BPS
          WHERE
            BI.DISPLAY_BUFFER_POOL = 'X' AND
            BP.NAME = BPS.POOL_NAME AND
            BP.BLOCK_SIZE = BPS.BLOCK_SIZE
        )
      )
      UNION ALL
      ( SELECT
          NULL NAME,
          NAME POOL_NAME,
          BLOCK_SIZE,
          999999 LINE,
          NULL,
          NULL
        FROM
          BASIS_INFO BI,
          BUFFER_POOLS BP
        WHERE
          BI.DISPLAY_BUFFER_POOL = 'X' 
      )
    )
    ORDER BY
      POOL_NAME,
      BLOCK_SIZE,
      LINE
  )
)
UNION ALL
( SELECT 'SHARED POOL OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT '********************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT 'AREA', 'CURRENT_SIZE', 'MAXIMUM_SIZE' FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT
    NAME,
    TO_CHAR(VALUE, 999999999990.99)  || ' MB', 
    TO_CHAR(MAX_VALUE, 9999999990.99) || ' MB'
  FROM
  ( SELECT
      SA.NAME,
      SA.BYTES / 1024 / 1024 VALUE,
      GREATEST(SA.BYTES, NVL(SMA.BYTES, 0)) / 1024 / 1024 MAX_VALUE
    FROM
      BASIS_INFO BI,
      SHARED_POOL_AREAS SA,
      SHARED_POOL_AREAS_MAX SMA
    WHERE
      BI.DISPLAY_SHARED_POOL = 'X' AND
      SA.NAME = SMA.NAME (+)
    ORDER BY
      SA.BYTES DESC
  )
)
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SHARED_POOL = 'X' )
UNION ALL
( SELECT 'SQL AREA OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT '*****************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT 'SQL_ID', 'SHARABLE_MEMORY', NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT
    NAME,
    TO_CHAR(VALUE, 999999999990.99)  || ' MB', 
    NULL
  FROM
  ( SELECT
      SQ.SQL_ID NAME,
      SQ.SHARABLE_MEM_MB VALUE,
      NULL MAX_VALUE
    FROM
      BASIS_INFO BI,
      SQL_STATEMENTS SQ
    WHERE
      BI.DISPLAY_SQL = 'X' 
    ORDER BY
      SQ.SHARABLE_MEM_MB DESC
  )
)
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_SQL = 'X' )
UNION ALL
( SELECT 'PARAMETER OVERVIEW', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_PARAMETERS = 'X' )
UNION ALL
( SELECT '******************', NULL, NULL FROM BASIS_INFO WHERE DISPLAY_PARAMETERS = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_PARAMETERS = 'X' )
UNION ALL
( SELECT 'PARAMETER_NAME', 'PARAMETER_VALUE', 'IS_DEFAULT' FROM BASIS_INFO WHERE DISPLAY_PARAMETERS = 'X' )
UNION ALL
( SELECT NULL, NULL, NULL FROM BASIS_INFO WHERE DISPLAY_PARAMETERS = 'X' )
UNION ALL
( SELECT
    NAME,
    VALUE,
    ISDEFAULT
  FROM
  ( SELECT
      P.NAME,
      P.VALUE,
      P.ISDEFAULT
    FROM
      BASIS_INFO BI,
      PARAMETERS P
    WHERE
      BI.DISPLAY_PARAMETERS = 'X'
    ORDER BY
      P.NAME
  )
)
UNION ALL
( SELECT NULL, NULL, NULL FROM BUFFER_POOL_SEGMENTS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM BUFFER_POOLS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM SQL_STATEMENTS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM MEMORY_AREAS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM MEMORY_AREAS_MAX WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM SGA_AREAS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM SGA_AREAS_MAX WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM PARAMETERS WHERE 1 = 0 )
UNION ALL
( SELECT NULL, NULL, NULL FROM SHARED_POOL_AREAS WHERE 1 = 0 )
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d569442-014d-1000-806d-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Resources_Memory_PGA]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT NULL BEGIN_TIME, NULL PGA_PEAK_MB, NULL PGA_CURRENT_MB, NULL PGA_AUTO_MB, 
  NULL PGA_MANUAL_MB, NULL "PROCESSED_MB/H", NULL "TEMP_IO_MB/H", NULL "OVERALLOC/H"
  FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL BEGIN_TIME, NULL PGA_PEAK_MB, NULL PGA_CURRENT_MB, NULL PGA_AUTO_MB, 
  NULL PGA_MANUAL_MB, NULL "PROCESSED_MB/H", NULL "TEMP_IO_MB/H", NULL "OVERALLOC/H"
  FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), 
      INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    DECODE(AGGREGATE_BY,
      'SNAPSHOT',    'YYYY-MM-DD HH24:MI:SS',
      'DAY',         'YYYY-MM-DD (DY)',
      'HOUR_OF_DAY', 'HH24',
      AGGREGATE_BY ) AGGREGATE_BY
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 09:07:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 18:00:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      'SNAPSHOT' AGGREGATE_BY    /* SNAPSHOT, DAY, HOUR_OF_DAY or Oracle time pattern */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT /*+ MATERIALIZE */ 
    HSS2.DBID,
    HSS2.INSTANCE_NUMBER,
    HSS2.SNAP_ID,
    HSS1.SNAP_ID PREV_SNAP_ID,
    HSS2.BEGIN_INTERVAL_TIME,
    HSS2.END_INTERVAL_TIME,
    TO_CHAR(HSS2.END_INTERVAL_TIME, 'SSSSS') -
      TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'SSSSS') +
      86400 * (TO_CHAR(HSS2.END_INTERVAL_TIME, 'J') - 
               TO_CHAR(HSS2.BEGIN_INTERVAL_TIME, 'J'))
      INTERVAL_SECONDS,
    DECODE(HSS2.STARTUP_TIME, HSS1.STARTUP_TIME, 'NO', 'YES') RESTART
  FROM 
    BASIS_INFO BI,
    DBA_HIST_SNAPSHOT HSS1, 
    DBA_HIST_SNAPSHOT HSS2
  WHERE
    HSS2.DBID = BI.DBID AND
    HSS1.DBID (+) = HSS2.DBID AND
    HSS2.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS1.INSTANCE_NUMBER (+) = HSS2.INSTANCE_NUMBER AND
    HSS2.END_INTERVAL_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    HSS1.SNAP_ID (+) = HSS2.SNAP_ID - 1
  ORDER BY
    HSS2.SNAP_ID
)
SELECT
  BEGIN_TIME,
  TO_CHAR(PGA_PEAK_MB, 9999990.99) PGA_PEAK_MB,
  TO_CHAR(PGA_CURRENT_MB, 9999999990.99) PGA_CURRENT_MB,
  TO_CHAR(PGA_AUTO_MB, 9999990.99) PGA_AUTO_MB,
  TO_CHAR(PGA_MANUAL_MB, 999999990.99) PGA_MANUAL_MB,
  TO_CHAR(PROCESSED_MB / SECONDS * 3600, 9999999990.99) "PROCESSED_MB/H",
  TO_CHAR(TEMP_IO_MB / SECONDS * 3600, 99999990.99) "TEMP_IO_MB/H",
  TO_CHAR(OVERALLOCATIONS / SECONDS * 3600, 9999990.99) "OVERALLOC/H"
FROM
( SELECT
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY) BEGIN_TIME,
    SUM(SECONDS) SECONDS,
    MAX(PGA_PEAK_MB) PGA_PEAK_MB,
    MAX(PGA_CURRENT_MB) PGA_CURRENT_MB,
    MAX(PGA_AUTO_MB) PGA_AUTO_MB,
    MAX(PGA_MANUAL_MB) PGA_MANUAL_MB,
    SUM(PROCESSED_MB) PROCESSED_MB,
    SUM(TEMP_IO_MB) TEMP_IO_MB,
    SUM(OVERALLOCATIONS) OVERALLOCATIONS
  FROM
  ( SELECT
      SS.BEGIN_INTERVAL_TIME, 
      SS.INTERVAL_SECONDS SECONDS,
      HPS1.VALUE / 1024 / 1024 PGA_CURRENT_MB,
      NVL(HPS2.VALUE, 0) / 1024 / 1024 PGA_AUTO_MB,
      NVL(HPS3.VALUE, 0) / 1024 / 1024 PGA_MANUAL_MB,
      DECODE(HPS4.VALUE, NULL, 0, DECODE(SS.RESTART, 'YES', HPS4.VALUE, HPS4.VALUE - 
        LAG(HPS4.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1024 / 1024) PROCESSED_MB,
      DECODE(HPS5.VALUE, NULL, 0, DECODE(SS.RESTART, 'YES', HPS5.VALUE, HPS5.VALUE - 
        LAG(HPS5.VALUE, 1) OVER (ORDER BY SS.SNAP_ID)) / 1024 / 1024) TEMP_IO_MB,
      NVL(HPS6.VALUE, 0) / 1024 / 1024 PGA_PEAK_MB,
      DECODE(HPS7.VALUE, NULL, 0, DECODE(SS.RESTART, 'YES', HPS7.VALUE, HPS7.VALUE - 
        LAG(HPS7.VALUE, 1) OVER (ORDER BY SS.SNAP_ID))) OVERALLOCATIONS,
      SS.PREV_SNAP_ID,
      BI.AGGREGATE_BY
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_PGASTAT HPS1, 
      DBA_HIST_PGASTAT HPS2, 
      DBA_HIST_PGASTAT HPS3,
      DBA_HIST_PGASTAT HPS4,
      DBA_HIST_PGASTAT HPS5,
      DBA_HIST_PGASTAT HPS6,
      DBA_HIST_PGASTAT HPS7
    WHERE
      HPS1.DBID = SS.DBID AND
      HPS2.DBID (+) = SS.DBID AND
      HPS3.DBID (+) = SS.DBID AND
      HPS4.DBID (+) = SS.DBID AND
      HPS5.DBID (+) = SS.DBID AND
      HPS6.DBID (+) = SS.DBID AND
      HPS7.DBID (+) = SS.DBID AND
      HPS1.INSTANCE_NUMBER = SS.INSTANCE_NUMBER AND
      HPS2.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS3.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS4.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS5.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS6.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS7.INSTANCE_NUMBER (+) = SS.INSTANCE_NUMBER AND
      HPS1.SNAP_ID = SS.SNAP_ID AND
      HPS2.SNAP_ID (+) = SS.SNAP_ID AND
      HPS3.SNAP_ID (+) = SS.SNAP_ID AND
      HPS4.SNAP_ID (+) = SS.SNAP_ID AND
      HPS5.SNAP_ID (+) = SS.SNAP_ID AND
      HPS6.SNAP_ID (+) = SS.SNAP_ID AND
      HPS7.SNAP_ID (+) = SS.SNAP_ID AND
      HPS1.NAME = 'total PGA inuse' AND
      HPS2.NAME (+) = 'total PGA used for auto workareas' AND
      HPS3.NAME (+) = 'total PGA used for manual workareas' AND
      HPS4.NAME (+) = 'bytes processed' AND
      HPS5.NAME (+) = 'extra bytes read/written' AND
      HPS6.NAME (+) = 'maximum PGA allocated' AND
      HPS7.NAME (+) = 'over allocation count'
  )
  WHERE 
    PREV_SNAP_ID IS NOT NULL
  GROUP BY
    TO_CHAR(BEGIN_INTERVAL_TIME, AGGREGATE_BY)
  ORDER BY
    1 DESC
)
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
		<display id="2d570ec2-014d-1000-806e-7f0000014ee2" type="" style="Table" enable="true">
			<name><![CDATA[Resources_ResourceLimitsPerAWRInterval]]></name>
			<description><![CDATA[]]></description>
			<tooltip><![CDATA[]]></tooltip>
			<drillclass><![CDATA[null]]></drillclass>
			<CustomValues>
				<TYPE>horizontal</TYPE>
			</CustomValues>
			<query>
				<sql><![CDATA[SELECT  NULL BEGIN_TIME, NULL PROC_CUR, NULL PROC_MAX, NULL SESS_CUR, NULL SESS_MAX,
  NULL ENQ_CUR, NULL ENQ_MAX, NULL PX_CUR, NULL PX_MAX FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT  NULL BEGIN_TIME, NULL PROC_CUR, NULL PROC_MAX, NULL SESS_CUR, NULL SESS_MAX,
  NULL ENQ_CUR, NULL ENQ_MAX, NULL PX_CUR, NULL PX_MAX FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ MATERIALIZE */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME
  FROM
  ( SELECT
      -1 DBID,
      -1 INSTANCE_NUMBER,          
      TO_DATE('01.01.1000 01:04:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 01:05:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    HSS.SNAP_ID,
    HSS.BEGIN_INTERVAL_TIME BEGIN_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME 
)
SELECT
  TO_CHAR(BEGIN_TIME, 'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
  TO_CHAR(PROC_CUR, 9999990) PROC_CUR,
  TO_CHAR(PROC_MAX, 9999990) PROC_MAX,
  TO_CHAR(SESS_CUR, 9999990) SESS_CUR,
  TO_CHAR(SESS_MAX, 9999990) SESS_MAX,
  TO_CHAR(ENQ_CUR, 999990) ENQ_CUR,
  TO_CHAR(ENQ_MAX, 999990) ENQ_MAX,
  TO_CHAR(PX_CUR, 99990) PX_CUR,
  TO_CHAR(PX_MAX, 99990) PX_MAX
FROM
( SELECT
    SS.BEGIN_TIME,
    SUM(DECODE(RESOURCE_NAME, 'processes', CURRENT_UTILIZATION, 0)) PROC_CUR,
    SUM(DECODE(RESOURCE_NAME, 'processes', MAX_UTILIZATION, 0)) PROC_MAX,
    SUM(DECODE(RESOURCE_NAME, 'sessions', CURRENT_UTILIZATION, 0)) SESS_CUR,
    SUM(DECODE(RESOURCE_NAME, 'sessions', MAX_UTILIZATION, 0)) SESS_MAX,
    SUM(DECODE(RESOURCE_NAME, 'enqueue_locks', CURRENT_UTILIZATION, 0)) ENQ_CUR,
    SUM(DECODE(RESOURCE_NAME, 'enqueue_locks', MAX_UTILIZATION, 0)) ENQ_MAX,
    SUM(DECODE(RESOURCE_NAME, 'parallel_max_servers', CURRENT_UTILIZATION, 0)) PX_CUR,
    SUM(DECODE(RESOURCE_NAME, 'parallel_max_servers', MAX_UTILIZATION, 0)) PX_MAX,
    SS.SNAP_ID
  FROM
    SNAPSHOTS SS,
    DBA_HIST_RESOURCE_LIMIT RL
  WHERE
    SS.DBID = RL.DBID AND
    SS.INSTANCE_NUMBER = RL.INSTANCE_NUMBER AND
    SS.SNAP_ID = RL.SNAP_ID
  GROUP BY
    SS.BEGIN_TIME,
    SS.SNAP_ID
)
ORDER BY
  SNAP_ID DESC
))]]></sql>
			</query>
				<pdf version="VERSION_1_7" compression="CONTENT">
					<docproperty title="null" author="null" subject="null" keywords="null" />
					<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
					<column>
						<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
						<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
						<blob blob="NONE" zip="false" />
					</column>
					<table font="null" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
					<header enable="false" generatedate="false">
						<data>
						null						</data>
					</header>
					<footer enable="false" generatedate="false">
						<data value="null" />
					</footer>
					<security enable="false" useopenpassword="false" openpassword="null" encryption="EXCLUDE_METADATA">
						<permission enable="false" permissionpassword="null" allowcopying="true" allowprinting="true" allowupdating="false" allowaccessdevices="false" />
					</security>
					<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
				</pdf>
		</display>
	</folder>
</folder>
</displays>